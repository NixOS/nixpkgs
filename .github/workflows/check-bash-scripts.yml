# This file was copied from check-nix-format.yml for the logic to apply
# this only to those files which are already conforming on the target branch.
name: Check that shell scripts are formatted and shellcheck-ed

on:
  pull_request_target:
    # See the comment at the same location in ./nixpkgs-vet.yml
    types: [opened, synchronize, reopened, edited]
permissions:
  contents: read

jobs:
  nixos:
    name: shell-check
    runs-on: ubuntu-latest
    if: "!contains(github.event.pull_request.title, '[skip treewide]')"
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          # pull_request_target checks out the base branch by default
          ref: refs/pull/${{ github.event.pull_request.number }}/merge
          # Fetches the merge commit and its parents
          fetch-depth: 2
      - name: Checking out base branch
        run: |
          base=$(mktemp -d)
          baseRev=$(git rev-parse HEAD^1)
          git worktree add "$base" "$baseRev"
          echo "baseRev=$baseRev" >> "$GITHUB_ENV"
          echo "base=$base" >> "$GITHUB_ENV"
      - name: Get Nixpkgs revision for shellcheck and shfmt
        run: |
          # Pin to a commit from nixpkgs-unstable to avoid e.g. building shellcheck or shfmt
          # from staging.
          # This should not be a URL, because it would allow PRs to run arbitrary code in CI!
          rev=$(jq -r .rev ci/pinned-nixpkgs.json)
          echo "url=https://github.com/NixOS/nixpkgs/archive/$rev.tar.gz" >> "$GITHUB_ENV"
      - uses: cachix/install-nix-action@08dcb3a5e62fa31e2da3d490afc4176ef55ecd72 # v30
        with:
          # explicitly enable sandbox
          extra_nix_config: sandbox = true
          nix_path: nixpkgs=${{ env.url }}
      - name: Install shellcheck and shfmt
        run: "nix-env -f '<nixpkgs>' -iAP shellcheck shfmt"
      - name: Check that shell scripts are conforming
        run: |
          shfmtFiles=()
          shellcheckFiles=()

          # TODO: Make this more parallel

          # Loop through all .sh files touched by the PR
          while readarray -d '' -n 2 entry && (( ${#entry[@]} != 0 )); do
            type=${entry[0]}
            file=${entry[1]}
            case $type in
              A*)
                source=""
                dest=$file
                ;;
              M*)
                source=$file
                dest=$file
                ;;
              C*|R*)
                source=$file
                read -r -d '' dest
                ;;
              *)
                echo "Ignoring file $file with type $type"
                continue
            esac

            # Ignore files that weren't already formatted
            if [[ -n "$source" ]] && ! shfmt --diff ${{ env.base }}/"$source" >/dev/null; then
              echo "Ignoring file $file because it's not formatted in the base commit"
            elif ! shfmt --diff "$dest"; then
              shfmtFiles+=("$dest")
            fi

            # Ignore files that weren't already shellcheck-ed
            if [[ -n "$source" ]] && ! shellcheck ${{ env.base }}/"$source" >/dev/null; then
              echo "Ignoring file $file because it's not shellcheck-ed in the base commit"
            elif ! shellcheck "$dest"; then
              shellcheckFiles+=("$dest")
            fi
          done < <(git diff -z --name-status ${{ env.baseRev }} -- '*.sh')

          if (( "${#shfmtFiles[@]}" > 0 )); then
            echo "Some new/changed shell scripts are not properly formatted"
            echo "Please go to the Nixpkgs root directory, run \`nix-shell\`, then:"
            echo "shfmt -w ${shfmtFiles[*]@Q}"
            echo
          fi

          if (( "${#shellcheckFiles[@]}" > 0 )); then
            echo "Some new/changed shell scripts are not properly shellcheck-ed"
            echo "Please go to the Nixpkgs root directory, run \`nix-shell\`, then:"
            echo "shellcheck ${shellcheckFiles[*]@Q}"
            echo
          fi

          if (( "${#shfmtFiles[@]}" + "${#shellcheckFiles[@]}" > 0 ))
            exit 1
          fi
