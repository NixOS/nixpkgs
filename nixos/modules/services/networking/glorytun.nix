{ pkgs, lib, config, ... }:

with lib;

let
  cfg = config.networking.glorytun;
  pathOpts = { ... }: {
    options = {
      outboundInterfaceName = mkOption {
        example = "eth0";
        type = with types; str;
        description = "Which interface to bind this path to.";
      };
      txRate = mkOption {
        default = 12500000;
        type = with types; int;
        description =
          "The outbound transfer rate of the path. If autoRate is true, this is the max value.";
      };
      rxRate = mkOption {
        default = 12500000;
        type = with types; int;
        description =
          "The inbound transfer rate of the path. If autoRate is true, this is the max value.";
      };
      backup = mkOption {
        default = false;
        type = with types; bool;
        description = "Only use this path if all non-backup paths are down.";
      };
      autoRate = mkOption {
        default = false;
        type = with types; bool;
        description = "Automatically adjust rated bandwidth of the path.";
      };
      beat = mkOption {
        default = null;
        type = with types; nullOr float;
        description = "How often in seconds to check the status of the path.";
      };
      lossLimit = mkOption {
        default = null;
        type = with types; nullOr int;
        description =
          "The max percentage of lost packets before marking the interface as down.";
      };
    };
  };
  interfaceOpts = { ... }: {

    options = {
      keyFile = mkOption {
        example = "/private/glorytun_key";
        type = with types; str;
        default = null;
        description = ''
          File pointing to preshared key as generated by <command>glorytun keygen</command>.
          The shared key that glorytun will use to connect.
        '';
      };
      bindAddress = mkOption {
        default = "0.0.0.0";
        type = with types; str;
        description = ''
          The address glorytun will bind to. Currently glorytun can only work
          on IPv4 or IPv6, but not both at the same time.'';
      };
      bindPort = mkOption {
        default = null;
        type = with types; nullOr int;
        description = "Local port to bind to.";
      };
      remoteAddress = mkOption {
        example = "8.8.8.8";
        type = with types; nullOr str;
        default = null;
        description = ''
          The address of the remote glorytun endpoint. Client side option only.
          If this option is set glorytun will act as a client. If null it will be a server.'';
      };
      remotePort = mkOption {
        default = null;
        type = with types; nullOr int;
        description = "Port of the remote server.";
      };
      chacha = mkOption {
        default = false;
        type = with types; bool;
        description = ''
          Force the use of chacha instead of AES. Older processors don't have hardware support for AES
          and will perform slower than chacha.
        '';
      };
      persist = mkOption {
        default = false;
        type = with types; bool;
        description = "Keep the tun interface around after the process dies.";
      };
      paths = mkOption {
        default = [ ];
        example = [{
          outboundInterfaceName = "enp3s0";
          autoRate = true;
        }];
        type = with types; listOf (submodule pathOpts);
        description = "Client side paths to set up to the remote";
      };
    };
  };

  generatePathUnit =
    { glorytunInterfaceName, glorytunInterfaceConfig, pathCfg }:
    let
      dev = glorytunInterfaceName;
      oif = pathCfg.outboundInterfaceName;
      serviceName = pathUnitServiceName dev oif;
      preScript = ''
        SRC=$(${pkgs.iproute2}/bin/ip route get oif "${oif}" "${glorytunInterfaceConfig.remoteAddress}" | ${pkgs.gawk}/bin/awk '/src/{getline;print $0}' RS=' ')
        if [ -z "$SRC" ]; then
          echo could not find route to remote "${glorytunInterfaceConfig.remoteAddress}" on interface "${oif}" >&2
          exit 1
        fi
      '';
    in nameValuePair "glorytun-${dev}-path-${oif}" {
      description =
        "Glorytun Path - ${glorytunInterfaceName} - ${pathCfg.outboundInterfaceName}";
      requires = [ "glorytun-${glorytunInterfaceName}.service" ];
      after = [ "glorytun-${glorytunInterfaceName}.service" ];
      wantedBy =
        [ "multi-user.target" "glorytun-${glorytunInterfaceName}.service" ];
      environment.DEVICE = glorytunInterfaceName;
      path = with pkgs; [ iproute2 gawk coreutils cfg.package ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        Restart = "on-failure";
        RestartSec = "60";
      };

      script = let
        targetState = if pathCfg.backup then "backup" else "up";
        setup = concatStringsSep " " ([
          ''
            "${cfg.package}/bin/glorytun" path "$SRC" dev "${glorytunInterfaceName}" ${targetState} rate''
        ] ++ optional pathCfg.autoRate "auto" ++ [
          "rx ${builtins.toString pathCfg.rxRate} tx ${
            builtins.toString pathCfg.txRate
          }"
        ] ++ optional (pathCfg.beat != null)
          "beat ${builtins.toString pathCfg.beat}"
          ++ optional (pathCfg.lossLimit != null)
          "losslimit ${pathCfg.lossLimit}");
      in ''
        ${preScript}
        ${setup}
      '';

      postStop = ''
        ${preScript}
        "${cfg.package}/bin/glorytun" path "$SRC" dev "${glorytunInterfaceName}" down
      '';
    };

  generateInterfaceUnit = name: values:
    let
    in nameValuePair "glorytun-${name}" {
      description = "Glorytun Tunnel - ${name} ";
      after = [ "network.target" ];
      wantedBy = [ "multi-user.target" ];
      path = with pkgs; [ iproute2 cfg.package ];

      serviceConfig = {
        Type = "simple";
        Restart = "always";
      };
      script = let
        bindStr = concatStringsSep " " ([ "${values.bindAddress}" ]
          ++ optional (values.bindPort != null) "${bindPort}");
        remoteStr = optional (values.remoteAddress != null)
          (concatStringsSep " " ([ "to ${values.remoteAddress}" ]
            ++ optional (values.remotePort != null) "${values.remotePort}"));
        setup = concatStringsSep " "
          ([ "exec ${cfg.package}/bin/glorytun bind ${bindStr}" ] ++ remoteStr
            ++ [ "dev ${name} keyfile ${values.keyFile}" ]
            ++ optional (values.chacha) "chacha"
            ++ optional (values.persist) "persist");
      in ''
        ${setup}
      '';
    };

in {
  options.networking.glorytun = {
    enable = mkEnableOption "Enable glorytun";

    package = mkOption {
      type = types.package;
      default = pkgs.glorytun;
      defaultText = "pkgs.glorytun";
      description = "Set version of glorytun package to use.";
    };

    interfaces = mkOption {
      description = ''
        Glorytun interfaces. NOTE: This module does not configure the IP, Routes, or Firewall of the interface.
              '';
      default = { };
      example = {
        gtc-main = { keyFile = "/etc/glory/gtc-main.key"; };
        remoteAddress = "1.1.1.1";
        chacha = true;
        paths = [{
          outboundInterfaceName = "enp3s0";
          autoRate = true;
        }];
      };
      type = with types; attrsOf (submodule interfaceOpts);
    };
  };

  config = mkIf cfg.enable (let
    all_paths = flatten (mapAttrsToList
      (glorytunInterfaceName: glorytunInterfaceConfig:
        map (pathCfg: {
          inherit glorytunInterfaceName glorytunInterfaceConfig pathCfg;
        }) glorytunInterfaceConfig.paths) cfg.interfaces);
  in {
    environment.systemPackages =
      [ cfg.package ]; # if user should have the command available as well

    systemd.services = (mapAttrs' generateInterfaceUnit cfg.interfaces)
      // (listToAttrs (map generatePathUnit all_paths));

  });

  meta.maintainers = with lib.maintainers; [ georgyo ];
}
