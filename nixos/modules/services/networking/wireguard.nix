{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.networking.wireguard;

  kernel = config.boot.kernelPackages;

  # interface options

  interfaceOpts = { config, ... }: {

    options = {

      ips = mkOption {
        example = [ "192.168.2.1/24" ];
        default = [];
        type = with types; listOf str;
        description = "The IP addresses of the interface.";
      };

      privateKey = mkOption {
        example = "yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=";
        type = with types; nullOr str;
        default = null;
        description = ''
          Base64 private key generated by <command>wg genkey</command>.

          Warning: Consider using privateKeyFile instead if you do not
          want to store the key in the world-readable Nix store.
        '';
      };

      generatePrivateKeyFile = mkOption {
        default = false;
        type = types.bool;
        description = ''
          Automatically generate a private key with
          <command>wg genkey</command>, at the privateKeyFile location.
        '';
      };

      privateKeyFile = mkOption {
        example = "/private/wireguard_key";
        type = with types; nullOr str;
        default = null;
        description = ''
          Private key file as generated by <command>wg genkey</command>.
        '';
      };

      listenPort = mkOption {
        default = null;
        type = with types; nullOr port;
        example = 51820;
        description = ''
          16-bit port for listening. Optional; if not specified,
          automatically generated based on interface name.
        '';
      };

      preSetup = mkOption {
        example = literalExample ''
          ${pkgs.iproute2}/bin/ip netns add foo
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = ''
          Commands called at the start of the interface setup.
        '';
      };

      postSetup = mkOption {
        example = literalExample ''
          printf "nameserver 10.200.100.1" | ${pkgs.openresolv}/bin/resolvconf -a wg0 -m 0
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called at the end of the interface setup.";
      };

      postShutdown = mkOption {
        example = literalExample "${pkgs.openresolv}/bin/resolvconf -d wg0";
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called after shutting down the interface.";
      };

      table = mkOption {
        default = "main";
        type = types.str;
        description = ''
          The kernel routing table to add this interface's
          associated routes to. Setting this is useful for e.g. policy routing
          ("ip rule") or virtual routing and forwarding ("ip vrf"). Both
          numeric table IDs and table names (/etc/rt_tables) can be used.
          Defaults to "main".
        '';
      };

      peers = mkOption {
        default = [];
        description = "Peers linked to the interface.";
        type = with types; listOf (submodule peerOpts);
      };

      peersAnnouncing = {
        enable = mkEnableOption ''
          announcing of peers' endpoints.
        '';
        listenPort = mkOption {
          type = types.port;
          defaultText = "<option>networking.wireguard.listenPort</option> or 51820 if null";
          description = ''
            TCP port on which to listen for peers queries for other peers' endpoints.

            <warning><para>
            This exposes the public key and current (or last known) endpoint address of all the peers
            configured in the WireGuard interface, to all the peers,
            and to any host connected to the peers or announcing peer
            able to query the WireGuard interface
            by spoofing the allowedIPs of any peer.
            </para></warning>
          '';
        };
      };

      allowedIPsAsRoutes = mkOption {
        example = false;
        default = true;
        type = types.bool;
        description = ''
          Determines whether to add allowed IPs as routes or not.
        '';
      };

      socketNamespace = mkOption {
        default = null;
        type = with types; nullOr str;
        example = "container";
        description = ''The pre-existing network namespace in which the
        WireGuard interface is created, and which retains the socket even if the
        interface is moved via <option>interfaceNamespace</option>. When
        <literal>null</literal>, the interface is created in the init namespace.
        See <link
        xlink:href="https://www.wireguard.com/netns/">documentation</link>.
        '';
      };

      interfaceNamespace = mkOption {
        default = null;
        type = with types; nullOr str;
        example = "init";
        description = ''The pre-existing network namespace the WireGuard
        interface is moved to. The special value <literal>init</literal> means
        the init namespace. When <literal>null</literal>, the interface is not
        moved.
        See <link
        xlink:href="https://www.wireguard.com/netns/">documentation</link>.
        '';
      };
    };

    config = {
      peersAnnouncing = {
        listenPort = mkDefault (if config.listenPort == null then 51820 else config.listenPort);
      };
    };

  };

  # peer options

  peerOpts = { config, ... }: {

    options = {

      publicKey = mkOption {
        example = "xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=";
        type = types.str;
        description = "The base64 public key of the peer.";
      };

      presharedKey = mkOption {
        default = null;
        example = "rVXs/Ni9tu3oDBLS4hOyAUAa1qTWVA3loR8eL20os3I=";
        type = with types; nullOr str;
        description = ''
          Base64 preshared key generated by <command>wg genpsk</command>.
          Optional, and may be omitted. This option adds an additional layer of
          symmetric-key cryptography to be mixed into the already existing
          public-key cryptography, for post-quantum resistance.

          Warning: Consider using presharedKeyFile instead if you do not
          want to store the key in the world-readable Nix store.
        '';
      };

      presharedKeyFile = mkOption {
        default = null;
        example = "/private/wireguard_psk";
        type = with types; nullOr str;
        description = ''
          File pointing to preshared key as generated by <command>wg genpsk</command>.
          Optional, and may be omitted. This option adds an additional layer of
          symmetric-key cryptography to be mixed into the already existing
          public-key cryptography, for post-quantum resistance.
        '';
      };

      allowedIPs = mkOption {
        example = [ "10.192.122.3/32" "10.192.124.1/24" ];
        type = with types; listOf str;
        description = ''List of IP (v4 or v6) addresses with CIDR masks from
        which this peer is allowed to send incoming traffic and to which
        outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may
        be specified for matching all IPv4 addresses, and ::/0 may be specified
        for matching all IPv6 addresses.'';
      };

      endpoint = mkOption {
        default = null;
        example = "demo.wireguard.io:12913";
        type = with types; nullOr str;
        description = ''Endpoint IP or hostname of the peer, followed by a colon,
        and then a port number of the peer.

        Warning for endpoints with changing IPs:
        The WireGuard kernel side cannot perform DNS resolution.
        Thus DNS resolution is done once by the <literal>wg</literal> userspace
        utility, when setting up WireGuard. Consequently, if the IP address
        behind the name changes, WireGuard will not notice.
        This is especially common for dynamic-DNS setups, but also applies to
        any other DNS-based setup.
        If you do not use IP endpoints, you likely want to set
        <option>networking.wireguard.dynamicEndpointRefreshSeconds</option>
        to refresh the IPs periodically.
        '';
      };

      endpointsUpdater = {
        enable = mkEnableOption ''
          receiving the enpoint of other peers from a periodic TCP connection.
          That connection is meant to be to a peer using <option>networking.wireguard.peersAnnouncing.enable</option>.

          This is especially useful to punch-through non-symmetric NATs
          effectively establishing peer-to-peer connectivity:
          the peers initiate a Wireguard connection to the announcing peer,
          then use that Wireguard tunnel to query the endpoints of the other peers
          to establish Wireguard tunnels to them,
          using UDP hole punching when both peers are behind non-symmetric NATs.

          Note that it can also work for two peers behind the same NAT
          if that NAT can reflect (to its internal network) connections
          from its internal network to its external IP address,
          which may require to set persistentKeepalive as low as 1
          and/or redirecting at least one host's WireGuard port, eg. with UPnP.
        '';
        addr = mkOption {
          type = types.str;
          defaultText = "address of the first item of the peer's <option>allowedIPs</option>";
          description = ''
            Address at which to contact the announcing peer,
            configured on the announcing peer's <option>networking.wireguard.ips</option>.
          '';
        };
        port = mkOption {
          type = types.port;
          defaultText = "port of the peer's endpoint";
          description = ''
            TCP port on which to contact the peer announcing other peers.
            This is configured on the announcing peer's <option>networking.wireguard.peersAnnouncing.listenPort</option>.
          '';
        };
        refreshSeconds = mkOption {
          type = with types; int;
          example = 120;
          default = 60;
          description = ''
            Time to wait between two successive queries of the endpoints known by the peer.
          '';
        };
      };

      dynamicEndpointRefreshSeconds = mkOption {
        default = 0;
        example = 5;
        type = with types; int;
        description = ''
          Periodically re-execute the <literal>wg</literal> utility every
          this many seconds in order to let WireGuard notice DNS / hostname
          changes.

          Setting this to <literal>0</literal> disables periodic reexecution.
        '';
      };

      persistentKeepalive = mkOption {
        default = null;
        type = with types; nullOr int;
        example = 25;
        description = ''This is optional and is by default off, because most
        users will not need it. It represents, in seconds, between 1 and 65535
        inclusive, how often to send an authenticated empty packet to the peer,
        for the purpose of keeping a stateful firewall or NAT mapping valid
        persistently. For example, if the interface very rarely sends traffic,
        but it might at anytime receive traffic from a peer, and it is behind
        NAT, the interface might benefit from having a persistent keepalive
        interval of 25 seconds; however, most users will not need this.'';
      };

    };

    config = {
      endpointsUpdater = {
        addr = mkDefault (head (builtins.match "^\([^/]*\).*$" (head (config.allowedIPs))));
        port = mkDefault (toInt (head (builtins.match "^.*:\([0-9]*\)$" config.endpoint)));
      };
    };

  };

  generateKeyServiceUnit = name: values:
    assert values.generatePrivateKeyFile;
    nameValuePair "wireguard-${name}-key"
      {
        description = "WireGuard Tunnel - ${name} - Key Generator";
        wantedBy = [ "wireguard-${name}.service" ];
        requiredBy = [ "wireguard-${name}.service" ];
        before = [ "wireguard-${name}.service" ];
        path = with pkgs; [ wireguard-tools ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
        };

        script = ''
          set -e

          # If the parent dir does not already exist, create it.
          # Otherwise, does nothing, keeping existing permisions intact.
          mkdir -p --mode 0755 "${dirOf values.privateKeyFile}"

          if [ ! -f "${values.privateKeyFile}" ]; then
            # Write private key file with atomically-correct permissions.
            (set -e; umask 077; wg genkey > "${values.privateKeyFile}")
          fi
        '';
      };

  keyToUnitName = replaceChars
    [ "/" "-"    " "     "+"     "="      ]
    [ "-" "\\x2d" "\\x20" "\\x2b" "\\x3d" ];

  peerUnitServiceName = interfaceName: publicKey: dynamicRefreshEnabled:
    let
      unitName = keyToUnitName publicKey;
      refreshSuffix = optionalString dynamicRefreshEnabled "-refresh";
    in
      "wireguard-${interfaceName}-peer-${unitName}${refreshSuffix}";

  generatePeerUnit = { interfaceName, interfaceCfg, peer }:
    let
      psk =
        if peer.presharedKey != null
          then pkgs.writeText "wg-psk" peer.presharedKey
          else peer.presharedKeyFile;
      src = interfaceCfg.socketNamespace;
      dst = interfaceCfg.interfaceNamespace;
      ip = nsWrap "ip" src dst;
      wg = nsWrap "wg" src dst;
      dynamicRefreshEnabled = peer.dynamicEndpointRefreshSeconds != 0;
      # We generate a different name (a `-refresh` suffix) when `dynamicEndpointRefreshSeconds`
      # to avoid that the same service switches `Type` (`oneshot` vs `simple`),
      # with the intent to make scripting more obvious.
      serviceName = peerUnitServiceName interfaceName peer.publicKey dynamicRefreshEnabled;
    in nameValuePair serviceName
      {
        description = "WireGuard Peer - ${interfaceName} - ${peer.publicKey}";
        requires = [ "wireguard-${interfaceName}.service" ];
        after = [ "wireguard-${interfaceName}.service" ];
        wantedBy = [ "multi-user.target" "wireguard-${interfaceName}.service" ];
        environment.DEVICE = interfaceName;
        environment.WG_ENDPOINT_RESOLUTION_RETRIES = "infinity";
        path = with pkgs; [ iproute2 wireguard-tools ];

        unitConfig = {
          StartLimitIntervalSec = 0;
        };
        serviceConfig =
          {
            # Overcomes failure to resolve the endpoint's host
            # (eg, when the resolver is not yet reachable).
            Restart = "on-failure";
          } // (
          if !dynamicRefreshEnabled
            then
              {
                Type = "oneshot";
                RemainAfterExit = true;
              }
            else
              {
                Type = "simple"; # re-executes 'wg' indefinitely
                # Note that `Type = "oneshot"` services with `RemainAfterExit = true`
                # cannot be used with systemd timers (see `man systemd.timer`),
                # which is why `simple` with a loop is the best choice here.
                # It also makes starting and stopping easiest.
              }
          );

        script = let
          wg_setup = concatStringsSep " " (
            [ ''${wg} set ${interfaceName} peer "${peer.publicKey}"'' ]
            ++ optional (psk != null) ''preshared-key "${psk}"''
            ++ optional (peer.endpoint != null) ''endpoint "${peer.endpoint}"''
            ++ optional (peer.persistentKeepalive != null) ''persistent-keepalive "${toString peer.persistentKeepalive}"''
            ++ optional (peer.allowedIPs != []) ''allowed-ips "${concatStringsSep "," peer.allowedIPs}"''
          );
          route_setup =
            optionalString interfaceCfg.allowedIPsAsRoutes
              (concatMapStringsSep "\n"
                (allowedIP:
                  ''${ip} route replace "${allowedIP}" dev "${interfaceName}" table "${interfaceCfg.table}"''
                ) peer.allowedIPs);
        in ''
          ${wg_setup}
          ${route_setup}

          ${optionalString (peer.dynamicEndpointRefreshSeconds != 0) ''
            # Re-execute 'wg' periodically to notice DNS / hostname changes.
            # Note this will not time out on transient DNS failures such as DNS names
            # because we have set 'WG_ENDPOINT_RESOLUTION_RETRIES=infinity'.
            # Also note that 'wg' limits its maximum retry delay to 20 seconds as of writing.
            while ${wg_setup}; do
              sleep "${toString peer.dynamicEndpointRefreshSeconds}";
            done
          ''}
        '';

        postStop = let
          route_destroy = optionalString interfaceCfg.allowedIPsAsRoutes
            (concatMapStringsSep "\n"
              (allowedIP:
                ''${ip} route delete "${allowedIP}" dev "${interfaceName}" table "${interfaceCfg.table}"''
              ) peer.allowedIPs);
        in ''
          ${wg} set "${interfaceName}" peer "${peer.publicKey}" remove
          ${route_destroy}
        '';
      };

  generateInterfaceUnit = name: values:
    # exactly one way to specify the private key must be set
    #assert (values.privateKey != null) != (values.privateKeyFile != null);
    let privKey = if values.privateKeyFile != null then values.privateKeyFile else pkgs.writeText "wg-key" values.privateKey;
        src = values.socketNamespace;
        dst = values.interfaceNamespace;
        ipPreMove  = nsWrap "ip" src null;
        ipPostMove = nsWrap "ip" src dst;
        wg = nsWrap "wg" src dst;
        ns = if dst == "init" then "1" else dst;

    in
    nameValuePair "wireguard-${name}"
      {
        description = "WireGuard Tunnel - ${name}";
        requires = [ "network-online.target" ];
        after = [ "network.target" "network-online.target" ];
        wantedBy = [ "multi-user.target" ];
        environment.DEVICE = name;
        path = with pkgs; [ kmod iproute2 wireguard-tools ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
        };

        script = ''
          ${optionalString (!config.boot.isContainer) "modprobe wireguard || true"}

          ${values.preSetup}

          ${ipPreMove} link add dev "${name}" type wireguard
          ${optionalString (values.interfaceNamespace != null && values.interfaceNamespace != values.socketNamespace) ''${ipPreMove} link set "${name}" netns "${ns}"''}

          ${concatMapStringsSep "\n" (ip:
            ''${ipPostMove} address add "${ip}" dev "${name}"''
          ) values.ips}

          ${concatStringsSep " " (
            [ ''${wg} set "${name}" private-key "${privKey}"'' ]
            ++ optional (values.listenPort != null) ''listen-port "${toString values.listenPort}"''
          )}

          ${ipPostMove} link set up dev "${name}"

          ${values.postSetup}
        '';

        postStop = ''
          ${ipPostMove} link del dev "${name}"
          ${values.postShutdown}
        '';
      };

  # See:
  # - systemd-analyze security wireguard-${iface}-peers-announcing@
  # - systemd-analyze security wireguard-${iface}-endpoints-updater-${public_key}.service
  # Note that PrivateUsers=true would be too restrictive wrt. capabilities.
  peerUpdateSecurity = {
    IPAddressDeny = "any";
    # For running wg(1)
    AmbientCapabilities = [ "CAP_NET_ADMIN" ];
    CapabilityBoundingSet = [ "CAP_NET_ADMIN" ];
    RestrictNamespaces = true;
    DynamicUser = true;
    PrivateDevices = true;
    ProtectClock = true;
    ProtectControlGroups = true;
    ProtectHome = true;
    ProtectKernelLogs = true;
    ProtectKernelModules = true;
    ProtectKernelTunables = true;
    ProtectProc = "invisible";
    SystemCallArchitectures = "native";
    # Remove (likely) unused groups from the basic @system-service group
    SystemCallFilter = [
      "@system-service"
      "~@aio" "~@chown" "~@keyring" "~@privileged"
      "~@memlock" "~@resources" "~@setuid"
    ];
    RestrictRealtime = true;
    LockPersonality = true;
    MemoryDenyWriteExecute = true;
    UMask = 0077;
    ProtectHostname = true;
    ProcSubset = "pid";
  };

  generatePeersAnnouncingSocket = name: values:
    nameValuePair "wireguard-${name}-peers-announcing"
      {
        enable = values.peersAnnouncing.enable;
        listenStreams = [(toString values.peersAnnouncing.listenPort)];
        socketConfig.Accept = true;
        # Basic firewalling restricting answers to peers
        # querying an internal IP address of the announcing peer.
        # Note that IPv4 addresses can be spoofed using other interfaces unless
        # sysctl net.ipv4.conf.${name}.rp_filter=1
        socketConfig.BindToDevice = name;
        socketConfig.IPAddressAllow = map (peer: peer.allowedIPs) values.peers;
        socketConfig.IPAddressDeny = "any";
        socketConfig.MaxConnectionsPerSource = 1;
        socketConfig.ReusePort = true;
        wantedBy = [ "sockets.target" ];
      };

  generatePeersAnnouncingUnit = name: values:
    nameValuePair "wireguard-${name}-peers-announcing@"
      {
        description = "WireGuard Peers Announcing - ${name}";
        requires = [ "wireguard-${name}.service" ];
        after = [ "wireguard-${name}.service" ];

        serviceConfig = mkMerge [
          peerUpdateSecurity
          {
            Type = "simple";
            ExecStart = "${pkgs.wireguard-tools}/bin/wg show '${name}' endpoints";
            StandardInput = "null";
            StandardOutput = "socket";
            RestrictAddressFamilies = "";
          }
          (mkIf (values.interfaceNamespace != null)
            { NetworkNamespacePath = "/var/run/netns/${values.interfaceNamespace}"; })
        ];
      };

  generateEndpointsUpdaterUnit = { interfaceName, interfaceCfg, peer }: let
      dynamicRefreshEnabled = peer.dynamicEndpointRefreshSeconds != 0;
      peerService = peerUnitServiceName interfaceName peer.publicKey dynamicRefreshEnabled;
    in
    nameValuePair "wireguard-${interfaceName}-endpoints-updater-${keyToUnitName peer.publicKey}"
      {
        description = "WireGuard ${interfaceName} Endpoints Updater - ${peer.publicKey}";
        requires = [ "${peerService}.service" ];
        after = [ "${peerService}.service" ];
        wantedBy = [ "${peerService}.service" ];
        path = with pkgs; [ wireguard-tools ];

        unitConfig = {
          StartLimitIntervalSec = 0;
        };
        serviceConfig = mkMerge [
          peerUpdateSecurity
          {
            Type = "simple";
            IPAddressAllow = [ peer.endpointsUpdater.addr ];
            RestrictAddressFamilies = [ "AF_INET" "AF_INET6" "AF_NETLINK" ];
            Restart = "on-failure";
          }
          (mkIf (interfaceCfg.interfaceNamespace != null)
            { NetworkNamespacePath = "/var/run/netns/${interfaceCfg.interfaceNamespace}"; })
        ];

        # Query the peer announcing other peers
        # for setting the current endpoint of all configured peers
        # (but the announcing peer).
        # Note that socat is used instead of libressl's netcat
        # (which would require MemoryDenyWriteExecute=true to load libtls.so)
        # or netcat-gnu (which does not work on ARM and has last been released in 2004).
        script = ''
          wait="${toString peer.endpointsUpdater.refreshSeconds}"
          declare -A configured_keys
          configured_keys=(${concatMapStringsSep " " (p:
            optionalString (p.publicKey != peer.publicKey) "[${p.publicKey}]=set")
            interfaceCfg.peers})

          while true; do
            # Set stdin to socat's stdout
            exec < <(exec ${pkgs.socat}/bin/socat STDOUT \
              "TCP:${with peer.endpointsUpdater; addr+":"+toString port}")

            # Update the endpoint of each configured peer
            while read -t "$wait" -n 128 -r public_key endpoint x; do
              if [ "$endpoint" != "(none)" -a "''${configured_keys[$public_key]}" ]; then
                wg set "${interfaceName}" peer "$public_key" endpoint "$endpoint"
              fi;
            done

            sleep "$wait"
          done
        '';
      };

  nsWrap = cmd: src: dst:
    let
      nsList = filter (ns: ns != null) [ src dst ];
      ns = last nsList;
    in
      if (length nsList > 0 && ns != "init") then ''ip netns exec "${ns}" "${cmd}"'' else cmd;
in

{

  ###### interface

  options = {

    networking.wireguard = {

      enable = mkOption {
        description = "Whether to enable WireGuard.";
        type = types.bool;
        # 2019-05-25: Backwards compatibility.
        default = cfg.interfaces != {};
        example = true;
      };

      interfaces = mkOption {
        description = "WireGuard interfaces.";
        default = {};
        example = {
          wg0 = {
            ips = [ "192.168.20.4/24" ];
            privateKey = "yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=";
            peers = [
              { allowedIPs = [ "192.168.20.1/32" ];
                publicKey  = "xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=";
                endpoint   = "demo.wireguard.io:12913"; }
            ];
          };
        };
        type = with types; attrsOf (submodule interfaceOpts);
      };

    };

  };


  ###### implementation

  config = mkIf cfg.enable (let
    all_peers = flatten
      (mapAttrsToList (interfaceName: interfaceCfg:
        map (peer: { inherit interfaceName interfaceCfg peer;}) interfaceCfg.peers
      ) cfg.interfaces);
  in {

    assertions = (attrValues (
        mapAttrs (name: value: {
          assertion = (value.privateKey != null) != (value.privateKeyFile != null);
          message = "Either networking.wireguard.interfaces.${name}.privateKey or networking.wireguard.interfaces.${name}.privateKeyFile must be set.";
        }) cfg.interfaces))
      ++ (attrValues (
        mapAttrs (name: value: {
          assertion = value.generatePrivateKeyFile -> (value.privateKey == null);
          message = "networking.wireguard.interfaces.${name}.generatePrivateKeyFile must not be set if networking.wireguard.interfaces.${name}.privateKey is set.";
        }) cfg.interfaces))
        ++ map ({ interfaceName, peer, ... }: {
          assertion = (peer.presharedKey == null) || (peer.presharedKeyFile == null);
          message = "networking.wireguard.interfaces.${interfaceName} peer «${peer.publicKey}» has both presharedKey and presharedKeyFile set, but only one can be used.";
        }) all_peers;

    boot.extraModulePackages = optional (versionOlder kernel.kernel.version "5.6") kernel.wireguard;
    environment.systemPackages = [ pkgs.wireguard-tools ];

    systemd.sockets =
      mapAttrs' generatePeersAnnouncingSocket cfg.interfaces;

    systemd.services =
      (mapAttrs' generateInterfaceUnit cfg.interfaces)
      // (mapAttrs' generatePeersAnnouncingUnit cfg.interfaces)
      // (listToAttrs (map generatePeerUnit all_peers))
      // (listToAttrs (map generateEndpointsUpdaterUnit
      (filter ({peer, ...}: peer.endpointsUpdater.enable) all_peers)))
      // (mapAttrs' generateKeyServiceUnit
      (filterAttrs (name: value: value.generatePrivateKeyFile) cfg.interfaces));

    meta.maintainers = with maintainers; [ julm ];

  });

}
