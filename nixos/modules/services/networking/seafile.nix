{
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.services.seafile;
  settingsFormat = pkgs.formats.ini { };
  envFormat = pkgs.formats.keyValue { };

  seafileConf = settingsFormat.generate "seafile.conf" cfg.seafileSettings;

  seahubSettings = pkgs.writeText "seahub_settings.py" (
    ''
      import os

      DATABASES = {
          'default': {
              'ENGINE': 'django.db.backends.mysql',
              'NAME' : '${cfg.environment.SEAFILE_MYSQL_DB_SEAHUB_DB_NAME}',
              'HOST' : '${cfg.environment.SEAFILE_MYSQL_DB_HOST}',
    ''
    + (lib.strings.optionalString (cfg.environment.SEAFILE_MYSQL_DB_PORT != null) ''
      'PORT' : '${cfg.environment.SEAFILE_MYSQL_DB_PORT}',
    '')
    + ''
              'USER' : '${cfg.environment.SEAFILE_MYSQL_DB_USER}',
              'PASSWORD' : os.environ.get('SEAFILE_MYSQL_DB_PASSWORD', ""),
          }
      }
      MEDIA_ROOT = '${seahubDir}/media/'
      THUMBNAIL_ROOT = '${seahubDir}/thumbnail/'

      CSRF_TRUSTED_ORIGINS = ["${cfg.environment.SEAFILE_SERVER_PROTOCOL}://${cfg.environment.SEAFILE_SERVER_HOSTNAME}"]

      JWT_PRIVATE_KEY = os.environ['JWT_PRIVATE_KEY']
      SECRET_KEY = os.environ['SEAHUB_SECRET_KEY']

      ${cfg.seahubExtraConf}
    ''
  );

  seafRoot = "/var/lib/seafile";
  ccnetDir = "${seafRoot}/ccnet";
  seahubDir = "${seafRoot}/seahub";
  defaultUser = "seafile";
  defaultEnv = "${seafRoot}/envAutogenerated";

in
{

  ###### Interface

  options.services.seafile = with lib; {
    enable = mkEnableOption "Seafile server";

    environment = mkOption {
      type = types.submodule {
        # From systemd environment definition
        freeformType =
          with types;
          attrsOf (
            nullOr (oneOf [
              str
              path
              package
            ])
          );
        options = {
          SEAFILE_SERVER_PROTOCOL = mkOption {
            type = types.singleLineStr;
            default = "http";
            description = ''
              The world-facing protocol used to access seafile.
              Set to `https` when using a TLS-enabled reverse proxy.
            '';
          };
          SEAFILE_SERVER_HOSTNAME = mkOption {
            type = types.singleLineStr;
            example = "seafile.example.com";
            description = "The world-facing hostname used to access seafile.";
          };
          SEAFILE_MYSQL_DB_HOST = mkOption {
            type = types.singleLineStr;
            default = "localhost";
            description = "MySQL database hostname.";
          };
          SEAFILE_MYSQL_DB_PORT = mkOption {
            type = types.nullOr types.singleLineStr;
            default = null;
            description = "MySQL database port.";
          };
          SEAFILE_MYSQL_DB_USER = mkOption {
            type = types.singleLineStr;
            default = "seafile";
            description = "MySQL database user.";
          };
          SEAFILE_MYSQL_DB_CCNET_DB_NAME = mkOption {
            type = types.singleLineStr;
            description = "MySQL database for ccnet.";
            default = "ccnet_db";
          };
          SEAFILE_MYSQL_DB_SEAFILE_DB_NAME = mkOption {
            type = types.singleLineStr;
            description = "MySQL database for seafile.";
            default = "seafile_db";
          };
          SEAFILE_MYSQL_DB_SEAHUB_DB_NAME = mkOption {
            type = types.singleLineStr;
            description = "MySQL database for seahub.";
            default = "seahub_db";
          };
          SEAFILE_LOG_TO_STDOUT = mkOption {
            type = types.singleLineStr;
            description = "Output server logs to stdout instead of to a log file. Useful for journald.";
            default = "true";
          };
        };
      };
      default = { };
      description = ''
        Environment variables set for the seafile-server and seahub services.
        Refer to <https://manual.seafile.com/latest/setup_binary/installation_ce/?h=#create-the-env-file-in-conf-directory>
        for some of the variables used.
        Use `services.seafile.environmentFile` to configure secret variables.
      '';
    };

    environmentFile = mkOption {
      type = types.nullOr types.path;
      description = ''
        Environment variable file containing the following secrets:
        - `SEAFILE_MYSQL_DB_PASSWORD`: password to authenticate to the MySQL database with.
        - `JWT_PRIVATE_KEY`: a random secret of at least 32 characters.
          Generate with `openssl rand -hex 64`.
        - `SEAHUB_SECRET_KEY`: a random secret.
          Generate with `openssl rand -hex 64`.
          For migration from Seafile 11: this secret was previously stored at `/var/lib/seafile/.seahubSecret`.

        If left as the default path, any missing variables will be autogenerated and written to it.
      '';
      default = defaultEnv;
    };

    setupLocalDatabase = mkOption {
      type = types.bool;
      description = ''
        Whether to enable the MariaDB module and configure it to contain the needed user and databases.

        If this option is disabled, the MySQL server used must be manually configured according to the options set
        in `services.seafile.environment` to contain the (empty) databases, and to allow the specified username and password
        full access to these databases.
        The module will still initialize the empty databases to the correct schema when this option is disabled.
      '';
      default = true;
    };

    seafileSettings = mkOption {
      type = types.submodule {
        freeformType = settingsFormat.type;
        options = {
          fileserver = {
            port = mkOption {
              type = types.port;
              default = 8082;
              description = ''
                The tcp port used by seafile fileserver.
              '';
            };
            host = mkOption {
              type = types.singleLineStr;
              default = "ipv4:127.0.0.1";
              example = "unix:/run/seafile/server.sock";
              description = ''
                The bind address used by seafile fileserver.

                The addr can be defined as one of the following:
                - ipv6:<ipv6addr> for binding to an IPv6 address.
                - unix:<named pipe> for binding to a unix named socket
                - ipv4:<ipv4addr> for binding to an ipv4 address
                Otherwise the addr is assumed to be ipv4.
              '';
            };
          };
          database = {
            type = mkOption {
              type = types.singleLineStr;
              default = "mysql";
              visible = false;
              # SQLite is deprecated, no other values exist
            };
            password = mkOption {
              type = types.singleLineStr;
              default = "!";
              visible = false;
              # If this is unset, seafile-server fails to start
              # The environment variable actually used overrides this
            };
          };
        };
      };
      default = { };
      description = ''
        Configuration for seafile-server, see
        <https://manual.seafile.com/config/seafile-conf/>
        for supported values.
      '';
    };

    seahubAddress = mkOption {
      type = types.singleLineStr;
      default = "unix:/run/seahub/gunicorn.sock";
      example = "[::1]:8083";
      description = ''
        Which address to bind the seahub server to, of the form:
        - HOST
        - HOST:PORT
        - unix:PATH.
        IPv6 HOSTs must be wrapped in brackets.
      '';
    };

    workers = mkOption {
      type = types.int;
      default = 4;
      example = 10;
      description = ''
        The number of gunicorn worker processes for handling requests.
      '';
    };

    adminEmail = mkOption {
      example = "john@example.com";
      type = types.singleLineStr;
      description = ''
        The email address used to login to the seafile admin account.
      '';
    };

    initialAdminPassword = mkOption {
      example = "someStrongPass";
      type = types.singleLineStr;
      description = ''
        The password set for the admin account on first setup.
        This should be changed using the web interface after setup is complete.
      '';
    };

    seahubPackage = mkPackageOption pkgs "seahub" { };

    user = mkOption {
      type = types.singleLineStr;
      default = defaultUser;
      description = "User account under which seafile runs.";
    };

    group = mkOption {
      type = types.singleLineStr;
      default = defaultUser;
      description = "Group under which seafile runs.";
    };

    dataDir = mkOption {
      type = types.path;
      default = "${seafRoot}/data";
      description = "Path in which to store user data";
    };

    gc = {
      enable = mkEnableOption "automatic garbage collection on stored data blocks";

      dates = mkOption {
        type = types.listOf types.singleLineStr;
        default = [ "Sun 03:00:00" ];
        description = ''
          When to run garbage collection on stored data blocks.
          The time format is described in {manpage}`systemd.time(7)`.
        '';
      };

      randomizedDelaySec = mkOption {
        default = "0";
        type = types.singleLineStr;
        example = "45min";
        description = ''
          Add a randomized delay before each garbage collection.
          The delay will be chosen between zero and this value.
          This value must be a time span in the format specified by
          {manpage}`systemd.time(7)`
        '';
      };

      persistent = mkOption {
        default = true;
        type = types.bool;
        example = false;
        description = ''
          Takes a boolean argument. If true, the time when the service
          unit was last triggered is stored on disk. When the timer is
          activated, the service unit is triggered immediately if it
          would have been triggered at least once during the time when
          the timer was inactive. Such triggering is nonetheless
          subject to the delay imposed by RandomizedDelaySec=. This is
          useful to catch up on missed runs of the service when the
          system was powered down.
        '';
      };
    };

    seahubExtraConf = mkOption {
      default = "";
      example = ''
        CSRF_TRUSTED_ORIGINS = ["https://example.com"]
      '';
      type = types.lines;
      description = ''
        Extra config to append to `seahub_settings.py` file.
        Refer to <https://manual.seafile.com/config/seahub_settings_py/>
        for all available options.
      '';
    };
  };

  ###### Implementation

  config = lib.mkIf cfg.enable {
    assertions = [
      {
        assertion = cfg.setupLocalDatabase -> cfg.environment.SEAFILE_MYSQL_DB_HOST == "localhost";
        message = "services.seafile.environment.SEAFILE_MYSQL_DB_HOST must be `localhost` if services.seafile.setupLocalDatabase is set.";
      }
      {
        assertion = cfg.setupLocalDatabase -> cfg.environment.SEAFILE_MYSQL_DB_PORT == null;
        message = "services.seafile.environment.SEAFILE_MYSQL_DB_PORT must be `null` if services.seafile.setupLocalDatabase is set.";
      }
    ];

    services.mysql = lib.mkIf cfg.setupLocalDatabase {
      enable = true;
      package = lib.mkDefault pkgs.mariadb;
      ensureDatabases = [
        cfg.environment.SEAFILE_MYSQL_DB_CCNET_DB_NAME
        cfg.environment.SEAFILE_MYSQL_DB_SEAFILE_DB_NAME
        cfg.environment.SEAFILE_MYSQL_DB_SEAHUB_DB_NAME
      ];
      ensureUsers = [
        {
          name = cfg.environment.SEAFILE_MYSQL_DB_USER;
          ensurePermissions = {
            "${cfg.environment.SEAFILE_MYSQL_DB_CCNET_DB_NAME}.*" = "ALL PRIVILEGES";
            "${cfg.environment.SEAFILE_MYSQL_DB_SEAFILE_DB_NAME}.*" = "ALL PRIVILEGES";
            "${cfg.environment.SEAFILE_MYSQL_DB_SEAHUB_DB_NAME}.*" = "ALL PRIVILEGES";
          };
        }
      ];
    };

    environment.etc."seafile/seafile.conf".source = seafileConf;
    environment.etc."seafile/seahub_settings.py".source = seahubSettings;

    users.users = lib.optionalAttrs (cfg.user == defaultUser) {
      "${defaultUser}" = {
        group = cfg.group;
        isSystemUser = true;
      };
    };

    users.groups = lib.optionalAttrs (cfg.group == defaultUser) { "${defaultUser}" = { }; };

    systemd.targets.seafile = {
      wantedBy = [ "multi-user.target" ];
      description = "Seafile components";
    };

    systemd.services =
      let
        serviceOptions = {
          ProtectHome = true;
          PrivateUsers = true;
          PrivateDevices = true;
          PrivateTmp = true;
          ProtectSystem = "strict";
          ProtectClock = true;
          ProtectHostname = true;
          ProtectProc = "invisible";
          ProtectKernelModules = true;
          ProtectKernelTunables = true;
          ProtectKernelLogs = true;
          ProtectControlGroups = true;
          RestrictNamespaces = true;
          RemoveIPC = true;
          LockPersonality = true;
          RestrictRealtime = true;
          RestrictSUIDSGID = true;
          NoNewPrivileges = true;
          MemoryDenyWriteExecute = true;
          SystemCallArchitectures = "native";
          RestrictAddressFamilies = [
            "AF_UNIX"
            "AF_INET"
          ];

          User = cfg.user;
          Group = cfg.group;
          StateDirectory = "seafile";
          RuntimeDirectory = "seafile";
          LogsDirectory = "seafile";
          ConfigurationDirectory = "seafile";
          ReadWritePaths = lib.lists.optional (cfg.dataDir != "${seafRoot}/data") cfg.dataDir;
          EnvironmentFile = cfg.environmentFile;
        };
        mysqlServer = lib.lists.optional cfg.setupLocalDatabase "mysql.service";
        mysqlClient = "${pkgs.mariadb.client}/bin/mysql --user=${cfg.environment.SEAFILE_MYSQL_DB_USER}";
      in
      {
        seaf-server = {
          description = "Seafile server";
          partOf = [ "seafile.target" ];
          environment = cfg.environment;
          unitConfig.RequiresMountsFor = lib.lists.optional (cfg.dataDir != "${seafRoot}/data") cfg.dataDir;
          requires = mysqlServer;
          after = [
            "network.target"
          ] ++ mysqlServer;
          wantedBy = [ "seafile.target" ];
          restartTriggers = [
            seafileConf
          ];
          serviceConfig = serviceOptions // {
            ExecStart = ''
              ${lib.getExe cfg.seahubPackage.seafile-server} \
              --foreground \
              -F /etc/seafile \
              -c ${ccnetDir} \
              -d ${cfg.dataDir} \
              -l /var/log/seafile/server.log \
              -P /run/seafile/server.pid \
              -p /run/seafile
            '';
            # Allow environment file not to exist if it is to be generated
            EnvironmentFile =
              if (cfg.environmentFile == defaultEnv) then "-${cfg.environmentFile}" else cfg.environmentFile;
          };
          preStart =
            (lib.strings.optionalString (!cfg.setupLocalDatabase) ''
              if [[ ! -v SEAFILE_MYSQL_DB_PASSWORD ]]; then
                echo "error: missing SEAFILE_MYSQL_DB_PASSWORD for manually-configured database"
                exit 1
              fi
            '')
            + (lib.strings.optionalString (cfg.environmentFile != defaultEnv) ''
              if [[ ! -r "${cfg.environmentFile}" ]]; then
                echo "error: manually specified services.seafile.environmentFile does not exist or is not readable"
                exit 1
              elif [[ ! -v JWT_PRIVATE_KEY ]]; then
                echo "error: manually specified services.seafile.environmentFile does not set JWT_PRIVATE_KEY"
                exit 1
              elif [[ ! -v SEAHUB_SECRET_KEY ]]; then
                echo "error: manually specified services.seafile.environmentFile does not set SEAHUB_SECRET_KEY"
                exit 1
              fi
            '')
            + ''
              export MYSQL_HOST=$SEAFILE_MYSQL_DB_HOST
              export MYSQL_TCP_PORT=$SEAFILE_MYSQL_DB_PORT
              export MYSQL_PWD=$SEAFILE_MYSQL_DB_PASSWORD

              if [[ ! -f "${seafRoot}/server-setup" ]]; then
                mkdir -p ${cfg.dataDir}/library-template

                # Load schema on first install
                ${mysqlClient} --database=ccnet_db < ${cfg.seahubPackage.seafile-server}/share/seafile/sql/mysql/ccnet.sql
                ${mysqlClient} --database=seafile_db < ${cfg.seahubPackage.seafile-server}/share/seafile/sql/mysql/seafile.sql
                echo "Loaded MySQL schemas for first install"
            ''
            + (lib.strings.optionalString (cfg.environmentFile == defaultEnv) ''
              touch "${cfg.environmentFile}"
              chmod 600 "${cfg.environmentFile}"
              if [[ ! -v JWT_PRIVATE_KEY ]]; then
                export JWT_PRIVATE_KEY="$(${pkgs.lib.getExe pkgs.openssl} rand -hex 64)"
                echo "JWT_PRIVATE_KEY=$JWT_PRIVATE_KEY" >> ${cfg.environmentFile}
              fi
              if [[ ! -v SEAHUB_SECRET_KEY ]]; then
                export SEAHUB_SECRET_KEY="$(${pkgs.lib.getExe pkgs.openssl} rand -hex 64)"
                echo "SEAHUB_SECRET_KEY=$SEAHUB_SECRET_KEY" >> ${cfg.environmentFile}
              fi
              echo "Generated seafile secrets for first install"
            '')
            + ''
                # Mark as initialized
                echo "${cfg.seahubPackage.seafile-server.version}-mysql" > "${seafRoot}"/server-setup
              fi

              # Check for upgrades and handle them
              installedMajor=$(cat "${seafRoot}/server-setup" | cut -d"-" -f1 | cut -d"." -f1)
              installedMinor=$(cat "${seafRoot}/server-setup" | cut -d"-" -f1 | cut -d"." -f2)
              pkgMajor=$(echo "${cfg.seahubPackage.seafile-server.version}" | cut -d"." -f1)
              pkgMinor=$(echo "${cfg.seahubPackage.seafile-server.version}" | cut -d"." -f2)

              if [[ $installedMajor == $pkgMajor && $installedMinor == $pkgMinor ]]; then
                  :
              elif [[ $installedMajor == 11 && $installedMinor == 0 && $pkgMajor == 12 && $pkgMinor == 0 ]]; then
                # Upgrade from 11.0 to 12.0
            ''
            + (lib.strings.optionalString (cfg.environmentFile == defaultEnv) ''
              touch "${cfg.environmentFile}"
              chmod 600 "${cfg.environmentFile}"
              if [[ ! -v JWT_PRIVATE_KEY ]]; then
                export JWT_PRIVATE_KEY="$(${pkgs.lib.getExe pkgs.openssl} rand -hex 64)"
                echo "JWT_PRIVATE_KEY=$JWT_PRIVATE_KEY" >> ${cfg.environmentFile}
              fi
              if [[ ! -v SEAHUB_SECRET_KEY ]]; then
                export SEAHUB_SECRET_KEY="$( < ${seafRoot}/.seahubSecret)"
                echo "SEAHUB_SECRET_KEY=$SEAHUB_SECRET_KEY" >> ${cfg.environmentFile}
              fi
            '')
            + ''
                ${mysqlClient} --database=seafile_db < ${cfg.seahubPackage}/scripts/upgrade/sql/12.0.0/mysql/seafile.sql

                # Migrations from SQLite seem to be missing the GCID and LastGCID tables
                # Run the initial schema which should add any missing tbales
                ${mysqlClient} --database=seafile_db < ${cfg.seahubPackage.seafile-server}/share/seafile/sql/mysql/seafile.sql

                echo "${cfg.seahubPackage.seafile-server.version}-mysql" > "${seafRoot}"/server-setup
                echo Migration complete
              else
                  echo "Unsupported upgrade: $installedMajor.$installedMinor to $pkgMajor.$pkgMinor" >&2
                  exit 1
              fi
            '';

          # Fix unix socket permissions: by default these are 755, but connecting requires write permission
          # Allowing any user to connect is as safe as using a loopback IP
          postStart = (
            lib.strings.optionalString (lib.strings.hasPrefix "unix:" cfg.seafileSettings.fileserver.host) ''
              while [[ ! -S "${lib.strings.removePrefix "unix:" cfg.seafileSettings.fileserver.host}" ]]; do
                sleep 1
              done
              chmod 666 "${lib.strings.removePrefix "unix:" cfg.seafileSettings.fileserver.host}"
            ''
          );
        };

        seahub = {
          description = "Seafile Server Web Frontend";
          wantedBy = [ "seafile.target" ];
          partOf = [ "seafile.target" ];
          unitConfig.RequiresMountsFor = lib.lists.optional (cfg.dataDir != "${seafRoot}/data") cfg.dataDir;
          requires = [
            "seaf-server.service"
          ] ++ mysqlServer;
          after = [
            "network.target"
            "seaf-server.service"
          ] ++ mysqlServer;
          restartTriggers = [ seahubSettings ];
          environment = {
            PYTHONPATH = "${cfg.seahubPackage.pythonPath}:${cfg.seahubPackage}/thirdpart:${cfg.seahubPackage}";
            DJANGO_SETTINGS_MODULE = "seahub.settings";
            CCNET_CONF_DIR = ccnetDir;
            SEAFILE_CONF_DIR = cfg.dataDir;
            SEAFILE_CENTRAL_CONF_DIR = "/etc/seafile";
            SEAFILE_RPC_PIPE_PATH = "/run/seafile";
            SEAHUB_LOG_DIR = "/var/log/seafile";
          } // cfg.environment;
          serviceConfig = serviceOptions // {
            RuntimeDirectory = "seahub";
            ExecStart = ''
              ${lib.getExe cfg.seahubPackage.python3.pkgs.gunicorn} seahub.wsgi:application \
              --name seahub \
              --workers ${toString cfg.workers} \
              --log-level=info \
              --preload \
              --timeout=1200 \
              --limit-request-line=8190 \
              --bind ${cfg.seahubAddress}
            '';
          };
          preStart = ''
            mkdir -p ${seahubDir}/media
            # Link all media except avatars
            for m in `find ${cfg.seahubPackage}/media/ -maxdepth 1 -not -name "avatars"`; do
              ln -sf $m ${seahubDir}/media/
            done

            # On first setup
            if [[ ! -f "${seafRoot}/seahub-setup" ]]; then
                # avatars directory should be writable
                install -D -t ${seahubDir}/media/avatars/ ${cfg.seahubPackage}/media/avatars/default.png
                install -D -t ${seahubDir}/media/avatars/groups ${cfg.seahubPackage}/media/avatars/groups/default.png

                # init database
                ${cfg.seahubPackage}/manage.py migrate

                # create admin account
                ${lib.getExe pkgs.expect} -c 'spawn ${cfg.seahubPackage}/manage.py createsuperuser --email=${cfg.adminEmail}; expect "Password: "; send "${cfg.initialAdminPassword}\r"; expect "Password (again): "; send "${cfg.initialAdminPassword}\r"; expect "Superuser created successfully."'

                echo "${cfg.seahubPackage.version}-mysql" > "${seafRoot}/seahub-setup"
            fi

            # On upgrade
            if [[ $(cat "${seafRoot}/seahub-setup" | cut -d"-" -f1) != "${pkgs.seahub.version}" ]]; then
                # run django migrations
                ${cfg.seahubPackage}/manage.py migrate
                echo "${cfg.seahubPackage.version}-mysql" > "${seafRoot}/seahub-setup"
            fi
          '';
        };

        seaf-gc = {
          description = "Seafile storage garbage collection";
          environment = cfg.environment;
          unitConfig.RequiresMountsFor = lib.lists.optional (cfg.dataDir != "${seafRoot}/data") cfg.dataDir;
          startAt = lib.lists.optionals cfg.gc.enable cfg.gc.dates;
          serviceConfig = serviceOptions // {
            Type = "oneshot";
          };
          script = ''
            if [ ! -f "${seafRoot}/server-setup" ]; then
                echo "Server not setup yet, GC not needed" >&2
                exit
            fi

            # checking for pending upgrades
            installedMajor=$(cat "${seafRoot}/server-setup" | cut -d"-" -f1 | cut -d"." -f1)
            installedMinor=$(cat "${seafRoot}/server-setup" | cut -d"-" -f1 | cut -d"." -f2)
            pkgMajor=$(echo "${cfg.seahubPackage.seafile-server.version}" | cut -d"." -f1)
            pkgMinor=$(echo "${cfg.seahubPackage.seafile-server.version}" | cut -d"." -f2)

            if [[ $installedMajor != $pkgMajor || $installedMinor != $pkgMinor ]]; then
                echo "Server not upgraded yet" >&2
                exit
            fi

            # Clean up user-deleted blocks and libraries
            ${cfg.seahubPackage.seafile-server}/bin/seafserv-gc \
              -F /etc/seafile \
              -c ${ccnetDir} \
              -d ${cfg.dataDir} \
              --rm-fs
          '';
        };
      };

    systemd.timers.seaf-gc = lib.mkIf cfg.gc.enable {
      timerConfig = {
        RandomizedDelaySec = cfg.gc.randomizedDelaySec;
        Persistent = cfg.gc.persistent;
      };
    };
  };

  meta.maintainers = with lib.maintainers; [
    greizgh
    schmittlauch
  ];
}
