{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.networking.wireless.iwd;

  encodeFileName = pkgs.writeScript "encode" ''
    #! ${pkgs.runtimeShell} -e
    echo "=$(printf "$1" | ${pkgs.unixtools.xxd}/bin/xxd -pu)"
  '';

  # If a network consists of alphanumeric chars and `_` and `-`, the network will be stored
  # as `/var/lib/iwd/<ssid>.<ext>`. In any other case a hex-encoded version of the SSID will
  # be stored with an `=` as prefix.
  encodeIfNeeded = file: ext: let
    allowedChars = stringToCharacters "01234556789abcdefghijklmnopqrstuvwxyz-_ ";
    skipEncoding = all (char: elem (toLower char) allowedChars) (stringToCharacters file);
  in
    "/var/lib/iwd/${if skipEncoding then file else "$(${encodeFileName} \"${file}\")"}.${ext}";

  # The file extension of the network-config determines the type of the network. Currently,
  # we support public networks (`open`) and networks protected with a passphrase (`psk`).
  # Anything else, like 802.1x networks are not supported by this module.
  determineType = cfg: if cfg.psk != null || cfg.passphrase != null then "psk" else "open";

  # Generates a name-value-pair with configurations for a SSID. For further information
  # about the configuration options, please refer to the upstream docs:
  #
  # https://iwd.wiki.kernel.org/networkconfigurationsettings
  predefinedNetworks = flip mapAttrs cfg.networks (name: cfg: {
    extension = determineType cfg;

    # Cannot use the SSID here: the hex-encode is done at build-time, not eval time
    # and several special chars in a file name would break `writeText`.
    file = pkgs.writeText "ssid" (generators.toINI {} ({
      Settings.AutoConnect = boolToString cfg.autoConnect;
      Settings.Hidden = boolToString cfg.hidden;
    } // (optionalAttrs (cfg.psk != null) {
      Security.PreSharedKey = cfg.psk;
    }) // (optionalAttrs (cfg.passphrase != null) {
      Security.Passprase = cfg.passphrase;
    })));
  });
in {
  options.networking.wireless.iwd = {
    enable = mkEnableOption "iwd";

    interfaces = mkOption {
      type = types.nullOr (types.listOf types.str);
      example = literalExample ''
        [ "wlp2s0" ]
      '';
      default = null;
      description = ''
        List of interfaces to use.
      '';
    };

    networks = mkOption {
      default = {};
      example = literalExample ''
        { "karlsruhe.freifunk.net" = {};
          "secured".passphrase = "12345678";
          "network-with-psk".psk = "bf4c086e055e492373a0f59ff614f61fc2d597a56db94e17a165f9ef1d42c066";
        };
      '';

      description = ''
        Declarative configuration of wifi networks for
        <citerefentry><refentrytitle>iwd</refentrytitle><manvolnum>8</manvolnum></citerefentry>.

        All networks will be stored in
        <literal>/var/lib/iwd/&lt;name&gt;.&lt;type&gt;</literal>.

        Since each network is stored in its own file, declarative networks can be used in an
        environment with imperatively added networks via
        <citerefentry><refentrytitle>iwctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
      '';

      type = types.attrsOf (types.submodule {
        options = {
          psk = mkOption {
            type = types.nullOr (types.fixedLengthString 64);
            default = null;
            description = ''
              WPA PSK for the currently defined network. This can be generated by using
              <citerefentry><refentrytitle>wpa_passphrase</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
            '';
          };

          passphrase = mkOption {
            type = types.nullOr (types.lengthCheckedString 8 63);
            default = null;
            description = ''
              Raw passphrase for the currently defined network.
            '';
          };

          autoConnect = mkOption {
            default = true;
            type = types.bool;
            description = ''
              Disable automatic connection to the network.
            '';
          };

          hidden = mkOption {
            default = false;
            type = types.bool;
            description = ''
              Used for hidden networks that don't respond to scans unless
              their SSID is explicitly specified.
            '';
          };
        };
      });
    };
  };

  config = mkIf cfg.enable {
    assertions = [{
      assertion = !config.networking.wireless.enable;
      message = ''
        Only one wireless daemon is allowed at the time: networking.wireless.enable and networking.wireless.iwd.enable are mutually exclusive.
      '';
    }] ++ (flip mapAttrsToList cfg.networks (name: value: {
      assertion = value.psk != null -> value.passphrase == null;
      message = ''
        Cannot set WPA PSK and raw passphrase at the same time for network ${name}!
      '';
    }));

    # for iwctl
    environment.systemPackages =  [ pkgs.iwd ];

    services.dbus.packages = [ pkgs.iwd ];

    systemd.packages = [ pkgs.iwd ];

    systemd.services.iwd.preStart = mkIf (cfg.networks != {}) (let
      ssids = flip mapAttrsToList predefinedNetworks (file: content: {
        inherit (content) file;
        local = encodeIfNeeded file content.extension;
      });
    in ''
      # Remove all network-configs from `/var/lib/iwd` that are symlinks to a store-path,
      # but aren't declared in `cfg.networks` (i.e. all networks that were "removed" from
      # `cfg.networks`).
      find /var/lib/iwd -type l -lname '${builtins.storeDir}/*' ${optionalString (ssids != {}) ''
        -not \( ${concatMapStringsSep " -o " ({ local, ... }:
          "-name '${baseNameOf local}*'")
        ssids} \) \
      ''} -delete

      ${concatMapStrings ({ file, local }: ''
        ln -sf '${file}' "${local}"
      '') ssids}
    '');

    systemd.services.iwd.serviceConfig.ExecStart = mkIf (cfg.interfaces != null) [
      ""
      "${pkgs.iwd}/libexec/iwd -i ${concatStringsSep " -i " cfg.interfaces}"
    ];

    systemd.services.iwd.wantedBy = [ "multi-user.target" ];
  };

  meta.maintainers = with lib.maintainers; [ mic92 dtzWill ma27 ];
}
