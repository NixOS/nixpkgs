{ config, lib, pkgs, ... }:

let
  inherit (lib)
    mkEnableOption mkPackageOption mkIf mkOption types
    recursiveUpdate;

  cfg = config.networking.wireless.iwd;
  ini = pkgs.formats.ini { };
  defaults = {
    # without UseDefaultInterface, sometimes wlan0 simply goes AWOL with NetworkManager
    # https://iwd.wiki.kernel.org/interface_lifecycle#interface_management_in_iwd
    General.UseDefaultInterface = with config.networking.networkmanager; (enable && (wifi.backend == "iwd"));
  };
  configFile = ini.generate "main.conf" (recursiveUpdate defaults cfg.settings);
  encodeFileName = pkgs.writeScript "encode" ''
    #! ${pkgs.runtimeShell} -e
    echo "=$(printf "$1" | ${pkgs.unixtools.xxd}/bin/xxd -pu)"
  '';

  # If a network consists of alphanumeric chars and `_` and `-`, the network will be stored
  # as `/var/lib/iwd/<ssid>.<ext>`. In any other case a hex-encoded version of the SSID will
  # be stored with an `=` as prefix.
  encodeIfNeeded = file: ext: let
    allowedChars = lib.stringToCharacters "01234556789abcdefghijklmnopqrstuvwxyz-_ ";
    skipEncoding = lib.all (char: lib.elem (lib.toLower char) allowedChars) (lib.stringToCharacters file);
  in
    "/var/lib/iwd/${if skipEncoding then file else "$(${encodeFileName} \"${file}\")"}.${ext}";

  # The file extension of the network-config determines the type of the network. Currently,
  # we support public networks (`open`) and networks protected with a passphrase (`psk`).
  # Anything else, like 802.1x networks are not supported by this module.
  determineType = cfg: if cfg.psk != null || cfg.passphrase != null then "psk" else "open";

  # Generates a name-value-pair with configurations for a SSID. For further information
  # about the configuration options, please refer to the upstream docs:
  # https://iwd.wiki.kernel.org/networkconfigurationsettings
  predefinedNetworks = lib.flip lib.mapAttrs cfg.networks (name: cfg: {
    extension = determineType cfg;

    # Cannot use the SSID here: the hex-encode is done at build-time, not eval time
    # and several special chars in a file name would break `writeText`.
    file = pkgs.writeText "ssid" (lib.generators.toINI {} ({
      Settings.AutoConnect = lib.boolToString cfg.autoConnect;
      Settings.Hidden = lib.boolToString cfg.hidden;
    } // (lib.optionalAttrs (cfg.psk != null) {
      Security.PreSharedKey = cfg.psk;
    }) // (lib.optionalAttrs (cfg.passphrase != null) {
      Security.Passprase = cfg.passphrase;
    })));
  });

in
{
  options.networking.wireless.iwd = {
    enable = mkEnableOption (lib.mdDoc "iwd");

    package = mkPackageOption pkgs "iwd" { };

    settings = mkOption {
      type = ini.type;
      default = { };

      example = lib.literalExpression ''
        {
          Settings.AutoConnect = true;

          Network = {
            EnableIPv6 = true;
            RoutePriorityOffset = 300;
          };
        };
      '';

      description = lib.mdDoc ''
        Options passed to iwd. See <https://iwd.wiki.kernel.org/networkconfigurationsettings> for supported options.
      '';
    };

    networks = mkOption {
      default = {};
      example = lib.literalExpression ''
        { "karlsruhe.freifunk.net" = {};
          "secured".passphrase = "12345678";
          "network-with-psk".psk = "bf4c086e055e492373a0f59ff614f61fc2d597a56db94e17a165f9ef1d42c066";
        };
      '';

      description = lib.mdDoc ''
        Declarative configuration of wifi networks for
        <citerefentry><refentrytitle>iwd</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
        All networks will be stored in
        <literal>/var/lib/iwd/&lt;name&gt;.&lt;type&gt;</literal>.
        Since each network is stored in its own file, declarative networks can be used in an
        environment with imperatively added networks via
        <citerefentry><refentrytitle>iwctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
      '';

      type = types.attrsOf (types.submodule {
        options = {
          psk = mkOption {
            type = types.nullOr (types.lengthCheckedString 64 64);
            default = null;
            description = lib.mdDoc ''
              WPA PSK for the currently defined network. This can be generated by using
              <citerefentry><refentrytitle>wpa_passphrase</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
            '';
          };

          passphrase = mkOption {
            type = types.nullOr (types.lengthCheckedString 8 63);
            default = null;
            description = lib.mdDoc ''
              Raw passphrase for the currently defined network.
            '';
          };

          autoConnect = mkOption {
            default = true;
            type = types.bool;
            description = lib.mdDoc ''
              Disable automatic connection to the network.
            '';
          };

          hidden = mkOption {
            default = false;
            type = types.bool;
            description = lib.mdDoc ''
              Used for hidden networks that don't respond to scans unless their
              SSID is explicitly specified.
            '';
          };
        };
      });
    };

  };

  config = mkIf cfg.enable {
    assertions = [{
      assertion = !config.networking.wireless.enable;
      message = ''
        Only one wireless daemon is allowed at the time: networking.wireless.enable and networking.wireless.iwd.enable are mutually exclusive.
      '';
    }] ++ (lib.flip lib.mapAttrsToList cfg.networks (name: value: {
      assertion = value.psk != null -> value.passphrase == null;
      message = ''
        Cannot set WPA PSK and raw passphrase at the same time for network ${name}!
      '';
    }));

    environment.etc."iwd/${configFile.name}".source = configFile;

    # for iwctl
    environment.systemPackages = [ cfg.package ];

    services.dbus.packages = [ cfg.package ];

    systemd.packages = [ cfg.package ];

    systemd.network.links."80-iwd" = {
      matchConfig.Type = "wlan";
      linkConfig.NamePolicy = "keep kernel";
    };

    systemd.services.iwd = {
      path = [ config.networking.resolvconf.package ];
      wantedBy = [ "multi-user.target" ];
      restartTriggers = [ configFile ];
      serviceConfig.ReadWritePaths = "-/etc/resolv.conf";
    };

    systemd.services.iwd.preStart = mkIf (cfg.networks != {}) (let
      ssids = lib.flip lib.mapAttrsToList predefinedNetworks (file: content: {
        inherit (content) file;
        local = encodeIfNeeded file content.extension;
      });
    in ''
      # Remove all network-configs from `/var/lib/iwd` that are symlinks to a store-path,
      # but aren't declared in `cfg.networks` (i.e. all networks that were "removed" from
      # `cfg.networks`).
      find /var/lib/iwd -type l -lname '${builtins.storeDir}/*' ${lib.optionalString (ssids != {}) ''
        -not \( ${lib.concatMapStringsSep " -o " ({ local, ... }:
          "-name '${baseNameOf local}*'")
        ssids} \) \
      ''} -delete
      ${lib.concatMapStrings ({ file, local }: ''
        ln -sf '${file}' "${local}"
      '') ssids}
    '');

  };

  meta.maintainers = with lib.maintainers; [ dtzWill onny ];
}
