{ config, pkgs, lib, ... }:

with lib;

let
  cfg = config.services.netdata;

  wrappedPlugins = pkgs.runCommand "wrapped-plugins" { preferLocalBuild = true; } ''
    mkdir -p $out/libexec/netdata/plugins.d
    ln -s /run/wrappers/bin/apps.plugin $out/libexec/netdata/plugins.d/apps.plugin
    ln -s /run/wrappers/bin/cgroup-network $out/libexec/netdata/plugins.d/cgroup-network
    ln -s /run/wrappers/bin/perf.plugin $out/libexec/netdata/plugins.d/perf.plugin
    ln -s /run/wrappers/bin/slabinfo.plugin $out/libexec/netdata/plugins.d/slabinfo.plugin
    ln -s /run/wrappers/bin/freeipmi.plugin $out/libexec/netdata/plugins.d/freeipmi.plugin
  '';

  plugins = [
    "${cfg.package}/libexec/netdata/plugins.d"
    "${wrappedPlugins}/libexec/netdata/plugins.d"
  ] ++ cfg.extraPluginPaths;

  configDirectory = pkgs.runCommand "netdata-config-d" { } ''
    mkdir $out
    ${concatStringsSep "\n" (mapAttrsToList (path: file: ''
        mkdir -p "$out/$(dirname ${path})"
        ln -s "${file}" "$out/${path}"
      '') cfg.configDir)}
  '';

  localConfig = {
    directories = {
      "config" = "/etc/netdata/conf.d";
      "plugins" = concatStringsSep " " plugins;
      "stock health config" = "/var/empty";
      "health config" = "/etc/netdata/health.d";
    };
    logs = {
      # Output to journald
      "debug" = "none";
      "access" = "none";
      "error" = "syslog";
    };
    web = {
      "web files owner" = "root";
      "web files group" = "root";
    };
    "plugin:cgroups" = {
      "script to get cgroup network interfaces" = "${wrappedPlugins}/libexec/netdata/plugins.d/cgroup-network";
      "use unified cgroups" = "yes";
    };
  };
  mkConfig = generators.toINI { } (recursiveUpdate localConfig cfg.config);
  configFile = pkgs.writeText "netdata.conf" (if cfg.configText != null then cfg.configText else mkConfig);

  # https://learn.netdata.cloud/docs/agent/health/reference#health-entity-reference
  health = with builtins; {
    # Parses all files in the netdata directory and returns a set of alerts
    parse = dir:
      let
        parseFile = f:
          let
            t = readFile "${dir}/${f}";
            lines = filter (l: l != [ ]) (split " *\n *" t);
            parser = acc: line:
              let
                full = "${acc.cont}${line}";
                esc = match "(.*)\\\\$" full;
                m = match " *([^:#]*): *([^#]*).*$" full;
                k = if m != null then (elemAt m 0) else null;
                v = if m != null then (elemAt m 1) else null;
              in
              if esc != null then acc // { cont = elemAt esc 0; }
              else if k == null then acc // { cont = ""; }
              else if k == "template" || k == "alarm" then
                {
                  current = v;
                  cont = "";
                  alerts = acc.alerts // { ${v} = { isAlarm = k == "alarm"; }; };
                }
              else
                {
                  current = acc.current;
                  cont = "";
                  alerts = acc.alerts // {
                    ${acc.current} = (acc.alerts.${acc.current} // { ${k} = v; });
                  };
                };
          in
          foldl' parser { current = "invalid file"; cont = ""; alerts = { }; } lines;
      in
      foldl' (a: f: a // (parseFile f).alerts) { } (attrNames (readDir dir));

    # Converts the set of alerts to a string
    stringify = result:
      foldl'
        (s: k:
          let
            sub = result.${k};
            names = (filter (k: k != "enable" && k != "isAlarm" && sub.${k} != null) (attrNames sub));
            type = if sub.isAlarm then "alarm" else "template";
            lines = concatStringsSep "\n" (map (subK: "  ${subK}: ${sub.${subK}}") names);
          in
          if sub == null || sub.enable == false then s
          else
            (
              assert (sub.every != null || sub.lookup != null) && (sub.lookup != null || sub.calc != null || sub.warn != null || sub.crit != null) || throw "${k}: missing required attribute";
              "${s}\n${type}: ${k}\n${lines}\n"
            )
        )
        "# Autogenerated - change services.netdata.health"
        (attrNames result);
  };

  defaultUser = "netdata";

in
{
  options = {
    services.netdata = {
      enable = mkEnableOption (lib.mdDoc "netdata");

      package = mkOption {
        type = types.package;
        default = pkgs.netdata;
        defaultText = literalExpression "pkgs.netdata";
        description = lib.mdDoc "Netdata package to use.";
      };

      user = mkOption {
        type = types.str;
        default = "netdata";
        description = lib.mdDoc "User account under which netdata runs.";
      };

      group = mkOption {
        type = types.str;
        default = "netdata";
        description = lib.mdDoc "Group under which netdata runs.";
      };

      configText = mkOption {
        type = types.nullOr types.lines;
        description = lib.mdDoc "Verbatim netdata.conf, cannot be combined with config.";
        default = null;
        example = ''
          [global]
          debug log = syslog
          access log = syslog
          error log = syslog
        '';
      };

      python = {
        enable = mkOption {
          type = types.bool;
          default = true;
          description = lib.mdDoc ''
            Whether to enable python-based plugins
          '';
        };
        extraPackages = mkOption {
          type = types.functionTo (types.listOf types.package);
          default = ps: [ ];
          defaultText = literalExpression "ps: []";
          example = literalExpression ''
            ps: [
              ps.psycopg2
              ps.docker
              ps.dnspython
            ]
          '';
          description = lib.mdDoc ''
            Extra python packages available at runtime
            to enable additional python plugins.
          '';
        };
      };

      extraPluginPaths = mkOption {
        type = types.listOf types.path;
        default = [ ];
        example = literalExpression ''
          [ "/path/to/plugins.d" ]
        '';
        description = lib.mdDoc ''
          Extra paths to add to the netdata global "plugins directory"
          option.  Useful for when you want to include your own
          collection scripts.

          Details about writing a custom netdata plugin are available at:
          <https://docs.netdata.cloud/collectors/plugins.d/>

          Cannot be combined with configText.
        '';
      };

      config = mkOption {
        type = types.attrsOf types.attrs;
        default = { };
        description = lib.mdDoc "netdata.conf configuration as nix attributes. cannot be combined with configText.";
        example = literalExpression ''
          global = {
            "debug log" = "syslog";
            "access log" = "syslog";
            "error log" = "syslog";
          };
        '';
      };

      configDir = mkOption {
        type = types.attrsOf types.path;
        default = { };
        description = lib.mdDoc ''
          Complete netdata config directory except netdata.conf.
          The default configuration is merged with changes
          defined in this option.
          Each top-level attribute denotes a path in the configuration
          directory as in environment.etc.
          Its value is the absolute path and must be readable by netdata.
          Cannot be combined with configText.
        '';
        example = literalExpression ''
          "health_alarm_notify.conf" = pkgs.writeText "health_alarm_notify.conf" '''
            sendmail="/path/to/sendmail"
          ''';
          "health.d" = "/run/secrets/netdata/health.d";
        '';
      };

      enableAnalyticsReporting = mkOption {
        type = types.bool;
        default = false;
        description = lib.mdDoc ''
          Enable reporting of anonymous usage statistics to Netdata Inc. via either
          Google Analytics (in versions prior to 1.29.4), or Netdata Inc.'s
          self-hosted PostHog (in versions 1.29.4 and later).
          See: <https://learn.netdata.cloud/docs/agent/anonymous-statistics>
        '';
      };

      health = lib.mkOption {
        description = lib.mdDoc "The health.d configuration, see <https://learn.netdata.cloud/docs/agent/health/reference#entity-format>";
        type = types.attrsOf (types.nullOr (types.submodule {
          options = {
            enable = lib.mkOption {
              type = types.bool;
              default = true;
              description = lib.mdDoc "Should this alarm be activated";
            };
            isAlarm = lib.mkOption {
              type = types.bool;
              default = false;
              description = lib.mdDoc "Is this an alarm or a template configuration";
            };

            on = lib.mkOption {
              type = types.singleLineStr;
              description = lib.mdDoc "The chart this alarm should attach to";
            };
            class = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "The general alarm classification";
            };
            type = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "What area of the system the alarm monitors";
            };
            component = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Specific component of the type of the alarm";
            };
            os = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Which operating systems to run this chart";
            };
            hosts = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Which hostnames will run this alarm";
            };
            plugin = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Restrict an alarm or template to only a certain plugin";
            };
            module = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Restrict an alarm or template to only a certain module";
            };
            charts = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Restrict an alarm or template to only certain charts";
            };
            families = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Restrict a template to only certain families";
            };
            lookup = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "The database lookup to find and process metrics for the chart specified through on";
            };
            calc = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "(see above)	A calculation to apply to the value found via lookup or another variable";
            };
            every = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "The frequency of the alarm";
            };
            green = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Set the green and red thresholds of a chart";
            };
            red = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Set the  red thresholds of a chart";
            };
            warn = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Expressions evaluating to true or false, and when true, will trigger the alarm";
            };
            crit = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Expressions evaluating to true or false, and when true, will trigger the alarm";
            };
            to = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "A list of roles to send notifications to";
            };
            exec = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "The script to execute when the alarm changes status";
            };
            delay = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Optional hysteresis settings to prevent floods of notifications";
            };
            repeat = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "The interval for sending notifications when an alarm is in WARNING or CRITICAL mode";
            };
            options = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "Add an option to not clear alarms";
            };
            "host labels" = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "List of labels present on a host";
            };
            units = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "the unit of the alarm, used to display in UI";
            };
            info = lib.mkOption {
              type = types.nullOr types.singleLineStr;
              default = null;
              description = lib.mdDoc "A brief description of the alarm";
            };
          };
        }));
      };
    };
  };

  # Provide the defaults for health so they can be altered
  imports = [{
    services.netdata.health =
      let
        defaults = health.parse (cfg.package + /lib/netdata/conf.d/health.d);
      in
      lib.mapAttrsRecursive (name: lib.mkDefault) defaults;
  }];

  config = mkIf cfg.enable {
    assertions =
      [{
        assertion = cfg.config != { } -> cfg.configText == null;
        message = "Cannot specify both config and configText";
      }];

    environment.etc."netdata/netdata.conf".source = configFile;
    environment.etc."netdata/conf.d".source = configDirectory;
    environment.etc."netdata/health.d/nixos.conf".text = health.stringify cfg.health;

    systemd.services.netdata = {
      description = "Real time performance monitoring";
      after = [ "network.target" ];
      wantedBy = [ "multi-user.target" ];
      path = (with pkgs; [ curl gawk iproute2 which procps bash ])
        ++ lib.optional cfg.python.enable (pkgs.python3.withPackages cfg.python.extraPackages)
        ++ lib.optional config.virtualisation.libvirtd.enable (config.virtualisation.libvirtd.package);
      environment = {
        PYTHONPATH = "${cfg.package}/libexec/netdata/python.d/python_modules";
      } // lib.optionalAttrs (!cfg.enableAnalyticsReporting) {
        DO_NOT_TRACK = "1";
      };
      restartTriggers = [
        config.environment.etc."netdata/netdata.conf".source
        config.environment.etc."netdata/conf.d".source
      ];
      # It's ok to keep running during system activation
      stopIfChanged = false;
      serviceConfig = {
        ExecStart = "${cfg.package}/bin/netdata -P /run/netdata/netdata.pid -D -c /etc/netdata/netdata.conf";
        ExecReload = "${pkgs.util-linux}/bin/kill -s HUP -s USR1 -s USR2 $MAINPID";
        ExecStartPost = pkgs.writeShellScript "wait-for-netdata-up" ''
          while [ "$(${pkgs.netdata}/bin/netdatacli ping)" != pong ]; do sleep 0.5; done
        '';

        TimeoutStopSec = 60;
        Restart = "on-failure";
        # User and group
        User = cfg.user;
        Group = cfg.group;
        # Performance
        LimitNOFILE = "30000";
        # Runtime directory and mode
        RuntimeDirectory = "netdata";
        RuntimeDirectoryMode = "0750";
        # State directory and mode
        StateDirectory = "netdata";
        StateDirectoryMode = "0750";
        # Cache directory and mode
        CacheDirectory = "netdata";
        CacheDirectoryMode = "0750";
        # Logs directory and mode
        LogsDirectory = "netdata";
        LogsDirectoryMode = "0750";
        # Configuration directory and mode
        ConfigurationDirectory = "netdata";
        ConfigurationDirectoryMode = "0755";
        # Capabilities
        CapabilityBoundingSet = [
          "CAP_DAC_OVERRIDE" # is required for freeipmi and slabinfo plugins
          "CAP_DAC_READ_SEARCH" # is required for apps plugin
          "CAP_FOWNER" # is required for freeipmi plugin
          "CAP_SETPCAP" # is required for apps, perf and slabinfo plugins
          "CAP_SYS_ADMIN" # is required for perf plugin
          "CAP_SYS_PTRACE" # is required for apps plugin
          "CAP_SYS_RESOURCE" # is required for ebpf plugin
          "CAP_NET_RAW" # is required for fping app
          "CAP_SYS_CHROOT" # is required for cgroups plugin
          "CAP_SETUID" # is required for cgroups and cgroups-network plugins
        ];
        # Sandboxing
        ProtectSystem = "full";
        ProtectHome = "read-only";
        PrivateTmp = true;
        ProtectControlGroups = true;
        PrivateMounts = true;
      };
    };

    systemd.enableCgroupAccounting = true;

    security.wrappers = {
      "apps.plugin" = {
        source = "${cfg.package}/libexec/netdata/plugins.d/apps.plugin.org";
        capabilities = "cap_dac_read_search,cap_sys_ptrace+ep";
        owner = cfg.user;
        group = cfg.group;
        permissions = "u+rx,g+x,o-rwx";
      };

      "cgroup-network" = {
        source = "${cfg.package}/libexec/netdata/plugins.d/cgroup-network.org";
        capabilities = "cap_setuid+ep";
        owner = cfg.user;
        group = cfg.group;
        permissions = "u+rx,g+x,o-rwx";
      };

      "perf.plugin" = {
        source = "${cfg.package}/libexec/netdata/plugins.d/perf.plugin.org";
        capabilities = "cap_sys_admin+ep";
        owner = cfg.user;
        group = cfg.group;
        permissions = "u+rx,g+x,o-rwx";
      };

      "slabinfo.plugin" = {
        source = "${cfg.package}/libexec/netdata/plugins.d/slabinfo.plugin.org";
        capabilities = "cap_dac_override+ep";
        owner = cfg.user;
        group = cfg.group;
        permissions = "u+rx,g+x,o-rwx";
      };

    } // optionalAttrs (cfg.package.withIpmi) {
      "freeipmi.plugin" = {
        source = "${cfg.package}/libexec/netdata/plugins.d/freeipmi.plugin.org";
        capabilities = "cap_dac_override,cap_fowner+ep";
        owner = cfg.user;
        group = cfg.group;
        permissions = "u+rx,g+x,o-rwx";
      };
    };

    security.pam.loginLimits = [
      { domain = "netdata"; type = "soft"; item = "nofile"; value = "10000"; }
      { domain = "netdata"; type = "hard"; item = "nofile"; value = "30000"; }
    ];

    users.users = optionalAttrs (cfg.user == defaultUser) {
      ${defaultUser} = {
        group = defaultUser;
        isSystemUser = true;
      };
    };

    users.groups = optionalAttrs (cfg.group == defaultUser) {
      ${defaultUser} = { };
    };

  };
}
