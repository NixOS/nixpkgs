{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.factorio;
  factorio = pkgs.factorio-headless;
  name = "Factorio";
  stateDir = "/var/lib/factorio";
  mkSavePath = name: "${stateDir}/saves/${name}.zip";
  configFile = pkgs.writeText "factorio.conf" ''
    use-system-read-write-data-directories=true
    [path]
    read-data=${factorio}/share/factorio/data
    write-data=${stateDir}
  '';
  modDir = pkgs.factorio-mkModDirDrv cfg.mods;
in
{
  options = {
    services.factorio = {
      enable = mkEnableOption name;
      port = mkOption {
        type = types.int;
        default = 34197;
        description = ''
          The port to which the service should bind.

          This option will also open up the UDP port in the firewall configuration.
        '';
      };
      saveName = mkOption {
        type = types.string;
        default = "default";
        description = ''
          The name of the savegame that will be used by the server.

          When not present in ${stateDir}/saves, a new map with default
          settings will be generated before starting the service.
        '';
      };
      # TODO Add more individual settings as nixos-options?
      # TODO XXX The server tries to copy a newly created config file over the old one
      #   on shutdown, but fails, because it's in the nix store. When is this needed?
      #   Can an admin set options in-game and expect to have them persisted?
      configFile = mkOption {
        type = types.path;
        default = configFile;
        defaultText = "configFile";
        description = ''
          The server's configuration file.

          The default file generated by this module contains lines essential to
          the server's operation. Use its contents as a basis for any
          customizations.
        '';
      };
      mods = mkOption {
        type = types.listOf types.package;
        default = [];
        description = ''
          Mods the server should install and activate.

          The derivations in this list must "build" the mod by simply copying
          the .zip, named correctly, into the output directory. Eventually,
          there will be a way to pull in the most up-to-date list of
          derivations via nixos-channel. Until then, this is for experts only.
        '';
      };
      autosave-interval = mkOption {
        type = types.nullOr types.int;
        default = null;
        example = 2;
        description = ''
          The time, in minutes, between autosaves.
        '';
      };
    };
  };

  config = mkIf cfg.enable {
    users = {
      users.factorio = {
        uid             = config.ids.uids.factorio;
        description     = "Factorio server user";
        group           = "factorio";
        home            = stateDir;
        createHome      = true;
      };

      groups.factorio = {
        gid = config.ids.gids.factorio;
      };
    };

    systemd.services.factorio = {
      description   = "Factorio headless server";
      wantedBy      = [ "multi-user.target" ];
      after         = [ "network.target" ];

      preStart = toString [
        "test -e ${stateDir}/saves/${cfg.saveName}.zip"
        "||"
        "${factorio}/bin/factorio"
          "--config=${cfg.configFile}"
          "--create=${mkSavePath cfg.saveName}"
          (optionalString (cfg.mods != []) "--mod-directory=${modDir}")
      ];

      serviceConfig = {
        User = "factorio";
        Group = "factorio";
        Restart = "always";
        KillSignal = "SIGINT";
        WorkingDirectory = stateDir;
        PrivateTmp = true;
        UMask = "0007";
        ExecStart = toString [
          "${factorio}/bin/factorio"
          "--config=${cfg.configFile}"
          "--port=${toString cfg.port}"
          "--start-server=${mkSavePath cfg.saveName}"
          (optionalString (cfg.mods != []) "--mod-directory=${modDir}")
          (optionalString (cfg.autosave-interval != null) "--autosave-interval ${toString cfg.autosave-interval}")
        ];
      };
    };

    networking.firewall.allowedUDPPorts = [ cfg.port ];
  };
}
