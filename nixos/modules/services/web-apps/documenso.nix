{
  pkgs,
  lib,
  config,
  ...
}:
let
  cfg = config.services.documenso;
  needs_init = cfg.nextauthSecretKeyFile != null;
in
{
  options.services.documenso = {
    enable = lib.mkEnableOption "documenso";

    package = lib.mkPackageOption pkgs "documenso" { };

    user = lib.mkOption {
      type = lib.types.str;
      default = "documenso";
      description = "Name of the Documenso user.";
    };

    group = lib.mkOption {
      type = lib.types.str;
      default = "documenso";
      description = "Name of the Documenso group.";
    };

    port = lib.mkOption {
      type = lib.types.port;
      default = 3000;
      description = "Port on which to listen.";
    };

    nextauthSecretKeyFile = lib.mkOption {
      type = with lib.types; nullOr path;
      default = "/var/lib/documenso/nextauth-secret";
      description = ''
        Path to file containing the nextauth secret.
        A new nextauth secret can be generated by running:

        `openssl rand -hex 64`

        If this file does not exist, it will be created with a new secret key base.

        Set to null when setting NEXTAUTH_SECRET environment variable via
        other means (e.g. via `extraEnvFiles`).
      '';
    };

    settings = lib.mkOption {
      type = with lib.types; attrsOf str;
      default = { };
      description = "Takes precedence over the default settings set by the module";
    };

    extraEnvironmentFiles = lib.mkOption {
      type = with lib.types; listOf path;
      default = [ ];
      description = "Extra environment files to pass to Documenso services. Useful for passing down environmental secrets. e.g. NEXT_PRIVATE_ENCRYPTION_KEY";
    };
  };

  config = lib.mkIf cfg.enable {

    users.users.${cfg.user} = {
      isSystemUser = true;
      group = cfg.group;
    };

    users.groups.${cfg.group} = { };

    services.postgresql = {
      enable = true;

      ensureDatabases = [ "documenso" ];
      ensureUsers = [
        {
          name = "documenso";
          ensureDBOwnership = true;
        }
      ];
    };

    # Maybe also utilize this generation mechanism for NEXT_PRIVATE_ENCRYPTION_KEY and NEXT_PRIVATE_ENCRYPTION_SECONDARY_KEY in the future
    systemd.services.documenso-init = lib.mkIf needs_init {
      description = "Initialize Documenso Data";
      wantedBy = [ "multi-user.target" ];
      after = [ "network.target" ];
      partOf = [ "documenso.service" ];
      path = [ pkgs.openssl ];
      script = ''
        umask 0077

        if [[ ! -e ${lib.escapeShellArg cfg.nextauthSecretKeyFile} ]];
        then
          openssl rand -hex 64 > ${lib.escapeShellArg cfg.nextauthSecretKeyFile}
        fi
      '';
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        User = cfg.user;
        Group = cfg.group;
        StateDirectory = "documenso";
        PrivateTmp = "yes";
      };
    };

    systemd.services.documenso = {
      wantedBy = [ "multi-user.target" ];
      wants = [ "postgresql.service" ];
      after = [
        "postgresql.service"
      ]
      ++ lib.optional needs_init "documenso-init.service";
      environment = {
        PORT = toString cfg.port;
        NEXT_PRIVATE_INTERNAL_WEBAPP_URL = "http://localhost:${toString cfg.port}";
        NEXT_PRIVATE_DATABASE_URL = "postgresql://documenso@localhost/documenso?host=/run/postgresql";
        NEXT_PRIVATE_DIRECT_DATABASE_URL = "postgresql://documenso@localhost/documenso?host=/run/postgresql";
      }
      // cfg.settings;
      script = ''
        ${lib.optionalString (
          cfg.nextauthSecretKeyFile != null
        ) "export NEXTAUTH_SECRET=$(cat $CREDENTIALS_DIRECTORY/nextauth_secret)"}
        exec ${lib.getExe cfg.package}
      '';
      serviceConfig = {
        LoadCredential = lib.optional (
          cfg.nextauthSecretKeyFile != null
        ) "nextauth_secret:${cfg.nextauthSecretKeyFile}";
        User = cfg.user;
        Group = cfg.group;
        EnvironmentFile = cfg.extraEnvironmentFiles;
      }
      // lib.optionalAttrs (cfg.port < 1024) {
        AmbientCapabilities = [ "CAP_NET_BIND_SERVICE" ];
        CapabilityBoundingSet = [ "CAP_NET_BIND_SERVICE" ];
      };
    };
  };

  meta.maintainers = [ lib.teams.cyberus.members ];
}
