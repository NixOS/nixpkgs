# Options for Program Settings {#sec-settings-options}

Many programs have configuration files where program-specific settings
can be declared. File formats can be separated into two categories:

-   Nix-representable ones: These can trivially be mapped to a subset of
    Nix syntax. E.g. JSON is an example, since its values like
    `{"foo":{"bar":10}}` can be mapped directly to Nix:
    `{ foo = { bar = 10; }; }`. Other examples are INI, YAML and TOML.
    The following section explains the convention for these settings.

-   Non-nix-representable ones: These can't be trivially mapped to a
    subset of Nix syntax. Most generic programming languages are in this
    group, e.g. bash, since the statement `if true; then echo hi; fi`
    doesn't have a trivial representation in Nix.

    Currently there are no fixed conventions for these, but it is common
    to have a `configFile` option for setting the configuration file
    path directly. The default value of `configFile` can be an
    auto-generated file, with convenient options for controlling the
    contents. For example an option of type `attrsOf str` can be used
    for representing environment variables which generates a section
    like `export FOO="foo"`. Often it can also be useful to also include
    an `extraConfig` option of type `lines` to allow arbitrary text
    after the autogenerated part of the file.

## Nix-representable Formats (JSON, YAML, TOML, INI, ...) {#sec-settings-nix-representable}

By convention, formats like this are handled with a generic `settings`
option, representing the full program configuration as a Nix value. The
type of this option should represent the format. The most common formats
have a predefined type and string generator already declared under
`pkgs.formats`:

`pkgs.formats.javaProperties` { *`comment`* ? `"Generated with Nix"` }

:   A function taking an attribute set with values

    `comment`

    :   A string to put at the start of the
        file in a comment. It can have multiple
        lines.

    It returns the `type`: `attrsOf str` and a function
    `generate` to build a Java `.properties` file, taking
    care of the correct escaping, etc.

`pkgs.formats.hocon` { *`generator`* ? `<derivation>`, *`validator`* ? `<derivation>`, *`doCheck`* ? true }

:  A function taking an attribute set with values

    `generator`

    :   A derivation used for converting the JSON output
        from the nix settings into HOCON. This might be
        useful if your HOCON variant is slightly different
        from the java-based one, or for testing purposes.

    `validator`

    :   A derivation used for verifying that the HOCON
        output is correct and parsable. This might be
        useful if your HOCON variant is slightly different
        from the java-based one, or for testing purposes.

    `doCheck`

    :   Whether to enable/disable the validator check.

    It returns an attrset with a `type`, `generate` function,
    and a `lib` attset, as specified [below](#pkgs-formats-result).
    Some of the lib functions will be best understood if you have
    read the reference specification. You can find this
    specification here:

    <https://github.com/lightbend/config/blob/main/HOCON.md>

    Inside of `lib`, you will find these functions

    `mkInclude`

    :   This is used together with a specially named
        attribute `includes`, to include other HOCON
        sources into the document.

        The function has a shorthand variant where it
        is up to the HOCON parser to figure out what type
        of include is being used. The include will default
        to being non-required. If you want to be more
        explicit about the details of the include, you can
        provide an attrset with following arguments

        `required`

        :   Whether the parser should fail upon failure
            to include the document

        `type`

        :   Type of the source of the included document.
            Valid values are `file`, `url` and `classpath`.
            See upstream documentation for the semantics
            behind each value

        `value`

        :   The URI/path/classpath pointing to the source of
            the document to be included.

        `Example usage:`

        ```nix
          let
            format = pkgs.formats.hocon { };
            hocon_file = pkgs.writeText "to_include.hocon" ''
              a = 1;
            '';
          in {
            some.nested.hocon.attrset = {
              _includes = [
                (format.lib.mkInclude hocon_file)
                (format.lib.mkInclude "https://example.com/to_include.hocon")
                (format.lib.mkInclude {
                  required = true;
                  type = "file";
                  value = include_file;
                })
              ];
              ...
            };
          }
        ```

    `mkAppend`

    :   This is used to invoke the `+=` operator.
        This can be useful if you need to add something
        to a list that is included from outside of nix.
        See upstream documentation for the semantics
        behind the `+=` operation.

        `Example usage:`

        ```nix
          let
            format = pkgs.formats.hocon { };
            hocon_file = pkgs.writeText "to_include.hocon" ''
              a = [ 1 ];
              b = [ 2 ];
            '';
          in {
            _includes = [
              (format.lib.mkInclude hocon_file)
            ];

            c = 3;
            a = format.lib.mkAppend 3;
            b = format.lib.mkAppend (format.lib.mkSubstitution "c");
          }
        ```

    `mkSubstitution`

    :   This is used to make HOCON substitutions.
        Similarly to `mkInclude`, this function has
        a shorthand variant where you just give it
        the string with the substitution value.
        The substitution is not optional by default.
        Alternatively, you can provide an attrset
        with more options

        `optional`

        :   Whether the parser should fail upon
            failure to fetch the substitution value.

        `value`

        :   The name of the variable to use for
            substitution.

        See upstream documentation for semantics
        behind the substitution functionality.

        `Example usage:`

        ```nix
          let
            format = pkgs.formats.hocon { };
          in {
            a = 1;
            b = format.lib.mkSubstitution "a";
            c = format.lib.mkSubstitution "SOME_ENVVAR";
            d = format.lib.mkSubstitution {
              value = "SOME_OPTIONAL_ENVVAR";
              optional = true;
            };
          }
        ```

    `Implementation notes:`

    - classpath includes are not implemented in pyhocon,
      which is used for validating the HOCON output. This
      means that if you are using classpath includes,
      you will want to either use an alternative validator
      or set `doCheck = false` in the format options.

`pkgs.formats.libconfig` { *`generator`* ? `<derivation>`, *`validator`* ? `<derivation>` }

:  A function taking an attribute set with values

    `generator`

    :   A derivation used for converting the JSON output
        from the nix settings into libconfig. This might be
        useful if your libconfig variant is slightly different
        from the original one, or for testing purposes.

    `validator`

    :   A derivation used for verifying that the libconfig
        output is correct and parsable. This might be
        useful if your libconfig variant is slightly different
        from the original one, or for testing purposes.

    It returns an attrset with a `type`, `generate` function,
    and a `lib` attset, as specified [below](#pkgs-formats-result).
    Some of the lib functions will be best understood if you have
    read the reference specification. You can find this
    specification here:

    <https://hyperrealm.github.io/libconfig/libconfig_manual.html#Configuration-Files>

    Inside of `lib`, you will find these functions

    `mkHex`, `mkOctal`, `mkFloat`

    :   Use these to specify numbers in other formats.

        `Example usage:`

        ```nix
          let
            format = pkgs.formats.libconfig { };
          in {
            myHexValue = format.lib.mkHex "0x1FC3";
            myOctalValue = format.lib.mkOctal "0027";
            myFloatValue = format.lib.mkFloat "1.2E-3";
          }
        ```

    `mkArray`, `mkList`

    :   Use these to differentiate between whether
        a nix list should be considered as a libconfig
        array or a libconfig list. See the upstream
        documentation for the semantics behind these types.

        `Example usage:`

        ```nix
          let
            format = pkgs.formats.libconfig { };
          in {
            myList = format.lib.mkList [ "foo" 1 true ];
            myArray = format.lib.mkArray [ 1 2 3 ];
          }
        ```

    `Implementation notes:`

    - Since libconfig does not allow setting names to start with an underscore,
      this is used as a prefix for both special types and include directives.

    - The difference between 32bit and 64bit values became optional in libconfig
      1.5, so we assume 64bit values for all numbers.

`pkgs.formats.json` { }

:   A function taking an empty attribute set (for future extensibility)
    and returning a set with JSON-specific attributes `type` and
    `generate` as specified [below](#pkgs-formats-result).

`pkgs.formats.yaml` { }

:   A function taking an empty attribute set (for future extensibility)
    and returning a set with YAML-specific attributes `type` and
    `generate` as specified [below](#pkgs-formats-result).

`pkgs.formats.ini` { *`listsAsDuplicateKeys`* ? false, *`listToValue`* ? null, \.\.\. }

:   A function taking an attribute set with values

    `listsAsDuplicateKeys`

    :   A boolean for controlling whether list values can be used to
        represent duplicate INI keys

    `listToValue`

    :   A function for turning a list of values into a single value.

    It returns a set with INI-specific attributes `type` and `generate`
    as specified [below](#pkgs-formats-result).
    The type of the input is an *attrset* of sections; key-value pairs where
    the key is the section name and the value is the corresponding content
    which is also an *attrset* of key-value pairs for the actual key-value
    mappings of the INI format.
    The values of the INI atoms are subject to the above parameters (e.g. lists
    may be transformed into multiple key-value pairs depending on
    `listToValue`).

    The attribute `lib.type.atom` contains the used INI atom.

`pkgs.formats.iniWithGlobalSection` { *`listsAsDuplicateKeys`* ? false, *`listToValue`* ? null, \.\.\. }

:   A function taking an attribute set with values

    `listsAsDuplicateKeys`

    :   A boolean for controlling whether list values can be used to
        represent duplicate INI keys

    `listToValue`

    :   A function for turning a list of values into a single value.

    It returns a set with INI-specific attributes `type` and `generate`
    as specified [below](#pkgs-formats-result).
    The type of the input is an *attrset* of the structure
    `{ sections = {}; globalSection = {}; }` where *sections* are several
    sections as with *pkgs.formats.ini* and *globalSection* being just a single
    attrset of key-value pairs for a single section, the global section which
    precedes the section definitions.

    The attribute `lib.type.atom` contains the used INI atom.

`pkgs.formats.toml` { }

:   A function taking an empty attribute set (for future extensibility)
    and returning a set with TOML-specific attributes `type` and
    `generate` as specified [below](#pkgs-formats-result).

`pkgs.formats.xml` { format ? "badgerfish", withHeader ? true}

:   A function taking an attribute set with values
    and returning a set with XML-specific attributes `type` and
    `generate` as specified [below](#pkgs-formats-result).

    `format`

    :   Input format. Because XML can not be translated one-to-one, we have to use intermediate formats. Possible values:
      - `"badgerfish"`: Uses [badgerfish](http://www.sklar.com/badgerfish/) conversion.

    `withHeader`

    :   Outputs the xml with header.

`pkgs.formats.cdn` { }

:   A function taking an empty attribute set (for future extensibility)
    and returning a set with [CDN](https://github.com/dzikoysk/cdn)-specific
    attributes `type` and `generate` as specified [below](#pkgs-formats-result).

`pkgs.formats.kdl` { `version` }

:   A function taking a KDL version (`version == 1 || version == 2`)
    and returning a set with [KDL](https://kdl.dev/)-specific attributes `type`,
    `lib` and `generate` as specified [below](#pkgs-formats-result).

    The `version` argument is used by the generator to choose which syntax revision to use.
    As the data model between both KDL specs are identical, the Nix library interface is identical for both.

    KDL is different from most of the other formats, because it does not primarily compose with attrsets.
    Nevertheless, it can be represented in Nix.

    The main type of the KDL format is the [KDL document](https://kdl.dev/spec/#name-document),
    which is fundamentally a list of [KDL nodes](https://kdl.dev/spec/#name-node).

    The Nix representation of a KDL node is an attrset with the following elements:

    - `name` is the name of the node. It is a string. (required)
    - `type` is the [Type Annotation](https://kdl.dev/spec/#name-type-annotation) of the node. It is a string or `null`. (default: `null`)
    - `arguments` is the [Arguments](https://kdl.dev/spec/#name-argument) of the node. It is a list of KDL values. (default: `[]`)
    - `properties` is the [Properties](https://kdl.dev/spec/#name-property) of the node. It is an attrset of KDL values. (default: `{}`)
    - `children` is the [Children block](https://kdl.dev/spec/#name-children-block) of the node. It is a KDL document. (default: `[]`)

    A KDL value (the element of `arguments` and `properties`) comes in one of two forms. Either, it can be a scalar value on its own:

    - `null`
    - a boolean
    - an integer
    - a floating pointer number
    - a string
    - a path (coerced to a string in the KDL document)

    Or, a KDL value can have a type. In this case, it is represented as an attrset with the names `type` and `value`,
    where `type` is identical to the type of a node, and `value` is obligatory.

    And lastly, a KDL document is just a list of KDL nodes. As such, you can specify a KDL document like so:

    ```nix
    [
      {
        name = "hello";
        arguments = ["world"];
        children = [
          {
            name = "foo";
            properties = {
              x = 5.0;
              y = {
                type = "i16";
                value = 4;
              };
            };
          }
        ];
      }
    ]
    ```

    And this is equivalent to the following KDL file:

    ```kdl
    hello "world" {
      foo x=5.0 y=(i16)4
    }
    ```

    Additionally, the `lib` provided by this format has two helper functions, to make the above a bit more ergonomic:
    ```nix
    {
      node = name: type: arguments: properties: children: { inherit name type arguments properties children; };
      typed = type: value: { inherit type value; };
    }
    ```

    Using these, you can write the same document like so:

    ```nix
    [
      (node "hello" null ["world"] {} [
        (node "foo" null [] { x=5.0; y=typed "i16" 4; } [])
      ])
    ]
    ```

    For use in modules, this format provides an option type `type`. It defines the type of a KDL document, as described above.
    However, the KDL document provided by the `type` of this format has a unique restriction: it can only be defined in one location.
    This is because the merging of KDL configurations is highly application-dependent, and it is fundamentally incorrect
    to define it from several locations.

    Modules with a KDL configuration should make sure that one of the following is true:

    - They reserve the config *entirely to the user*, making sure any "default configuration" can be applied *independent* of this config file
    - They define configuration themselves, and expose an `extraConfig` style option to insert additional nodes.

    The document type also allows "splatting" a configuration, and conditional nodes with `lib.mkIf`. These features should be preferred, as they make the evaluation lazier and less prone to recursion errors. To "splat" a partial document, simply insert it in place of where a node is expected.

    A full example of the `type` is like so:

    ```nix
    {
      lib,
      pkgs,
      config,
      ...
    }:
    let
      cfg = config.services.foo;
      kdl = pkgs.formats.kdl { version = 2; };
    in {
      options.services.foo = {
        state-directory = lib.mkOption {
          type = lib.types.str;
          default = "/var/lib/foo";
        };

        # Let's say `foo` can listen in many ways:
        #
        # listen (port)7462
        # listen (unix)"/run/foo/bar.sock"
        #
        listen = lib.mkOption {
          type = lib.types.attrTag {
            port = lib.mkOption { type = lib.types.port; };
            unix = lib.mkOption { type = lib.types.str; };
          };
          default.unix = "/run/foo/bar.sock";
        };

        extraConfig = lib.mkOption {
          type = kdl.type;
          default = [];
          description = ''
            Additional configuration applied to `foo`.
          '';
        };

        rendered = lib.mkOption {
          type = kdl.type;
          description = ''
            The configuration of `foo`, as rendered from all the other options in this module.
            You can `lib.mkForce` this to control the full configuration file.
            Use {option}`services.foo.extraConfig` to append to it.
          '';
          defaultText = "a KDL document based on `services.foo.*`"
        };
      };

      # recommended to define the value with the normal priority.
      config.services.foo.rendered = let
        inherit (kdl.lib) node typed;
      in [
        (node "state-directory" null [cfg.state-directory] {} [])

        # somewhat contrived, to show off `lib.mkIf` in here
        (lib.mkIf (cfg.listen?port) (
          (node "listen" null [(typed "port" cfg.listen.port)] {} [])
        ))
        (lib.mkIf (cfg.listen?unix) (
          (node "listen" null [(typed "unix" cfg.listen.unix)] {} [])
        ))

        # splatting: this inserts all the nodes from `extraConfig`.
        cfg.extraConfig
      ];
    }
    ```

    The value of `cfg.rendered` in the above configuration will be a *normalized* KDL document: all "splats" will be flattened, and any `mkIf`s will be evaluated.

    Lastly, the `generate` output of the KDL format (`kdl.generate`) will take a normalized KDL document, and produces a derivation with the configuration file.

    Note that the "splatting" and `lib.mkIf` functionality is only available when the document is assigned to an option of type `kdl.type`.
    These features do not work if you bypass the normalization, and directly pass nodes into `kdl.generate`.

`pkgs.formats.elixirConf { elixir ? pkgs.elixir }`

:   A function taking an attribute set with values

    `elixir`

    :   The Elixir package which will be used to format the generated output

    It returns a set with Elixir-Config-specific attributes `type`, `lib`, and
    `generate` as specified [below](#pkgs-formats-result).

    The `lib` attribute contains functions to be used in settings, for
    generating special Elixir values:

    `mkRaw elixirCode`

    :   Outputs the given string as raw Elixir code

    `mkGetEnv { envVariable, fallback ? null }`

    :   Makes the configuration fetch an environment variable at runtime

    `mkAtom atom`

    :   Outputs the given string as an Elixir atom, instead of the default
        Elixir binary string. Note: lowercase atoms still needs to be prefixed
        with `:`

    `mkTuple array`

    :   Outputs the given array as an Elixir tuple, instead of the default
        Elixir list

    `mkMap attrset`

    :   Outputs the given attribute set as an Elixir map, instead of the
        default Elixir keyword list

`pkgs.formats.lua { asBindings ? false, multiline ? true, columnWidth ? 100, indentWidth ? 2, indentUsingTabs ? false }`

:   A function taking an attribute set with values

    `asBindings` (default `false`)

    :   Whether to treat attributes as variable bindings

    `multiline` (default `true`)

    :   Whether to produce a multiline output. The output may still wrap across
        multiple lines if it would otherwise exceed `columnWidth`.

    `columnWidth` (default `100`)

    :   The column width to use to attempt to wrap lines.

    `indentWidth` (default `2`)

    :   The width of a single indentation level.

    `indentUsingTabs` (default `false`)

    :   Whether the indentation should use tabs instead of spaces.

`pkgs.formats.php { finalVariable }` []{#pkgs-formats-php}

:   A function taking an attribute set with values

    `finalVariable`

    :   The variable that will store generated expression (usually `config`). If set to `null`, generated expression will contain `return`.

    It returns a set with PHP-Config-specific attributes `type`, `lib`, and
    `generate` as specified [below](#pkgs-formats-result).

    The `lib` attribute contains functions to be used in settings, for
    generating special PHP values:

    `mkRaw phpCode`

    :   Outputs the given string as raw PHP code

    `mkMixedArray list set`

    :   Creates PHP array that contains both indexed and associative values. For example, `lib.mkMixedArray [ "hello" "world" ] { "nix" = "is-great"; }` returns `['hello', 'world', 'nix' => 'is-great']`

[]{#pkgs-formats-result}
These functions all return an attribute set with these values:

`type`

:   A module system type representing a value of the format

`lib`

:   Utility functions for convenience, or special interactions with the format.
    This attribute is optional. It may contain inside a `types` attribute
    containing types specific to this format.

`generate` *`filename jsonValue`*

:   A function that can render a value of the format to a file. Returns
    a file path.

    ::: {.note}
    This function puts the value contents in the Nix store. So this
    should be avoided for secrets.
    :::

::: {#ex-settings-nix-representable .example}
### Module with conventional `settings` option

The following shows a module for an example program that uses a JSON
configuration file. It demonstrates how above values can be used, along
with some other related best practices. See the comments for
explanations.

```nix
{
  options,
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.services.foo;
  # Define the settings format used for this program
  settingsFormat = pkgs.formats.json { };
in
{

  options.services.foo = {
    enable = lib.mkEnableOption "foo service";

    settings = lib.mkOption {
      # Setting this type allows for correct merging behavior
      type = settingsFormat.type;
      default = { };
      description = ''
        Configuration for foo, see
        <link xlink:href="https://example.com/docs/foo"/>
        for supported settings.
      '';
    };
  };

  config = lib.mkIf cfg.enable {
    # We can assign some default settings here to make the service work by just
    # enabling it. We use `mkDefault` for values that can be changed without
    # problems
    services.foo.settings = {
      # Fails at runtime without any value set
      log_level = lib.mkDefault "WARN";

      # We assume systemd's `StateDirectory` is used, so we require this value,
      # therefore no mkDefault
      data_path = "/var/lib/foo";

      # Since we use this to create a user we need to know the default value at
      # eval time
      user = lib.mkDefault "foo";
    };

    environment.etc."foo.json".source =
      # The formats generator function takes a filename and the Nix value
      # representing the format value and produces a filepath with that value
      # rendered in the format
      settingsFormat.generate "foo-config.json" cfg.settings;

    # We know that the `user` attribute exists because we set a default value
    # for it above, allowing us to use it without worries here
    users.users.${cfg.settings.user} = {
      isSystemUser = true;
    };

    # ...
  };
}
```
:::

### Option declarations for attributes {#sec-settings-attrs-options}

Some `settings` attributes may deserve some extra care. They may need a
different type, default or merging behavior, or they are essential
options that should show their documentation in the manual. This can be
done using [](#sec-freeform-modules).

We extend above example using freeform modules to declare an option for
the port, which will enforce it to be a valid integer and make it show
up in the manual.

::: {#ex-settings-typed-attrs .example}
### Declaring a type-checked `settings` attribute
```nix
{
  settings = lib.mkOption {
    type = lib.types.submodule {

      freeformType = settingsFormat.type;

      # Declare an option for the port such that the type is checked and this option
      # is shown in the manual.
      options.port = lib.mkOption {
        type = lib.types.port;
        default = 8080;
        description = ''
          Which port this service should listen on.
        '';
      };

    };
    default = { };
    description = ''
      Configuration for Foo, see
      <link xlink:href="https://example.com/docs/foo"/>
      for supported values.
    '';
  };
}
```
:::
