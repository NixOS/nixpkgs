<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="sec-customising-packages">
  <title>Customising Packages</title>
  <para>
    In Nix, packages are usually referred to as
    <literal>pkgs.git</literal>. This expression can be extended to
    allow modification of the package. For example, instead of
    <literal>pkgs.git</literal> you can also use
    <literal>(pkgs.git.override { guiSupport = true; })</literal>. This
    results in a new package where support for Git GUI is enabled. When
    using this expression, a package is built that includes the
    <literal>git-gui</literal> binary.
  </para>
  <para>
    The Nixpkgs manual has information about modifying existing packages
    by overriding. See
    <link xlink:href="https://nixos.org/manual/nixpkgs/stable/#chap-overrides">the
    chapter on overriding</link> to know more.
  </para>
  <para>
    Here we will focus on the ways to use those modified packages in
    NixOS. We describe 3 methods:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>
        <link linkend="system-environment">System environment</link> for
        executable packages available system-wide
      </para>
    </listitem>
    <listitem>
      <para>
        <link linkend="package-options-in-nix-os-modules">package
        options in NixOS modules</link> for background services and
        programs
      </para>
    </listitem>
    <listitem>
      <para>
        <link linkend="nixpkgs-overlays">Nixpkgs overlays</link> for
        in-place package replacements and additions
      </para>
    </listitem>
  </itemizedlist>
  <section>
    <title>System environment (#system-environment)</title>
    <para>
      Using a custom package in
      <literal>environment.systemPackages</literal> will only change the
      system environment. Basically, it’ll allow you to change the
      packages that you’d use in your terminal, but not anything else.
    </para>
    <para>
      Changing:
    </para>
    <programlisting language="bash">
{
  environment.systemPackages = [
    pkgs.git
  ];
}
</programlisting>
    <para>
      To:
    </para>
    <programlisting language="bash">
{
  environment.systemPackages = [
    (pkgs.git.override { guiSupport = true; })
  ];
}
</programlisting>
    <para>
      will allow you to use the Git GUI tools
      (<literal>git-gui</literal>) in your terminal. It
      <emphasis>doesn’t</emphasis> alter packages or NixOS modules that
      <emphasis>depend</emphasis> on Git. This is an important
      distinction, as it only affects the environment (applications
      available in <literal>PATH</literal>) and doesn’t rebuild any
      other packages.
    </para>
  </section>
  <section>
    <title>Package options in NixOS modules
    (#package-options-in-nix-os-modules)</title>
    <para>
      Some packages are only used in background services, so you won’t
      interact with them directly. In NixOS these are often configured
      with <literal>services.*.enable</literal> options.
    </para>
    <para>
      These options usually also have an option to change the package
      for the service, named <literal>services.*.package</literal>.
    </para>
    <para>
      For example, pipewire is a service to handle audio and video
      streams on a system. It is enabled on NixOS using:
    </para>
    <programlisting language="bash">
{
  services.pipewire.enable = true;
}
</programlisting>
    <para>
      To override the pipewire package being used, the following option
      can be added:
    </para>
    <programlisting language="bash">
{
  services.pipewire.package = pkgs.pipewire.override { x11Support = false; };
}
</programlisting>
    <para>
      In this case <literal>pipewire</literal> is compiled without x11
      support. The resulting package is used as the pipewire background
      service, which will be configured by NixOS in systemd.
    </para>
    <para>
      Just like with <literal>systemPackages</literal>, the altered
      package is only used in the NixOS system and packages that depend
      on pipewire will still refer to the original pipewire package.
    </para>
  </section>
  <section>
    <title>Nixpkgs overlays (#nixpkgs-overlays)</title>
    <para>
      Overlays in Nix allow extending Nixpkgs. Like the name suggests,
      it overlays your package definitions on top of Nixpkgs. Usually
      this means that you can alter what packages are available in the
      <literal>pkgs</literal> variable, allowing you to add or overwrite
      packages.
    </para>
    <para>
      With overlays you can replace an existing package system-wide.
      That means overwriting an existing package with your own will not
      only change your system, but can also change all packages that
      depend on the original package.
    </para>
    <para>
      This can be useful when you want to for instance patch a library
      that is used by other software. It does however require all
      depending packages to be rebuild. Nix does these rebuilds
      seamlessly and automatically, but it does cost time.
    </para>
    <para>
      Also a word of warning: overlays can become confusing. You
      generally want to be aware of overwritten packages in overlays. It
      is not obvious when referring to a package
      <literal>pkgs.git</literal> that it is different from what is in
      Nixpkgs. This can become especially confusing when overwriting
      packages like <literal>openssl</literal>, which
      <literal>git</literal> and many other packages depends on. With
      great power comes great responsibility!
    </para>
    <para>
      On NixOS you can use
      <link xlink:href="https://search.nixos.org/options?show=nixpkgs.overlays&amp;query=nixpkgs.overlays">the
      <literal>nixpkgs.overlays</literal> option</link>:
    </para>
    <programlisting language="bash">
{
  nixpkgs.overlays = [
    (final: prev: {
      pipewire = prev.pipewire.override { x11Support = false; };
    })
  ];
}
</programlisting>
    <para>
      When creating such an overlay, it is not needed anymore to specify
      the override in <literal>systemPackages</literal> nor
      <literal>services.*.package</literal>, as
      <literal>pkgs.pipewire</literal> will only refer to this
      overridden package.
    </para>
    <para>
      Note that the overlay is defined as a function with the arguments
      <literal>final</literal> and <literal>prev</literal>.
    </para>
    <para>
      <literal>prev</literal> refers to the previous layer, the
      underlying one. In this case that is <literal>nixpkgs</literal>.
      We take the original package from <literal>nixpkgs</literal> using
      <literal>prev.pipewire</literal> and alter that package. With
      <literal>pipewire = ...;</literal> we overwrite the orignal
      pipewire package in succeeding layers, which eventually results in
      the change in <literal>pkgs</literal>.
    </para>
    <para>
      <literal>final</literal> refers to the top-level overlay, which
      includes our overwritten packages. If we want to refer to a
      another package that we have overridden, then we can refer to
      <literal>final</literal>.
    </para>
    <para>
      More information about overlays can be found in
      <link xlink:href="https://nixos.org/manual/nixpkgs/stable/#chap-overlays">the
      Nixpkgs manual</link>.
    </para>
    <para>
      It is also possible to introduce a new attribute for custom
      packages, so that you can refer to this attribute in other parts
      of your configuration. For instance:
    </para>
    <programlisting language="bash">
{
  nixpkgs.overlays = [
    (final: prev: {
      git-with-gui = prev.git.override { guiSupport = true; };
    })
  ];
}
</programlisting>
    <para>
      will allow referring to <literal>pkgs.git-with-gui</literal>
      where-ever you have access to pkgs. For instance in NixOS:
    </para>
    <programlisting language="bash">
{
  environment.systemPackages = [ pkgs.git-with-gui ];
}
</programlisting>
    <para>
      Or even in Nix CLI:
    </para>
    <programlisting language="bash">
nix-env -iA git-with-gui
</programlisting>
    <para>
      Note that even though we have a new attribute name in the above
      example, the <emphasis>name of the package</emphasis> didn’t
      change. The name is part of the derivation. The package is called
      <literal>git</literal>, so the Nix store path is still
      <literal>/nix/store/*-git</literal>. When using
      <literal>.override</literal> this part of the derivation would not
      change. The name can only be changed using
      <literal>.overrideAttrs</literal>.
    </para>
  </section>
  <section>
    <title>Common use-cases (#use-cases)</title>
    <para>
      With the above knowledge we can tackle a number of common
      use-cases.
    </para>
    <section>
      <title>Use different version of a package in NixOS</title>
      <programlisting language="bash">
{
  services.xserver.windowManager.i3.package = pkgs.i3.overrideAttrs (previousAttrs: {
    name = &quot;i3-next&quot;;
    src = pkgs.fetchFromGitHub {
      owner = &quot;i3&quot;;
      repo = &quot;i3&quot;;
      rev = &quot;81287743869a5bdec4ffc0c1e6d1f8fd33920bcb&quot;;
      hash = pkgs.lib.fakeHash;
    };
  });
}
</programlisting>
      <para>
        This overrides the <literal>i3</literal> package with a version
        based on
        https://github.com/i3/i3/commit/81287743869a5bdec4ffc0c1e6d1f8fd33920bcb.
        <literal>pkgs.lib.fakeHash</literal> is a placeholder for the
        actual hash of the retrieved directory. Upon building Nix will
        ask to replace it with the actual hash that Nix calculated.
      </para>
      <para>
        The <literal>name = &quot;i3-next&quot;</literal> is also set.
        This is to make sure the new package name doesn’t equal the
        original package name (<literal>i3-X.X.X</literal>).
      </para>
    </section>
    <section>
      <title>Use local source code for a package</title>
      <programlisting language="bash">
{
  environment.systemPackages = [ pkgs.myfortune ];

  nixpkgs.overlays = [
    (final: prev: {
      myfortune = prev.fortune.overrideAttrs (previousAttrs: {
        src = ./fortune-src;
      });
    })
  ];
}
</programlisting>
      <para>
        This creates a new attribute <literal>myfortune</literal> that
        uses the build steps from <literal>fortune</literal> to build
        source code from a local directory
        <literal>./fortune-src</literal> into a package. It makes the
        package available through
        <literal>environment.systemPackages</literal>, so that it is
        available in the terminal.
      </para>
    </section>
    <section>
      <title>Use a different dependency for a single package</title>
      <programlisting language="bash">
{
  nixpkgs.overlays = [
    (final: prev: {
      maven-jdk8 = prev.maven.override {
        jdk = final.jdk8;
      };
    })
  ];
}
</programlisting>
      <para>
        This creates a new attribute <literal>maven-jdk8</literal> that
        builds and runs maven explicitly under <literal>jdk8</literal>.
        Notice that <literal>final.jdk8</literal> is used, so that other
        overlays may potentially overwrite <literal>jdk8</literal>. Also
        note that <literal>final.maven</literal> is
        <emphasis>not</emphasis> used, because that would refer to this
        package, causing an infinite loop during Nix evaluation.
      </para>
    </section>
    <section>
      <title>Apply a security patch system-wide</title>
      <programlisting language="bash">
{
  nixpkgs.overlays = [
    (final: prev: {
      openssl = prev.openssl.overrideAttrs (previousAttrs: {
        patches = previousAttrs.patches ++ [
          (fetchpatch {
            name = &quot;CVE-2021-4044.patch&quot;;
            url = &quot;https://git.openssl.org/gitweb/?p=openssl.git;a=patch;h=758754966791c537ea95241438454aa86f91f256&quot;;
            hash = pkgs.lib.fakeHash;
          })
        ];
      });
    })
  ];
}
</programlisting>
      <para>
        This overwrites <literal>openssl</literal> with a patched
        version. The patch itself is fetched from OpenSSL’s own git
        repository. Overwriting <literal>openssl</literal> in an overlay
        will rebuild and test all packages that depend on OpenSSL as
        well, so in this case can lead to high build times.
      </para>
    </section>
  </section>
</section>
