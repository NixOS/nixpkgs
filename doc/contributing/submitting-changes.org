* Submitting changes
  :PROPERTIES:
  :CUSTOM_ID: chap-submitting-changes
  :END:

* Making patches
  :PROPERTIES:
  :CUSTOM_ID: submitting-changes-making-patches
  :END:

- Read [[https://nixos.org/nixpkgs/manual/][Manual (How to write
  packages for Nix)]].

- Fork the repository on GitHub.

- Create a branch for your future fix.

  - You can make branch from a commit of your local =nixos-version=.
    That will help you to avoid additional local compilations. Because
    you will receive packages from binary cache.

    - For example: =nixos-version= returns =15.05.git.0998212 (Dingo)=.
      So you can do:

    #+BEGIN_EXAMPLE
      $ git checkout 0998212
      $ git checkout -b 'fix/pkg-name-update'
    #+END_EXAMPLE

  - Please avoid working directly on the =master= branch.

- Make commits of logical units.

  - If you removed pkgs, made some major NixOS changes etc., write about
    them in =nixos/doc/manual/release-notes/rl-unstable.xml=.

- Check for unnecessary whitespace with =git diff --check= before
  committing.

- Format the commit in a following way:

  #+BEGIN_EXAMPLE
    (pkg-name | nixos/<module>): (from -> to | init at version | refactor | etc)
    Additional information.
  #+END_EXAMPLE

  - Examples:

    - =nginx: init at 2.0.1=

    - =firefox: 54.0.1 -> 55.0=

    - =nixos/hydra: add bazBaz option=

    - =nixos/nginx: refactor config generation=

- Test your changes. If you work with

  - nixpkgs:

    - update pkg ->

      - =nix-env -i pkg-name -f <path to your local nixpkgs folder>=

    - add pkg ->

      - Make sure it's in =pkgs/top-level/all-packages.nix=

      - =nix-env -i pkg-name -f <path to your local nixpkgs folder>=

    - /If you don't want to install pkg in you profile/.

      - =nix-build -A pkg-attribute-name <path to your local nixpkgs folder>/default.nix=
        and check results in the folder =result=. It will appear in the
        same directory where you did =nix-build=.

    - If you did =nix-env -i pkg-name= you can do =nix-env -e pkg-name=
      to uninstall it from your system.

  - NixOS and its modules:

    - You can add new module to your NixOS configuration file (usually
      it's =/etc/nixos/configuration.nix=). And do
      =sudo nixos-rebuild test -I nixpkgs=<path to your local nixpkgs folder> --fast=.

- If you have commits =pkg-name: oh, forgot to insert whitespace=:
  squash commits in this case. Use =git rebase -i=.

- Rebase you branch against current =master=.

* Submitting changes
  :PROPERTIES:
  :CUSTOM_ID: submitting-changes-submitting-changes
  :END:

- Push your changes to your fork of nixpkgs.

- Create pull request:

  - Write the title in format
    =(pkg-name | nixos/<module>): improvement=.

    - If you update the pkg, write versions =from -> to=.

  - Write in comment if you have tested your patch. Do not rely much on
    =TravisCI=.

  - If you make an improvement, write about your motivation.

  - Notify maintainers of the package. For example add to the message:
    =cc @jagajaga @domenkozar=.

* Pull Request Template
  :PROPERTIES:
  :CUSTOM_ID: submitting-changes-pull-request-template
  :END:

The pull request template helps determine what steps have been made for
a contribution so far, and will help guide maintainers on the status of
a change. The motivation section of the PR should include any extra
details the title does not address and link any existing issues related
to the pull request.

When a PR is created, it will be pre-populated with some checkboxes
detailed below:

** Tested using sandboxing
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-tested-with-sandbox
   :END:

When sandbox builds are enabled, Nix will setup an isolated environment
for each build process. It is used to remove further hidden dependencies
set by the build environment to improve reproducibility. This includes
access to the network during the build outside of =fetch*= functions and
files outside the Nix store. Depending on the operating system access to
other resources are blocked as well (ex. inter process communication is
isolated on Linux); see
[[https://nixos.org/nix/manual/#conf-sandbox][sandbox]] in Nix manual
for details.

Sandboxing is not enabled by default in Nix due to a small performance
hit on each build. In pull requests for
[[https://github.com/NixOS/nixpkgs/][nixpkgs]] people are asked to test
builds with sandboxing enabled (see =Tested using sandboxing= in the
pull request template) because in[[https://nixos.org/hydra/]] sandboxing
is also used.

Depending if you use NixOS or other platforms you can use one of the
following methods to enable sandboxing *before* building the package:

- *Globally enable sandboxing on NixOS*: add the following to
  =configuration.nix=

  #+BEGIN_EXAMPLE
    nix.useSandbox = true;
  #+END_EXAMPLE

- *Globally enable sandboxing on non-NixOS platforms*: add the following
  to: =/etc/nix/nix.conf=

  #+BEGIN_EXAMPLE
    sandbox = true
  #+END_EXAMPLE

** Built on platform(s)
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-platform-diversity
   :END:

Many Nix packages are designed to run on multiple platforms. As such,
it's important to let the maintainer know which platforms your changes
have been tested on. It's not always practical to test a change on all
platforms, and is not required for a pull request to be merged. Only
check the systems you tested the build on in this section.

** Tested via one or more NixOS test(s) if existing and applicable for
the change (look inside nixos/tests)
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-nixos-tests
   :END:

Packages with automated tests are much more likely to be merged in a
timely fashion because it doesn't require as much manual testing by the
maintainer to verify the functionality of the package. If there are
existing tests for the package, they should be run to verify your
changes do not break the tests. Tests only apply to packages with NixOS
modules defined and can only be run on Linux. For more details on
writing and running tests, see the
[[https://nixos.org/nixos/manual/index.html#sec-nixos-tests][section in
the NixOS manual]].

** Tested compilation of all pkgs that depend on this change using
=nix-review=
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-tested-compilation
   :END:

If you are updating a package's version, you can use nix-review to make
sure all packages that depend on the updated package still compile
correctly. The =nix-review= utility can look for and build all
dependencies either based on uncommited changes with the =wip= option or
specifying a github pull request number.

review changes from pull request number 12345:

#+BEGIN_EXAMPLE
  nix-shell -p nix-review --run "nix-review pr 12345"
#+END_EXAMPLE

review uncommitted changes:

#+BEGIN_EXAMPLE
  nix-shell -p nix-review --run "nix-review wip"
#+END_EXAMPLE

** Tested execution of all binary files (usually in =./result/bin/=)
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-tested-execution
   :END:

It's important to test any executables generated by a build when you
change or create a package in nixpkgs. This can be done by looking in
=./result/bin= and running any files in there, or at a minimum, the main
executable for the package. For example, if you make a change to
texlive, you probably would only check the binaries associated with the
change you made rather than testing all of them.

** Meets Nixpkgs contribution standards
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-contribution-standards
   :END:

The last checkbox is fits
[[https://github.com/NixOS/nixpkgs/blob/master/.github/CONTRIBUTING.md][CONTRIBUTING.md]].
The contributing document has detailed information on standards the Nix
community has for commit messages, reviews, licensing of contributions
you make to the project, etc... Everyone should read and understand the
standards the community has for contributing before submitting a pull
request.

* Hotfixing pull requests
  :PROPERTIES:
  :CUSTOM_ID: submitting-changes-hotfixing-pull-requests
  :END:

- Make the appropriate changes in you branch.

- Don't create additional commits, do

  - =git rebase -i=

  - =git push --force= to your branch.

* Commit policy
  :PROPERTIES:
  :CUSTOM_ID: submitting-changes-commit-policy
  :END:

- Commits must be sufficiently tested before being merged, both for the
  master and staging branches.

- Hydra builds for master and staging should not be used as testing
  platform, it's a build farm for changes that have been already tested.

- When changing the bootloader installation process, extra care must be
  taken. Grub installations cannot be rolled back, hence changes may
  break people's installations forever. For any non-trivial change to
  the bootloader please file a PR asking for review, especially from
  @edolstra.

** Master branch
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-master-branch
   :END:

The =master= branch is the main development branch. It should only see
non-breaking commits that do not cause mass rebuilds.

** Staging branch
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-staging-branch
   :END:

The =staging= branch is a development branch where mass-rebuilds go. It
should only see non-breaking mass-rebuild commits. That means it is not
to be used for testing, and changes must have been well tested already.
If the branch is already in a broken state, please refrain from adding
extra new breakages.

** Staging-next branch
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-staging-next-branch
   :END:

The =staging-next= branch is for stabilizing mass-rebuilds submitted to
the =staging= branch prior to merging them into =master=. Mass-rebuilds
should go via the =staging= branch. It should only see non-breaking
commits that are fixing issues blocking it from being merged into the
=master = branch.

If the branch is already in a broken state, please refrain from adding
extra new breakages. Stabilize it for a few days and then merge into
master.

** Stable release branches
   :PROPERTIES:
   :CUSTOM_ID: submitting-changes-stable-release-branches
   :END:

- If you're cherry-picking a commit to a stable release branch, always
  use =git cherry-pick -xe= and ensure the message contains a clear
  description about why this needs to be included in the stable branch.

  An example of a cherry-picked commit would look like this:

  #+BEGIN_EXAMPLE
    nixos: Refactor the world.

    The original commit message describing the reason why the world was torn apart.

    (cherry picked from commit abcdef)
    Reason: I just had a gut feeling that this would also be wanted by people from
    the stone age.
  #+END_EXAMPLE


