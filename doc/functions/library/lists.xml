<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="sec-functions-library-lists">
  <!-- Do not edit this file manually!

This file was generated using nixdoc[1]. Please edit the source Nix
file from which this XML was generated instead.

If you need to manually override the documentation of a single
function in this file, create a new override file at
`nixpkgs/docs/functions/library/overrides/<function-identifier>.xml`.

[1]: https://github.com/tazjin/nixdoc
-->
  <title>List manipulation functions</title>
  <section xml:id="function-library-lib.lists.singleton">
    <title>
      <function>lib.lists.singleton</function>
    </title>
    <xi:include href="./overrides/lib.lists.singleton.xml">
      <xi:fallback>
        <subtitle>
          <literal>singleton :: a -> [a]</literal>
        </subtitle>
        <para>Create a list consisting of a single element.  `singleton x` is
sometimes more convenient with respect to indentation than `[x]`
when x spans multiple lines.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>x</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.singleton</function> usage example</title>
          <programlisting><![CDATA[
singleton "foo"
=> [ "foo" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.singleton" />
  </section>
  <section xml:id="function-library-lib.lists.foldr">
    <title>
      <function>lib.lists.foldr</function>
    </title>
    <xi:include href="./overrides/lib.lists.foldr.xml">
      <xi:fallback>
        <subtitle>
          <literal>foldr :: (a -> b -> b) -> b -> [a] -> b</literal>
        </subtitle>
        <para>“right fold” a binary function `op` between successive elements of
`list` with `nul' as the starting value, i.e.,
`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>op</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>nul</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.foldr</function> usage example</title>
          <programlisting><![CDATA[
concat = foldr (a: b: a + b) "z"
concat [ "a" "b" "c" ]
=> "abcz"
# different types
strange = foldr (int: str: toString (int + 1) + str) "a"
strange [ 1 2 3 4 ]
=> "2345a"
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.foldr" />
  </section>
  <section xml:id="function-library-lib.lists.fold">
    <title>
      <function>lib.lists.fold</function>
    </title>
    <xi:include href="./overrides/lib.lists.fold.xml">
      <xi:fallback>
        <para>`fold` is an alias of `foldr` for historic reasons</para>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.fold" />
  </section>
  <section xml:id="function-library-lib.lists.foldl">
    <title>
      <function>lib.lists.foldl</function>
    </title>
    <xi:include href="./overrides/lib.lists.foldl.xml">
      <xi:fallback>
        <subtitle>
          <literal>foldl :: (b -> a -> b) -> b -> [a] -> b</literal>
        </subtitle>
        <para>“left fold”, like `foldr`, but from the left:
`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>op</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>nul</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.foldl</function> usage example</title>
          <programlisting><![CDATA[
lconcat = foldl (a: b: a + b) "z"
lconcat [ "a" "b" "c" ]
=> "zabc"
# different types
lstrange = foldl (str: int: str + toString (int + 1)) ""
strange [ 1 2 3 4 ]
=> "a2345"
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.foldl" />
  </section>
  <section xml:id="function-library-lib.lists.foldl-prime">
    <title>
      <function>lib.lists.foldl'</function>
    </title>
    <xi:include href="./overrides/lib.lists.foldl-prime.xml">
      <xi:fallback>
        <subtitle>
          <literal>foldl' :: (b -> a -> b) -> b -> [a] -> b</literal>
        </subtitle>
        <para>Strict version of `foldl`.</para>
        <para>The difference is that evaluation is forced upon access. Usually used
with small whole results (in contract with lazily-generated list or large
lists where only a part is consumed.)</para>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.foldl-prime" />
  </section>
  <section xml:id="function-library-lib.lists.imap0">
    <title>
      <function>lib.lists.imap0</function>
    </title>
    <xi:include href="./overrides/lib.lists.imap0.xml">
      <xi:fallback>
        <subtitle>
          <literal>imap0 :: (int -> a -> b) -> [a] -> [b]</literal>
        </subtitle>
        <para>Map with index starting from 0</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>f</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.imap0</function> usage example</title>
          <programlisting><![CDATA[
imap0 (i: v: "${v}-${toString i}") ["a" "b"]
=> [ "a-0" "b-1" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.imap0" />
  </section>
  <section xml:id="function-library-lib.lists.imap1">
    <title>
      <function>lib.lists.imap1</function>
    </title>
    <xi:include href="./overrides/lib.lists.imap1.xml">
      <xi:fallback>
        <subtitle>
          <literal>imap1 :: (int -> a -> b) -> [a] -> [b]</literal>
        </subtitle>
        <para>Map with index starting from 1</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>f</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.imap1</function> usage example</title>
          <programlisting><![CDATA[
imap1 (i: v: "${v}-${toString i}") ["a" "b"]
=> [ "a-1" "b-2" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.imap1" />
  </section>
  <section xml:id="function-library-lib.lists.concatMap">
    <title>
      <function>lib.lists.concatMap</function>
    </title>
    <xi:include href="./overrides/lib.lists.concatMap.xml">
      <xi:fallback>
        <subtitle>
          <literal>concatMap :: (a -> [b]) -> [a] -> [b]</literal>
        </subtitle>
        <para>Map and concatenate the result.</para>
        <example>
          <title>
            <function>lib.lists.concatMap</function> usage example</title>
          <programlisting><![CDATA[
concatMap (x: [x] ++ ["z"]) ["a" "b"]
=> [ "a" "z" "b" "z" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.concatMap" />
  </section>
  <section xml:id="function-library-lib.lists.flatten">
    <title>
      <function>lib.lists.flatten</function>
    </title>
    <xi:include href="./overrides/lib.lists.flatten.xml">
      <xi:fallback>
        <para>Flatten the argument into a single list; that is, nested lists are
spliced into the top-level lists.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>x</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.flatten</function> usage example</title>
          <programlisting><![CDATA[
flatten [1 [2 [3] 4] 5]
=> [1 2 3 4 5]
flatten 1
=> [1]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.flatten" />
  </section>
  <section xml:id="function-library-lib.lists.remove">
    <title>
      <function>lib.lists.remove</function>
    </title>
    <xi:include href="./overrides/lib.lists.remove.xml">
      <xi:fallback>
        <subtitle>
          <literal>remove :: a -> [a] -> [a]</literal>
        </subtitle>
        <para>Remove elements equal to 'e' from a list.  Useful for buildInputs.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>e</varname>
            </term>
            <listitem>
              <para>Element to remove from the list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.remove</function> usage example</title>
          <programlisting><![CDATA[
remove 3 [ 1 3 4 3 ]
=> [ 1 4 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.remove" />
  </section>
  <section xml:id="function-library-lib.lists.findSingle">
    <title>
      <function>lib.lists.findSingle</function>
    </title>
    <xi:include href="./overrides/lib.lists.findSingle.xml">
      <xi:fallback>
        <subtitle>
          <literal>findSingle :: (a -> bool) -> a -> a -> [a] -> a</literal>
        </subtitle>
        <para>Find the sole element in the list matching the specified
predicate, returns `default` if no such element exists, or
`multiple` if there are multiple matching elements.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>pred</varname>
            </term>
            <listitem>
              <para>Predicate</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>default</varname>
            </term>
            <listitem>
              <para>Default value to return if element was not found.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>multiple</varname>
            </term>
            <listitem>
              <para>Default value to return if more than one element was found</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Input list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.findSingle</function> usage example</title>
          <programlisting><![CDATA[
findSingle (x: x == 3) "none" "multiple" [ 1 3 3 ]
=> "multiple"
findSingle (x: x == 3) "none" "multiple" [ 1 3 ]
=> 3
findSingle (x: x == 3) "none" "multiple" [ 1 9 ]
=> "none"
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.findSingle" />
  </section>
  <section xml:id="function-library-lib.lists.findFirst">
    <title>
      <function>lib.lists.findFirst</function>
    </title>
    <xi:include href="./overrides/lib.lists.findFirst.xml">
      <xi:fallback>
        <subtitle>
          <literal>findFirst :: (a -> bool) -> a -> [a] -> a</literal>
        </subtitle>
        <para>Find the first element in the list matching the specified
predicate or return `default` if no such element exists.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>pred</varname>
            </term>
            <listitem>
              <para>Predicate</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>default</varname>
            </term>
            <listitem>
              <para>Default value to return</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Input list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.findFirst</function> usage example</title>
          <programlisting><![CDATA[
findFirst (x: x > 3) 7 [ 1 6 4 ]
=> 6
findFirst (x: x > 9) 7 [ 1 6 4 ]
=> 7
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.findFirst" />
  </section>
  <section xml:id="function-library-lib.lists.any">
    <title>
      <function>lib.lists.any</function>
    </title>
    <xi:include href="./overrides/lib.lists.any.xml">
      <xi:fallback>
        <subtitle>
          <literal>any :: (a -> bool) -> [a] -> bool</literal>
        </subtitle>
        <para>Return true if function `pred` returns true for at least one
element of `list`.</para>
        <example>
          <title>
            <function>lib.lists.any</function> usage example</title>
          <programlisting><![CDATA[
any isString [ 1 "a" { } ]
=> true
any isString [ 1 { } ]
=> false
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.any" />
  </section>
  <section xml:id="function-library-lib.lists.all">
    <title>
      <function>lib.lists.all</function>
    </title>
    <xi:include href="./overrides/lib.lists.all.xml">
      <xi:fallback>
        <subtitle>
          <literal>all :: (a -> bool) -> [a] -> bool</literal>
        </subtitle>
        <para>Return true if function `pred` returns true for all elements of
`list`.</para>
        <example>
          <title>
            <function>lib.lists.all</function> usage example</title>
          <programlisting><![CDATA[
all (x: x < 3) [ 1 2 ]
=> true
all (x: x < 3) [ 1 2 3 ]
=> false
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.all" />
  </section>
  <section xml:id="function-library-lib.lists.count">
    <title>
      <function>lib.lists.count</function>
    </title>
    <xi:include href="./overrides/lib.lists.count.xml">
      <xi:fallback>
        <subtitle>
          <literal>count :: (a -> bool) -> [a] -> int</literal>
        </subtitle>
        <para>Count how many elements of `list` match the supplied predicate
function.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>pred</varname>
            </term>
            <listitem>
              <para>Predicate</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.count</function> usage example</title>
          <programlisting><![CDATA[
count (x: x == 3) [ 3 2 3 4 6 ]
=> 2
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.count" />
  </section>
  <section xml:id="function-library-lib.lists.optional">
    <title>
      <function>lib.lists.optional</function>
    </title>
    <xi:include href="./overrides/lib.lists.optional.xml">
      <xi:fallback>
        <subtitle>
          <literal>optional :: bool -> a -> [a]</literal>
        </subtitle>
        <para>Return a singleton list or an empty list, depending on a boolean
value.  Useful when building lists with optional elements
(e.g. `++ optional (system == "i686-linux") flashplayer').</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>cond</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>elem</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.optional</function> usage example</title>
          <programlisting><![CDATA[
optional true "foo"
=> [ "foo" ]
optional false "foo"
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.optional" />
  </section>
  <section xml:id="function-library-lib.lists.optionals">
    <title>
      <function>lib.lists.optionals</function>
    </title>
    <xi:include href="./overrides/lib.lists.optionals.xml">
      <xi:fallback>
        <subtitle>
          <literal>optionals :: bool -> [a] -> [a]</literal>
        </subtitle>
        <para>Return a list or an empty list, depending on a boolean value.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>cond</varname>
            </term>
            <listitem>
              <para>Condition</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>elems</varname>
            </term>
            <listitem>
              <para>List to return if condition is true</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.optionals</function> usage example</title>
          <programlisting><![CDATA[
optionals true [ 2 3 ]
=> [ 2 3 ]
optionals false [ 2 3 ]
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.optionals" />
  </section>
  <section xml:id="function-library-lib.lists.toList">
    <title>
      <function>lib.lists.toList</function>
    </title>
    <xi:include href="./overrides/lib.lists.toList.xml">
      <xi:fallback>
        <para>If argument is a list, return it; else, wrap it in a singleton
list.  If you're using this, you should almost certainly
reconsider if there isn't a more "well-typed" approach.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>x</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.toList</function> usage example</title>
          <programlisting><![CDATA[
toList [ 1 2 ]
=> [ 1 2 ]
toList "hi"
=> [ "hi "]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.toList" />
  </section>
  <section xml:id="function-library-lib.lists.range">
    <title>
      <function>lib.lists.range</function>
    </title>
    <xi:include href="./overrides/lib.lists.range.xml">
      <xi:fallback>
        <subtitle>
          <literal>range :: int -> int -> [int]</literal>
        </subtitle>
        <para>Return a list of integers from `first' up to and including `last'.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>first</varname>
            </term>
            <listitem>
              <para>First integer in the range</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>last</varname>
            </term>
            <listitem>
              <para>Last integer in the range</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.range</function> usage example</title>
          <programlisting><![CDATA[
range 2 4
=> [ 2 3 4 ]
range 3 2
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.range" />
  </section>
  <section xml:id="function-library-lib.lists.partition">
    <title>
      <function>lib.lists.partition</function>
    </title>
    <xi:include href="./overrides/lib.lists.partition.xml">
      <xi:fallback>
        <subtitle>
          <literal>(a -> bool) -> [a] -> { right :: [a], wrong :: [a] }</literal>
        </subtitle>
        <para>Splits the elements of a list in two lists, `right` and
`wrong`, depending on the evaluation of a predicate.</para>
        <example>
          <title>
            <function>lib.lists.partition</function> usage example</title>
          <programlisting><![CDATA[
partition (x: x > 2) [ 5 1 2 3 4 ]
=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.partition" />
  </section>
  <section xml:id="function-library-lib.lists.groupBy-prime">
    <title>
      <function>lib.lists.groupBy'</function>
    </title>
    <xi:include href="./overrides/lib.lists.groupBy-prime.xml">
      <xi:fallback>
        <para>Splits the elements of a list into many lists, using the return value of a predicate.
Predicate should return a string which becomes keys of attrset `groupBy' returns.</para>
        <para>`groupBy'` allows to customise the combining function and initial value</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>op</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>nul</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>pred</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>lst</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.groupBy'</function> usage example</title>
          <programlisting><![CDATA[
groupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]
=> { true = [ 5 3 4 ]; false = [ 1 2 ]; }
groupBy (x: x.name) [ {name = "icewm"; script = "icewm &";}
{name = "xfce";  script = "xfce4-session &";}
{name = "icewm"; script = "icewmbg &";}
{name = "mate";  script = "gnome-session &";}
]
=> { icewm = [ { name = "icewm"; script = "icewm &"; }
{ name = "icewm"; script = "icewmbg &"; } ];
mate  = [ { name = "mate";  script = "gnome-session &"; } ];
xfce  = [ { name = "xfce";  script = "xfce4-session &"; } ];
}

groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]
=> { true = 12; false = 3; }
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.groupBy-prime" />
  </section>
  <section xml:id="function-library-lib.lists.zipListsWith">
    <title>
      <function>lib.lists.zipListsWith</function>
    </title>
    <xi:include href="./overrides/lib.lists.zipListsWith.xml">
      <xi:fallback>
        <subtitle>
          <literal>zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]</literal>
        </subtitle>
        <para>Merges two lists of the same size together. If the sizes aren't the same
the merging stops at the shortest. How both lists are merged is defined
by the first argument.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>f</varname>
            </term>
            <listitem>
              <para>Function to zip elements of both lists</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>fst</varname>
            </term>
            <listitem>
              <para>First list</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>snd</varname>
            </term>
            <listitem>
              <para>Second list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.zipListsWith</function> usage example</title>
          <programlisting><![CDATA[
zipListsWith (a: b: a + b) ["h" "l"] ["e" "o"]
=> ["he" "lo"]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.zipListsWith" />
  </section>
  <section xml:id="function-library-lib.lists.zipLists">
    <title>
      <function>lib.lists.zipLists</function>
    </title>
    <xi:include href="./overrides/lib.lists.zipLists.xml">
      <xi:fallback>
        <subtitle>
          <literal>zipLists :: [a] -> [b] -> [{ fst :: a, snd :: b}]</literal>
        </subtitle>
        <para>Merges two lists of the same size together. If the sizes aren't the same
the merging stops at the shortest.</para>
        <example>
          <title>
            <function>lib.lists.zipLists</function> usage example</title>
          <programlisting><![CDATA[
zipLists [ 1 2 ] [ "a" "b" ]
=> [ { fst = 1; snd = "a"; } { fst = 2; snd = "b"; } ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.zipLists" />
  </section>
  <section xml:id="function-library-lib.lists.reverseList">
    <title>
      <function>lib.lists.reverseList</function>
    </title>
    <xi:include href="./overrides/lib.lists.reverseList.xml">
      <xi:fallback>
        <subtitle>
          <literal>reverseList :: [a] -> [a]</literal>
        </subtitle>
        <para>Reverse the order of the elements of a list.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>xs</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.reverseList</function> usage example</title>
          <programlisting><![CDATA[

reverseList [ "b" "o" "j" ]
=> [ "j" "o" "b" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.reverseList" />
  </section>
  <section xml:id="function-library-lib.lists.listDfs">
    <title>
      <function>lib.lists.listDfs</function>
    </title>
    <xi:include href="./overrides/lib.lists.listDfs.xml">
      <xi:fallback>
        <para>Depth-First Search (DFS) for lists `list != []`.</para>
        <para>`before a b == true` means that `b` depends on `a` (there's an
edge from `b` to `a`).</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>stopOnCycles</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>before</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.listDfs</function> usage example</title>
          <programlisting><![CDATA[
listDfs true hasPrefix [ "/home/user" "other" "/" "/home" ]
== { minimal = "/";                  # minimal element
visited = [ "/home/user" ];     # seen elements (in reverse order)
rest    = [ "/home" "other" ];  # everything else
}

listDfs true hasPrefix [ "/home/user" "other" "/" "/home" "/" ]
== { cycle   = "/";                  # cycle encountered at this element
loops   = [ "/" ];              # and continues to these elements
visited = [ "/" "/home/user" ]; # elements leading to the cycle (in reverse order)
rest    = [ "/home" "other" ];  # everything else
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.listDfs" />
  </section>
  <section xml:id="function-library-lib.lists.toposort">
    <title>
      <function>lib.lists.toposort</function>
    </title>
    <xi:include href="./overrides/lib.lists.toposort.xml">
      <xi:fallback>
        <para>Sort a list based on a partial ordering using DFS. This
implementation is O(N^2), if your ordering is linear, use `sort`
instead.</para>
        <para>`before a b == true` means that `b` should be after `a`
in the result.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>before</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.toposort</function> usage example</title>
          <programlisting><![CDATA[

toposort hasPrefix [ "/home/user" "other" "/" "/home" ]
== { result = [ "/" "/home" "/home/user" "other" ]; }

toposort hasPrefix [ "/home/user" "other" "/" "/home" "/" ]
== { cycle = [ "/home/user" "/" "/" ]; # path leading to a cycle
loops = [ "/" ]; }                # loops back to these elements

toposort hasPrefix [ "other" "/home/user" "/home" "/" ]
== { result = [ "other" "/" "/home" "/home/user" ]; }

toposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; }
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.toposort" />
  </section>
  <section xml:id="function-library-lib.lists.sort">
    <title>
      <function>lib.lists.sort</function>
    </title>
    <xi:include href="./overrides/lib.lists.sort.xml">
      <xi:fallback>
        <para>Sort a list based on a comparator function which compares two
elements and returns true if the first argument is strictly below
the second argument.  The returned list is sorted in an increasing
order.  The implementation does a quick-sort.</para>
        <example>
          <title>
            <function>lib.lists.sort</function> usage example</title>
          <programlisting><![CDATA[
sort (a: b: a < b) [ 5 3 7 ]
=> [ 3 5 7 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.sort" />
  </section>
  <section xml:id="function-library-lib.lists.compareLists">
    <title>
      <function>lib.lists.compareLists</function>
    </title>
    <xi:include href="./overrides/lib.lists.compareLists.xml">
      <xi:fallback>
        <para>Compare two lists element-by-element.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>cmp</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>a</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>b</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.compareLists</function> usage example</title>
          <programlisting><![CDATA[
compareLists compare [] []
=> 0
compareLists compare [] [ "a" ]
=> -1
compareLists compare [ "a" ] []
=> 1
compareLists compare [ "a" "b" ] [ "a" "c" ]
=> 1
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.compareLists" />
  </section>
  <section xml:id="function-library-lib.lists.naturalSort">
    <title>
      <function>lib.lists.naturalSort</function>
    </title>
    <xi:include href="./overrides/lib.lists.naturalSort.xml">
      <xi:fallback>
        <para>Sort list using "Natural sorting".
Numeric portions of strings are sorted in numeric order.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>lst</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.naturalSort</function> usage example</title>
          <programlisting><![CDATA[
naturalSort ["disk11" "disk8" "disk100" "disk9"]
=> ["disk8" "disk9" "disk11" "disk100"]
naturalSort ["10.46.133.149" "10.5.16.62" "10.54.16.25"]
=> ["10.5.16.62" "10.46.133.149" "10.54.16.25"]
naturalSort ["v0.2" "v0.15" "v0.0.9"]
=> [ "v0.0.9" "v0.2" "v0.15" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.naturalSort" />
  </section>
  <section xml:id="function-library-lib.lists.take">
    <title>
      <function>lib.lists.take</function>
    </title>
    <xi:include href="./overrides/lib.lists.take.xml">
      <xi:fallback>
        <subtitle>
          <literal>take :: int -> [a] -> [a]</literal>
        </subtitle>
        <para>Return the first (at most) N elements of a list.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>count</varname>
            </term>
            <listitem>
              <para>Number of elements to take</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.take</function> usage example</title>
          <programlisting><![CDATA[
take 2 [ "a" "b" "c" "d" ]
=> [ "a" "b" ]
take 2 [ ]
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.take" />
  </section>
  <section xml:id="function-library-lib.lists.drop">
    <title>
      <function>lib.lists.drop</function>
    </title>
    <xi:include href="./overrides/lib.lists.drop.xml">
      <xi:fallback>
        <subtitle>
          <literal>drop :: int -> [a] -> [a]</literal>
        </subtitle>
        <para>Remove the first (at most) N elements of a list.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>count</varname>
            </term>
            <listitem>
              <para>Number of elements to drop</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Input list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.drop</function> usage example</title>
          <programlisting><![CDATA[
drop 2 [ "a" "b" "c" "d" ]
=> [ "c" "d" ]
drop 2 [ ]
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.drop" />
  </section>
  <section xml:id="function-library-lib.lists.sublist">
    <title>
      <function>lib.lists.sublist</function>
    </title>
    <xi:include href="./overrides/lib.lists.sublist.xml">
      <xi:fallback>
        <subtitle>
          <literal>sublist :: int -> int -> [a] -> [a]</literal>
        </subtitle>
        <para>Return a list consisting of at most `count` elements of `list`,
starting at index `start`.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>start</varname>
            </term>
            <listitem>
              <para>Index at which to start the sublist</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>count</varname>
            </term>
            <listitem>
              <para>Number of elements to take</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Input list</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.sublist</function> usage example</title>
          <programlisting><![CDATA[
sublist 1 3 [ "a" "b" "c" "d" "e" ]
=> [ "b" "c" "d" ]
sublist 1 3 [ ]
=> [ ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.sublist" />
  </section>
  <section xml:id="function-library-lib.lists.last">
    <title>
      <function>lib.lists.last</function>
    </title>
    <xi:include href="./overrides/lib.lists.last.xml">
      <xi:fallback>
        <subtitle>
          <literal>last :: [a] -> a</literal>
        </subtitle>
        <para>Return the last element of a list.</para>
        <para>This function throws an error if the list is empty.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.last</function> usage example</title>
          <programlisting><![CDATA[
last [ 1 2 3 ]
=> 3
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.last" />
  </section>
  <section xml:id="function-library-lib.lists.init">
    <title>
      <function>lib.lists.init</function>
    </title>
    <xi:include href="./overrides/lib.lists.init.xml">
      <xi:fallback>
        <subtitle>
          <literal>init :: [a] -> [a]</literal>
        </subtitle>
        <para>Return all elements but the last.</para>
        <para>This function throws an error if the list is empty.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.init</function> usage example</title>
          <programlisting><![CDATA[
init [ 1 2 3 ]
=> [ 1 2 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.init" />
  </section>
  <section xml:id="function-library-lib.lists.crossLists">
    <title>
      <function>lib.lists.crossLists</function>
    </title>
    <xi:include href="./overrides/lib.lists.crossLists.xml">
      <xi:fallback>
        <para>Return the image of the cross product of some lists by a function.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>f</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.crossLists</function> usage example</title>
          <programlisting><![CDATA[
crossLists (x:y: "${toString x}${toString y}") [[1 2] [3 4]]
=> [ "13" "14" "23" "24" ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.crossLists" />
  </section>
  <section xml:id="function-library-lib.lists.unique">
    <title>
      <function>lib.lists.unique</function>
    </title>
    <xi:include href="./overrides/lib.lists.unique.xml">
      <xi:fallback>
        <subtitle>
          <literal>unique :: [a] -> [a]</literal>
        </subtitle>
        <para>Remove duplicate elements from the list. O(n^2) complexity.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>list</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.unique</function> usage example</title>
          <programlisting><![CDATA[
unique [ 3 2 3 4 ]
=> [ 3 2 4 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.unique" />
  </section>
  <section xml:id="function-library-lib.lists.intersectLists">
    <title>
      <function>lib.lists.intersectLists</function>
    </title>
    <xi:include href="./overrides/lib.lists.intersectLists.xml">
      <xi:fallback>
        <para>Intersects list 'e' and another list. O(nm) complexity.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>e</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.intersectLists</function> usage example</title>
          <programlisting><![CDATA[
intersectLists [ 1 2 3 ] [ 6 3 2 ]
=> [ 3 2 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.intersectLists" />
  </section>
  <section xml:id="function-library-lib.lists.subtractLists">
    <title>
      <function>lib.lists.subtractLists</function>
    </title>
    <xi:include href="./overrides/lib.lists.subtractLists.xml">
      <xi:fallback>
        <para>Subtracts list 'e' from another list. O(nm) complexity.</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>e</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <example>
          <title>
            <function>lib.lists.subtractLists</function> usage example</title>
          <programlisting><![CDATA[
subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]
=> [ 1 4 5 ]
]]></programlisting>
        </example>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.subtractLists" />
  </section>
  <section xml:id="function-library-lib.lists.mutuallyExclusive">
    <title>
      <function>lib.lists.mutuallyExclusive</function>
    </title>
    <xi:include href="./overrides/lib.lists.mutuallyExclusive.xml">
      <xi:fallback>
        <para>Test if two lists have no common element.
It should be slightly more efficient than (intersectLists a b == [])</para>
        <variablelist>
          <varlistentry>
            <term>
              <varname>a</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <varname>b</varname>
            </term>
            <listitem>
              <para>Function argument</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </xi:fallback>
    </xi:include>
    <xi:include href="./locations.xml" xpointer="lib.lists.mutuallyExclusive" />
  </section>
</section>