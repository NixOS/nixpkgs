<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-overlays">

<title>Overlays</title>

<para>This chapter describes how to extend and change Nixpkgs packages using
overlays. Overlays are used to add layers in the fix-point used by Nixpkgs
to compose the set of all packages.</para>

<!--============================================================-->

<section xml:id="sec-overlays-install">
<title>Installing Overlays</title>

<para>The set of overlays is looked for in the following places. The
first one present is considered, and all the rest are ignored:

<orderedlist>

  <listitem>

    <para>As an argument of the imported attribute set. When importing Nixpkgs,
    the <varname>overlays</varname> attribute argument can be set to a list of
    functions, which is described in <xref linkend="sec-overlays-layout"/>.</para>

  </listitem>

  <listitem>

    <para>In the directory pointed to by the Nix search path entry
    <literal>&lt;nixpkgs-overlays></literal>.</para>
  </listitem>

  <listitem>

    <para>In the directory <filename>~/.config/nixpkgs/overlays/</filename>.</para>
  </listitem>

</orderedlist>
</para>

<para>For the second and third options, the directory should contain Nix expressions defining the
overlays. Each overlay can be a file, a directory containing a
<filename>default.nix</filename>, or a symlink to one of those. The expressions should follow
the syntax described in <xref linkend="sec-overlays-layout"/>.</para>

<para>The order of the overlay layers can influence the recipe of packages if multiple layers override
the same recipe. In the case where overlays are loaded from a directory, they are loaded in
alphabetical order.</para>

<para>To install an overlay using the last option, you can clone the overlay's repository and add
a symbolic link to it in <filename>~/.config/nixpkgs/overlays/</filename> directory.</para>

</section>

<!--============================================================-->

<section xml:id="sec-overlays-layout">
<title>Overlays Layout</title>

<para>Overlays are expressed as Nix functions which accept 2 arguments and return a set of
packages.</para>

<programlisting>
pkgsself: pkgssuper:

{
  boost = pkgssuper.boost.override {
    python = pkgsself.python3;
  };
  rr = pkgssuper.callPackage ./pkgs/rr {
    stdenv = pkgsself.stdenv_32bit;
  };
}
</programlisting>

<para>The first argument, usually named <varname>pkgsself</varname>, corresponds to the final package
set. You should use this set for the dependencies of all packages specified in your
overlay. For example, all the dependencies of <varname>rr</varname> in the example above come
from <varname>pkgsself</varname>, as well as the overriden dependencies used in the
<varname>boost</varname> override.</para>

<para>The second argument, usually named <varname>pkgssuper</varname>,
corresponds to the result of the evaluation of the previous stages of
Nixpkgs. It does not contain any of the packages added by the current
overlay nor any of the following overlays. This set should be used either
to refer to packages you wish to override, or to access functions defined
in Nixpkgs. For example, the original recipe of <varname>boost</varname>
in the above example, comes from <varname>pkgssuper</varname>, as well as the
<varname>callPackage</varname> function.</para>

<para>The value returned by this function should be a set similar to
<filename>pkgs/top-level/all-packages.nix</filename>, which contains
overridden and/or new packages.</para>

</section>

<section xml:id="sec-overlays-extend-modify">
<title>Overlays used to extend or modify pkgs</title>

<para>
If you want to extend nixpkgs with your own packages: add new packages, alter existing ones then you can use this code <filename>nixcloud-pkgs.nix</filename>:
</para>

<programlisting>
{  pkgs ? import &lt;nixpkgs> {}
,  nixcloud-backend   ? pkgs.stdenv.lib.cleanSource ../nixcloud-backend
,  nixcloud-frontend  ? pkgs.stdenv.lib.cleanSource ../nixcloud-frontend
,  nixcloud-editor    ? pkgs.stdenv.lib.cleanSource ../nixcloud-editor
, ...
}:
let
  nc-backend = nixcloud-backend;
  nc-frontend = nixcloud-frontend;
  
  newpkgs = import pkgs.path { overlays = [ (pkgsself: pkgssuper: {
    nixcloud-backend  = pkgs.callPackage nc-backend { inherit newpkgs; };
    nixcloud-frontend = pkgs.callPackage "${nc-frontend}/release.nix" {
      inherit nixcloud-editor;
    };
  } ) ]; };
in newpkgs
</programlisting>

<para>
If you want to install a package from this new set, do this:

<programlisting>
nix-build nixcloud-pkgs.nix -A nixcloud-backend
</programlisting>

If you create additional services, with the nixos module system, then you can reference your new set of modules like this:

<programlisting>
{...}:
let
  ncpkgs = import ./nixcloud-pkgs.nix {};
in
  backend = ncpkgs.nixcloud-backend;
</programlisting>

Yet more interesting, you can use <varname>override</varname> to alter the attribute like this:

<programlisting>
{...}:
let
  ncpkgs = import ./nixcloud-pkgs.nix {};
in
  backend = ncpkgs.nixcloud-frontend.override (oldAttrs: rec {
    API_HOST="wss://....";
  })
</programlisting>


Note: There used to be a <varname>pkgs.overridePackages</varname> function in <varname>nixpkgs</varname> but it was removed and replaced by the overlays concept described above.

</para>


</section>

</chapter>
