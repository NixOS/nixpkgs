#!/usr/bin/env nix-shell
#! nix-shell -i bash -p curl jq nix coreutils
set -euo pipefail

# This script piggybacks on the code generated by
# the nix-community emacs overlay
# You can use this to avoid running lengthy code generation jobs locally

# Classic "where I am" block
# https://www.binaryphile.com/bash/2020/01/12/determining-the-location-of-your-script-in-bash.html
SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE[0]}); cd -P $(dirname $(readlink ${BASH_SOURCE[0]} || echo .)); pwd)

# Since Bash is meager on data structures, let's use a JSON file and jq!
# The format is straightforward:
# archive_name : { location, basename, nix_attribute }

JSON_ARCHIVE_TABLE="${SCRIPT_DIR}/elisp-archives-table.json"

OVERLAY_URL_HEAD="https://raw.githubusercontent.com/nix-community/emacs-overlay"
DEFAULT_COMMIT_ID="master"

function download_package_set {
    if [[ "$#" == "0" ]]; then
        echo "${FUNCNAME[0]}: you must pass one or two arguments."
        return 1
    elif [[ "$#" == "1" ]]; then
        # second argument does not exist; use default commit id
        ARCHIVE_NAME="$1"
        COMMIT_ID="${DEFAULT_COMMIT_ID}"
    else
        ARCHIVE_NAME="$1"
        COMMIT_ID="$2"
    fi

    if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
        echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
        return 1
    fi

    LOCATION=$(jq --raw-output ".\"${ARCHIVE_NAME}\".location" "${JSON_ARCHIVE_TABLE}")
    BASENAME=$(jq --raw-output ".\"${ARCHIVE_NAME}\".basename" "${JSON_ARCHIVE_TABLE}")
    URL="${OVERLAY_URL_HEAD}/${COMMIT_ID}/${LOCATION}/${BASENAME}"

    pushd "${SCRIPT_DIR}" > /dev/null
    echo "${FUNCNAME[0]}: ${ARCHIVE_NAME}..."
    curl --silent --remote-name "${URL}"
    echo "${FUNCNAME[0]}: ${ARCHIVE_NAME}: done!"
    popd > /dev/null
}

function test_package_sets {
    # Silent early-return when no argument is passed
    if [[ "$#" == "0" ]]; then
        return 0
    fi

    declare -a ARCHIVE_LIST

    # collect the command line arguments, bailing out when any of them is not recognized
    while (( "$#" )); do
        ARCHIVE_NAME="$1"
        if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
            echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
            return 1
        else
            ARCHIVE_LIST+=( "${ARCHIVE_NAME}" )
        fi
        shift
    done

    pushd "${SCRIPT_DIR}" > /dev/null
    for ARCHIVE_NAME in "${ARCHIVE_LIST[@]}"; do
        ATTRIBUTE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".nix_attribute" "${JSON_ARCHIVE_TABLE}")
        echo "${FUNCNAME[0]}: ${ATTRIBUTE}..."
        NIXPKGS_ALLOW_BROKEN=1 nix-instantiate --show-trace ../../../../../ -A "${ATTRIBUTE}"
        echo "${FUNCNAME[0]}: ${ATTRIBUTE}: done!"
    done
    popd > /dev/null
}

function commit_package_set {
    if [[ "$#" == "0" ]]; then
        echo "${FUNCNAME[0]}: you must pass one or two arguments."
        return 1
    elif [[ "$#" == "1" ]]; then
        # second argument does not exist; use default commit id
        ARCHIVE_NAME="$1"
        COMMIT_ID="${DEFAULT_COMMIT_ID}"
    else
        ARCHIVE_NAME="$1"
        COMMIT_ID="$2"
    fi

    if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
        echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
        return 1
    fi

    ATTRIBUTE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".nix_attribute" "${JSON_ARCHIVE_TABLE}")
    FILE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".basename" "${JSON_ARCHIVE_TABLE}")

    pushd "${SCRIPT_DIR}" > /dev/null
    if [[ "$(git diff --exit-code "${FILE}" > /dev/null)" == "0" ]]; then
        echo "${FUNCNAME[0]}: ${FILE}..."
        git commit -m "${ATTRIBUTE}: updated at $(date --iso) (from emacs-overlay at ${COMMIT_ID})" -- "${FILE}"
        echo "${FUNCNAME[0]}: ${FILE}: done!"
    else
        echo "${FUNCNAME[0]}: ${FILE} was not modified; doing nothing"
    fi
    popd > /dev/null
}

# The loops are unrolled as follows because either all package_sets should be
# updated, or none of them should. Therefore, if any of them fails, all the
# process should be aborted as soon as possible.

download_package_set "elpa"
download_package_set "elpa-devel"
download_package_set "melpa"
download_package_set "nongnu"
download_package_set "nongnu-devel"

test_package_sets "elpa" "elpa-devel" "melpa" "melpa-stable" "nongnu" "nongnu-devel"

commit_package_set "elpa"
commit_package_set "elpa-devel"
commit_package_set "melpa"
commit_package_set "nongnu"
commit_package_set "nongnu-devel"
