#!/usr/bin/env nix-shell
#! nix-shell -i bash -p curl jq nix coreutils
set -euo pipefail

# This script piggybacks on the code generated by
# the nix-community emacs overlay
# You can use this to avoid running lengthy code generation jobs locally

# Classic "where I am" block
# https://www.binaryphile.com/bash/2020/01/12/determining-the-location-of-your-script-in-bash.html
SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE[0]}); cd -P $(dirname $(readlink ${BASH_SOURCE[0]} || echo .)); pwd)

# Since Bash is meager on data structures, let's use a JSON file and jq!
# The format is straightforward:
# archive_name : { location, basename, nix_attribute }

JSON_ARCHIVE_TABLE="${SCRIPT_DIR}/elisp-archives-table.json"

OVERLAY_URL_HEAD="https://raw.githubusercontent.com/nix-community/emacs-overlay"
DEFAULT_COMMIT_ID="master"

function download_packagesets {
    # Silent early-return when no argument is passed
    if [[ "$#" == "0" ]]; then
        return 0
    fi

    declare -a ARCHIVE_LIST

    COMMIT_ID="${DEFAULT_COMMIT_ID}"

    # collect the command line arguments, bailing out when any of them is not recognized
    while (( "$#" )); do
        ARCHIVE_NAME="$1"
        if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
            echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
            return 1
        else
            ARCHIVE_LIST+=( "${ARCHIVE_NAME}" )
        fi
        shift
    done

    pushd "${SCRIPT_DIR}" > /dev/null
    for ARCHIVE_NAME in "${ARCHIVE_LIST[@]}"; do
        LOCATION=$(jq --raw-output ".\"${ARCHIVE_NAME}\".location" "${JSON_ARCHIVE_TABLE}")
        BASENAME=$(jq --raw-output ".\"${ARCHIVE_NAME}\".basename" "${JSON_ARCHIVE_TABLE}")
        URL="${OVERLAY_URL_HEAD}/${COMMIT_ID}/${LOCATION}/${BASENAME}"
        echo "${FUNCNAME[0]}: ${ARCHIVE_NAME}..."
        curl --silent --remote-name "${URL}"
        echo "${FUNCNAME[0]}: ${ARCHIVE_NAME}: done!"
    done
    popd > /dev/null
}

function test_packagesets {
    # Silent early-return when no argument is passed
    if [[ "$#" == "0" ]]; then
        return 0
    fi

    declare -a ARCHIVE_LIST

    # collect the command line arguments, bailing out when any of them is not recognized
    while (( "$#" )); do
        ARCHIVE_NAME="$1"
        if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
            echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
            return 1
        else
            ARCHIVE_LIST+=( "${ARCHIVE_NAME}" )
        fi
        shift
    done

    pushd "${SCRIPT_DIR}" > /dev/null
    for ARCHIVE_NAME in "${ARCHIVE_LIST[@]}"; do
        ATTRIBUTE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".nix_attribute" "${JSON_ARCHIVE_TABLE}")
        echo "${FUNCNAME[0]}: ${ATTRIBUTE}..."
        NIXPKGS_ALLOW_BROKEN=1 nix-instantiate --show-trace ../../../../../ -A "${ATTRIBUTE}"
        echo "${FUNCNAME[0]}: ${ATTRIBUTE}: done!"
    done
    popd > /dev/null
}

function commit_packagesets {
    # Silent early-return when no argument is passed
    if [[ "$#" == "0" ]]; then
        return 0
    fi

    declare -a ARCHIVE_LIST

    COMMIT_ID="${DEFAULT_COMMIT_ID}"

    while (( "$#" )); do
        ARCHIVE_NAME="$1"
        if [[ "$(jq "has(\"${ARCHIVE_NAME}\")" ${JSON_ARCHIVE_TABLE})" == "false" ]]; then
            echo "${FUNCNAME[0]}: unknown package archive: ${ARCHIVE_NAME}"
            return 1
        else
            ARCHIVE_LIST+=( "${ARCHIVE_NAME}" )
        fi
        shift
    done

    pushd "${SCRIPT_DIR}" > /dev/null
    for ARCHIVE_NAME in "${ARCHIVE_LIST[@]}"; do
        ATTRIBUTE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".nix_attribute" "${JSON_ARCHIVE_TABLE}")
        FILE=$(jq --raw-output ".\"${ARCHIVE_NAME}\".generated_file" "${JSON_ARCHIVE_TABLE}")
        if [[ "$(git diff --exit-code "${FILE}" > /dev/null)" == "0" ]]; then
            echo "${FUNCNAME[0]}: ${FILE}..."
            git commit -m "${ATTRIBUTE}: updated at $(date --iso) (from emacs-overlay at ${COMMIT_ID})" -- "${FILE}"
            echo "${FUNCNAME[0]}: ${FILE}: done!"
        else
            echo "${FUNCNAME[0]}: ${FILE} was not modified"
        fi
    done
    popd > /dev/null
}

# The loops are unrolled as follows because either all packagesets should be
# updated, or none of them should. Therefore, if any of them fails, all the
# process should be aborted as soon as possible.

download_packagesets "elpa" "elpa-devel" "melpa" "nongnu" "nongnu-devel"

test_packagesets "elpa" "elpa-devel" "melpa" "melpa-stable" "nongnu" "nongnu-devel"

commit_packagesets "elpa" "elpa-devel" "melpa" "nongnu" "nongnu-devel"
