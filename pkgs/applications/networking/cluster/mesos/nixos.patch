diff --git a/3rdparty/stout/include/stout/os/posix/fork.hpp b/3rdparty/stout/include/stout/os/posix/fork.hpp
index 83caaec..0f98053 100644
--- a/3rdparty/stout/include/stout/os/posix/fork.hpp
+++ b/3rdparty/stout/include/stout/os/posix/fork.hpp
@@ -365,7 +365,7 @@ private:
     if (exec.isSome()) {
       // Execute the command (via '/bin/sh -c command').
       const char* command = exec->command.c_str();
-      execlp("sh", "sh", "-c", command, (char*) nullptr);
+      execlp("@sh@", "sh", "-c", command, (char*) nullptr);
       EXIT(EXIT_FAILURE)
         << "Failed to execute '" << command << "': " << os::strerror(errno);
     } else if (wait.isSome()) {
diff --git a/3rdparty/stout/include/stout/posix/os.hpp b/3rdparty/stout/include/stout/posix/os.hpp
index b98d5ab..e8f1c19 100644
--- a/3rdparty/stout/include/stout/posix/os.hpp
+++ b/3rdparty/stout/include/stout/posix/os.hpp
@@ -364,7 +364,7 @@ inline Try<std::set<pid_t>> pids(Option<pid_t> group, Option<pid_t> session)
 inline Try<Nothing> tar(const std::string& path, const std::string& archive)
 {
   Try<std::string> tarOut =
-    os::shell("tar %s %s %s", "-czf", archive.c_str(), path.c_str());
+    os::shell("@tar@ %s %s %s", "-czf", archive.c_str(), path.c_str());
 
   if (tarOut.isError()) {
     return Error("Failed to archive " + path + ": " + tarOut.error());
diff --git a/src/Makefile.am b/src/Makefile.am
index 0b18f95..2941b8d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -2083,7 +2083,7 @@ if HAS_JAVA
 $(MESOS_JAR): $(MESOS_JAR_SOURCE) $(MESOS_JAR_GENERATED) java/mesos.pom
 	@echo "Building mesos-$(PACKAGE_VERSION).jar ..."
 	@cd $(abs_top_builddir)/src/java &&  \
-	  env JAVA_HOME=$(JAVA_HOME) $(MVN) -B -q -f mesos.pom clean package
+	  env JAVA_HOME=$(JAVA_HOME) $(MVN) -B -q -f mesos.pom -Dmaven.repo.local=@mavenRepo@ clean package
 
 # Convenience library for JNI bindings.
 # TODO(Charles Reiss): We really should be building the Java library
diff --git a/src/cli/mesos-scp b/src/cli/mesos-scp
index a71ab07..1043d1b 100755
--- a/src/cli/mesos-scp
+++ b/src/cli/mesos-scp
@@ -19,7 +19,8 @@ if sys.version_info < (2,6,0):
 
 
 def scp(host, src, dst):
-    cmd = 'scp -pr %s %s' % (src, host + ':' + dst)
+    cmd = '@scp@ -pr %s %s' % (src, host + ':' + dst)
+
     try:
         process = subprocess.Popen(
             cmd,
diff --git a/src/common/command_utils.cpp b/src/common/command_utils.cpp
index 7dfcc9f..7fc75e5 100644
--- a/src/common/command_utils.cpp
+++ b/src/common/command_utils.cpp
@@ -142,7 +142,7 @@ Future<Nothing> tar(
 
   argv.emplace_back(input);
 
-  return launch("tar", argv)
+  return launch("@tar@", argv)
     .then([]() { return Nothing(); });
 }
 
@@ -164,7 +164,7 @@ Future<Nothing> untar(
     argv.emplace_back(directory.get());
   }
 
-  return launch("tar", argv)
+  return launch("@tar@", argv)
     .then([]() { return Nothing(); });
 }
 
@@ -172,13 +172,13 @@ Future<Nothing> untar(
 Future<string> sha512(const Path& input)
 {
 #ifdef __linux__
-  const string cmd = "sha512sum";
+  const string cmd = "@sha512sum@";
   vector<string> argv = {
     cmd,
     input             // Input file to compute shasum.
   };
 #else
-  const string cmd = "shasum";
+  const string cmd = "@shasum@";
   vector<string> argv = {
     cmd,
     "-a", "512",      // Shasum type.
@@ -208,7 +208,7 @@ Future<Nothing> gzip(const Path& input)
     input
   };
 
-  return launch("gzip", argv)
+  return launch("@gzip@", argv)
     .then([]() { return Nothing(); });
 }
 
@@ -221,7 +221,7 @@ Future<Nothing> decompress(const Path& input)
     input
   };
 
-  return launch("gzip", argv)
+  return launch("@gzip@", argv)
     .then([]() { return Nothing(); });
 }
 
diff --git a/src/launcher/fetcher.cpp b/src/launcher/fetcher.cpp
index 9cb8196..11552d5 100644
--- a/src/launcher/fetcher.cpp
+++ b/src/launcher/fetcher.cpp
@@ -97,7 +97,7 @@ static Try<bool> extract(
     string filename = Path(pathWithoutExtension).basename();
     string destinationPath = path::join(destinationDirectory, filename);
 
-    command = {"gunzip", "-d", "-c"};
+    command = {"@gunzip@", "-d", "-c"};
     in = Subprocess::PATH(sourcePath);
     out = Subprocess::PATH(destinationPath);
   } else {
diff --git a/src/linux/perf.cpp b/src/linux/perf.cpp
index dfc4670..62de6e1 100644
--- a/src/linux/perf.cpp
+++ b/src/linux/perf.cpp
@@ -128,7 +128,7 @@ private:
     // NOTE: The supervisor childhook places perf in its own process group
     // and will kill the perf process when the parent dies.
     Try<Subprocess> _perf = subprocess(
-        "perf",
+        "@perf@",
         argv,
         Subprocess::PIPE(),
         Subprocess::PIPE(),
diff --git a/src/linux/systemd.cpp b/src/linux/systemd.cpp
index 75d3c2b..35e427c 100644
--- a/src/linux/systemd.cpp
+++ b/src/linux/systemd.cpp
@@ -200,13 +200,21 @@ bool exists()
   // This is static as the init system should not change while we are running.
   static const bool exists = []() -> bool {
     // (1) Test whether `/sbin/init` links to systemd.
-    const Result<string> realpath = os::realpath("/sbin/init");
-    if (realpath.isError() || realpath.isNone()) {
-      LOG(WARNING) << "Failed to test /sbin/init for systemd environment: "
-                   << (realpath.isError() ? realpath.error()
-                                          : "does not exist");
-
-      return false;
+    // cstrahan(nixos): first assume we're on NixOS, then try non-NixOS
+    Result<string> realpath = os::realpath("/run/current-system/systemd/lib/systemd/systemd");
+    Result<string> realpathNixOS = realpath;
+    if (realpathNixOS.isError() || realpathNixOS.isNone()) {
+      Result<string> realpathNonNixOS = realpath = os::realpath("/sbin/init");
+      if (realpathNonNixOS.isError() || realpathNonNixOS.isNone()) {
+        LOG(WARNING) << "Failed to test /run/current-system/systemd/lib/systemd/systemd for systemd environment: "
+                     << (realpathNixOS.isError() ? realpathNixOS.error()
+                                                 : "does not exist");
+        LOG(WARNING) << "Failed to test /sbin/init for systemd environment: "
+                     << (realpathNonNixOS.isError() ? realpathNonNixOS.error()
+                                                    : "does not exist");
+
+        return false;
+      }
     }
 
     CHECK_SOME(realpath);
@@ -282,6 +290,10 @@ Path hierarchy()
 
 Try<Nothing> daemonReload()
 {
+  // cstrahan(nixos): should we patch these `systemctl`s?
+  // probably don't want to hard-code a particular systemd store path here,
+  // but if we use /run/current-system/sw/bin/systemctl,
+  // we won't be able to support non-NixOS distros.
   Try<string> daemonReload = os::shell("systemctl daemon-reload");
   if (daemonReload.isError()) {
     return Error("Failed to reload systemd daemon: " + daemonReload.error());
diff --git a/src/python/cli/src/mesos/cli.py b/src/python/cli/src/mesos/cli.py
index 4a9b558..c08a8b9 100644
--- a/src/python/cli/src/mesos/cli.py
+++ b/src/python/cli/src/mesos/cli.py
@@ -40,7 +40,7 @@ def resolve(master):
     import subprocess
 
     process = subprocess.Popen(
-        ['mesos-resolve', master],
+        ['@mesos-resolve@', master],
         stdin=None,
         stdout=subprocess.PIPE,
         stderr=subprocess.PIPE,
diff --git a/src/slave/containerizer/mesos/isolators/filesystem/linux.cpp b/src/slave/containerizer/mesos/isolators/filesystem/linux.cpp
index 520d023..14b670e 100644
--- a/src/slave/containerizer/mesos/isolators/filesystem/linux.cpp
+++ b/src/slave/containerizer/mesos/isolators/filesystem/linux.cpp
@@ -332,9 +332,9 @@ static Try<Nothing> ensureSharedMount(const string& _targetDir)
       // here because 'create' will only be invoked during
       // initialization.
       Try<string> mount = os::shell(
-          "mount --bind %s %s && "
-          "mount --make-private %s && "
-          "mount --make-shared %s",
+          "@mount@ --bind %s %s && "
+          "@mount@ --make-private %s && "
+          "@mount@ --make-shared %s",
           targetDir.get(),
           targetDir.get(),
           targetDir.get(),
@@ -353,8 +353,8 @@ static Try<Nothing> ensureSharedMount(const string& _targetDir)
       LOG(INFO) << "Making '" << targetDir.get() << "' a shared mount";
 
       Try<string> mount = os::shell(
-          "mount --make-private %s && "
-          "mount --make-shared %s",
+          "@mount@ --make-private %s && "
+          "@mount@ --make-shared %s",
           targetDir.get(),
           targetDir.get());
 
@@ -423,8 +423,8 @@ static Try<Nothing> ensureAllowDevices(const string& _targetDir)
     // here because 'create' will only be invoked during
     // initialization.
     Try<string> mount = os::shell(
-        "mount --bind %s %s && "
-        "mount -o remount,dev %s",
+        "@mount@ --bind %s %s && "
+        "@mount@ -o remount,dev %s",
         targetDir.get(),
         targetDir.get(),
         targetDir.get());
@@ -442,7 +442,7 @@ static Try<Nothing> ensureAllowDevices(const string& _targetDir)
     LOG(INFO) << "Remounting '" << targetDir.get() << "' with '-o remount,dev'";
 
     Try<string> mount = os::shell(
-        "mount -o remount,dev %s",
+        "@mount@ -o remount,dev %s",
         targetDir.get());
 
     if (mount.isError()) {
diff --git a/src/slave/containerizer/mesos/isolators/gpu/volume.cpp b/src/slave/containerizer/mesos/isolators/gpu/volume.cpp
index 2d058a1..83c018e 100644
--- a/src/slave/containerizer/mesos/isolators/gpu/volume.cpp
+++ b/src/slave/containerizer/mesos/isolators/gpu/volume.cpp
@@ -340,7 +340,7 @@ Try<NvidiaVolume> NvidiaVolume::create()
     string path = path::join(hostPath, "bin", binary);
 
     if (!os::exists(path)) {
-      string command = "which " + binary;
+      string command = "@which@ " + binary;
       Try<string> which = os::shell(command);
 
       if (which.isSome()) {
@@ -354,7 +354,7 @@ Try<NvidiaVolume> NvidiaVolume::create()
                               : "No such file or directory"));
         }
 
-        command = "cp " + realpath.get() + " " + path;
+        command = "@cp@ " + realpath.get() + " " + path;
         Try<string> cp = os::shell(command);
         if (cp.isError()) {
           return Error("Failed to os::shell '" + command + "': " + cp.error());
@@ -426,7 +426,7 @@ Try<NvidiaVolume> NvidiaVolume::create()
             Path(realpath.get()).basename());
 
         if (!os::exists(libraryPath)) {
-          string command = "cp " + realpath.get() + " " + libraryPath;
+          string command = "@cp@ " + realpath.get() + " " + libraryPath;
           Try<string> cp = os::shell(command);
           if (cp.isError()) {
             return Error("Failed to os::shell '" + command + "':"
diff --git a/src/slave/containerizer/mesos/isolators/network/cni/cni.cpp b/src/slave/containerizer/mesos/isolators/network/cni/cni.cpp
index 4142160..5a8236d 100644
--- a/src/slave/containerizer/mesos/isolators/network/cni/cni.cpp
+++ b/src/slave/containerizer/mesos/isolators/network/cni/cni.cpp
@@ -230,9 +230,9 @@ Try<Isolator*> NetworkCniIsolatorProcess::create(const Flags& flags)
       // here because 'create' will only be invoked during
       // initialization.
       Try<string> mount = os::shell(
-          "mount --bind %s %s && "
-          "mount --make-private %s && "
-          "mount --make-shared %s",
+          "@mount@ --bind %s %s && "
+          "@mount@ --make-private %s && "
+          "@mount@ --make-shared %s",
           rootDir->c_str(),
           rootDir->c_str(),
           rootDir->c_str(),
@@ -252,8 +252,8 @@ Try<Isolator*> NetworkCniIsolatorProcess::create(const Flags& flags)
       LOG(INFO) << "Making '" << rootDir.get() << "' a shared mount";
 
       Try<string> mount = os::shell(
-          "mount --make-private %s && "
-          "mount --make-shared %s",
+          "@mount@ --make-private %s && "
+          "@mount@ --make-shared %s",
           rootDir->c_str(),
           rootDir->c_str());
 
diff --git a/src/slave/containerizer/mesos/isolators/network/cni/plugins/port_mapper/port_mapper.cpp b/src/slave/containerizer/mesos/isolators/network/cni/plugins/port_mapper/port_mapper.cpp
index 5445470..2429793 100644
--- a/src/slave/containerizer/mesos/isolators/network/cni/plugins/port_mapper/port_mapper.cpp
+++ b/src/slave/containerizer/mesos/isolators/network/cni/plugins/port_mapper/port_mapper.cpp
@@ -313,7 +313,7 @@ Try<Nothing> PortMapper::addPortMapping(
       # Check if the `chain` exists in the iptable. If it does not
       # exist go ahead and install the chain in the iptables NAT
       # table.
-      iptables -w -n -t nat --list %s
+      @iptables@ -w -n -t nat --list %s
       if [ $? -ne 0 ]; then
         # NOTE: When we create the chain, there is a possibility of a
         # race due to which a container launch can fail. This can
@@ -327,25 +327,25 @@ Try<Nothing> PortMapper::addPortMapping(
         # since it can happen only when the chain is created the first
         # time and two commands for creation of the chain are executed
         # simultaneously.
-        (iptables -w -t nat -N %s || exit 1)
+        (@iptables@ -w -t nat -N %s || exit 1)
 
         # Once the chain has been installed add a rule in the PREROUTING
         # chain to jump to this chain for any packets that are
         # destined to a local address.
-        (iptables -w -t nat -A PREROUTING \
+        (@iptables@ -w -t nat -A PREROUTING \
         -m addrtype --dst-type LOCAL -j %s || exit 1)
 
         # For locally generated packets we need a rule in the OUTPUT
         # chain as well, since locally generated packets directly hit
         # the output CHAIN, bypassing PREROUTING.
-        (iptables -w -t nat -A OUTPUT \
+        (@iptables@ -w -t nat -A OUTPUT \
         ! -d 127.0.0.0/8 -m addrtype \
         --dst-type LOCAL -j %s || exit 1)
       fi
 
       # Within the `chain` go ahead and install the DNAT rule, if it
       # does not exist.
-      (iptables -w -t nat -C %s || iptables -w -t nat -A %s))~",
+      (@iptables@ -w -t nat -C %s || @iptables@ -w -t nat -A %s))~",
       chain,
       chain,
       chain,
@@ -392,7 +392,7 @@ Try<Nothing> PortMapper::delPortMapping()
 
       trap cleanup EXIT
 
-      iptables -w -t nat -S %s | sed -n "/%s/ s/-A/iptables -w -t nat -D/p" > $FILE
+      @iptables@ -w -t nat -S %s | sed -n "/%s/ s/-A/@iptables@ -w -t nat -D/p" > $FILE
       sh $FILE
       )~",
       chain,
diff --git a/src/slave/containerizer/mesos/isolators/network/port_mapping.cpp b/src/slave/containerizer/mesos/isolators/network/port_mapping.cpp
index 3dd32f5..6e8cd4e 100644
--- a/src/slave/containerizer/mesos/isolators/network/port_mapping.cpp
+++ b/src/slave/containerizer/mesos/isolators/network/port_mapping.cpp
@@ -1384,19 +1384,19 @@ Try<Isolator*> PortMappingIsolatorProcess::create(const Flags& flags)
   // Check the availability of a few Linux commands that we will use.
   // We use the blocking os::shell here because 'create' will only be
   // invoked during initialization.
-  Try<string> checkCommandTc = os::shell("tc filter show");
+  Try<string> checkCommandTc = os::shell("@tc@ filter show");
   if (checkCommandTc.isError()) {
     return Error("Check command 'tc' failed: " + checkCommandTc.error());
   }
 
   // NOTE: loopback device always exists.
-  Try<string> checkCommandEthtool = os::shell("ethtool -k lo");
+  Try<string> checkCommandEthtool = os::shell("@ethtool@ -k lo");
   if (checkCommandEthtool.isError()) {
     return Error("Check command 'ethtool' failed: "
                  + checkCommandEthtool.error());
   }
 
-  Try<string> checkCommandIp = os::shell("ip link show");
+  Try<string> checkCommandIp = os::shell("@ip@ link show");
   if (checkCommandIp.isError()) {
     return Error("Check command 'ip' failed: " + checkCommandIp.error());
   }
@@ -1950,9 +1950,9 @@ Try<Isolator*> PortMappingIsolatorProcess::create(const Flags& flags)
     // visible. It's OK to use the blocking os::shell here because
     // 'create' will only be invoked during initialization.
     Try<string> mount = os::shell(
-        "mount --bind %s %s && "
-        "mount --make-slave %s && "
-        "mount --make-shared %s",
+        "@mount@ --bind %s %s && "
+        "@mount@ --make-slave %s && "
+        "@mount@ --make-shared %s",
         bindMountRoot->c_str(),
         bindMountRoot->c_str(),
         bindMountRoot->c_str(),
@@ -1969,8 +1969,8 @@ Try<Isolator*> PortMappingIsolatorProcess::create(const Flags& flags)
       // shared mount yet (possibly due to slave crash while preparing
       // the work directory mount). It's safe to re-do the following.
       Try<string> mount = os::shell(
-          "mount --make-slave %s && "
-          "mount --make-shared %s",
+          "@mount@ --make-slave %s && "
+          "@mount@ --make-shared %s",
           bindMountRoot->c_str(),
           bindMountRoot->c_str());
 
@@ -1989,8 +1989,8 @@ Try<Isolator*> PortMappingIsolatorProcess::create(const Flags& flags)
           // so that they are in different peer groups.
           if (entry.shared() == bindMountEntry->shared()) {
             Try<string> mount = os::shell(
-                "mount --make-slave %s && "
-                "mount --make-shared %s",
+                "@mount@ --make-slave %s && "
+                "@mount@ --make-shared %s",
                 bindMountRoot->c_str(),
                 bindMountRoot->c_str());
 
@@ -3945,6 +3945,8 @@ Try<Nothing> PortMappingIsolatorProcess::removeHostIPFilters(
 // TODO(jieyu): Use the Subcommand abstraction to remove most of the
 // logic here. Completely remove this function once we can assume a
 // newer kernel where 'setns' works for mount namespaces.
+// cstrahan(nixos): this is executed in the container,
+// so we don't want to substitute paths here.
 string PortMappingIsolatorProcess::scripts(Info* info)
 {
   ostringstream script;
@@ -3955,7 +3957,7 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   // Mark the mount point PORT_MAPPING_BIND_MOUNT_ROOT() as slave
   // mount so that changes in the container will not be propagated to
   // the host.
-  script << "mount --make-rslave " << bindMountRoot << "\n";
+  script << "@mount@ --make-rslave " << bindMountRoot << "\n";
 
   // Disable IPv6 when IPv6 module is loaded as IPv6 packets won't be
   // forwarded anyway.
@@ -3963,7 +3965,7 @@ string PortMappingIsolatorProcess::scripts(Info* info)
          << " echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6\n";
 
   // Configure lo and eth0.
-  script << "ip link set " << lo << " address " << hostMAC
+  script << "@ip@ link set " << lo << " address " << hostMAC
          << " mtu " << hostEth0MTU << " up\n";
 
   // NOTE: This is mostly a kernel issue: in veth_xmit() the kernel
@@ -3972,13 +3974,13 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   // when we receive a packet with a bad checksum. Disabling rx
   // checksum offloading ensures the TCP layer will checksum and drop
   // it.
-  script << "ethtool -K " << eth0 << " rx off\n";
-  script << "ip link set " << eth0 << " address " << hostMAC
+  script << "@ethtool@ -K " << eth0 << " rx off\n";
+  script << "@ip@ link set " << eth0 << " address " << hostMAC
          << " mtu " << hostEth0MTU << " up\n";
-  script << "ip addr add " << hostIPNetwork << " dev " << eth0 << "\n";
+  script << "@ip@ addr add " << hostIPNetwork << " dev " << eth0 << "\n";
 
   // Set up the default gateway to match that of eth0.
-  script << "ip route add default via " << hostDefaultGateway << "\n";
+  script << "@ip@ route add default via " << hostDefaultGateway << "\n";
 
   // Restrict the ephemeral ports that can be used by the container.
   script << "echo " << info->ephemeralPorts.lower() << " "
@@ -4007,19 +4009,19 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   }
 
   // Set up filters on lo and eth0.
-  script << "tc qdisc add dev " << lo << " ingress\n";
-  script << "tc qdisc add dev " << eth0 << " ingress\n";
+  script << "@tc@ qdisc add dev " << lo << " ingress\n";
+  script << "@tc@ qdisc add dev " << eth0 << " ingress\n";
 
   // Allow talking between containers and from container to host.
   // TODO(chzhcn): Consider merging the following two filters.
-  script << "tc filter add dev " << lo << " parent " << ingress::HANDLE
+  script << "@tc@ filter add dev " << lo << " parent " << ingress::HANDLE
          << " protocol ip"
          << " prio " << Priority(IP_FILTER_PRIORITY, NORMAL).get() << " u32"
          << " flowid ffff:0"
          << " match ip dst " << hostIPNetwork.address()
          << " action mirred egress redirect dev " << eth0 << "\n";
 
-  script << "tc filter add dev " << lo << " parent " << ingress::HANDLE
+  script << "@tc@ filter add dev " << lo << " parent " << ingress::HANDLE
          << " protocol ip"
          << " prio " << Priority(IP_FILTER_PRIORITY, NORMAL).get() << " u32"
          << " flowid ffff:0"
@@ -4030,7 +4032,7 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   foreach (const PortRange& range,
            getPortRanges(info->nonEphemeralPorts + info->ephemeralPorts)) {
     // Local traffic inside a container will not be redirected to eth0.
-    script << "tc filter add dev " << lo << " parent " << ingress::HANDLE
+    script << "@tc@ filter add dev " << lo << " parent " << ingress::HANDLE
            << " protocol ip"
            << " prio " << Priority(IP_FILTER_PRIORITY, HIGH).get() << " u32"
            << " flowid ffff:0"
@@ -4039,7 +4041,7 @@ string PortMappingIsolatorProcess::scripts(Info* info)
 
     // Traffic going to host loopback IP and ports assigned to this
     // container will be redirected to lo.
-    script << "tc filter add dev " << eth0 << " parent " << ingress::HANDLE
+    script << "@tc@ filter add dev " << eth0 << " parent " << ingress::HANDLE
            << " protocol ip"
            << " prio " << Priority(IP_FILTER_PRIORITY, NORMAL).get() << " u32"
            << " flowid ffff:0"
@@ -4051,14 +4053,14 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   }
 
   // Do not forward the ICMP packet if the destination IP is self.
-  script << "tc filter add dev " << lo << " parent " << ingress::HANDLE
+  script << "@tc@ filter add dev " << lo << " parent " << ingress::HANDLE
          << " protocol ip"
          << " prio " << Priority(ICMP_FILTER_PRIORITY, NORMAL).get() << " u32"
          << " flowid ffff:0"
          << " match ip protocol 1 0xff"
          << " match ip dst " << hostIPNetwork.address() << "\n";
 
-  script << "tc filter add dev " << lo << " parent " << ingress::HANDLE
+  script << "@tc@ filter add dev " << lo << " parent " << ingress::HANDLE
          << " protocol ip"
          << " prio " << Priority(ICMP_FILTER_PRIORITY, NORMAL).get() << " u32"
          << " flowid ffff:0"
@@ -4067,9 +4069,9 @@ string PortMappingIsolatorProcess::scripts(Info* info)
          << net::IP::Network::LOOPBACK_V4().address() << "\n";
 
   // Display the filters created on eth0 and lo.
-  script << "tc filter show dev " << eth0
+  script << "@tc@ filter show dev " << eth0
          << " parent " << ingress::HANDLE << "\n";
-  script << "tc filter show dev " << lo
+  script << "@tc@ filter show dev " << lo
          << " parent " << ingress::HANDLE << "\n";
 
   // If throughput limit for container egress traffic exists, use HTB
@@ -4081,9 +4083,9 @@ string PortMappingIsolatorProcess::scripts(Info* info)
   // throughput. TBF requires other parameters such as 'burst' that
   // HTB already has default values for.
   if (egressRateLimitPerContainer.isSome()) {
-    script << "tc qdisc add dev " << eth0 << " root handle "
+    script << "@tc@ qdisc add dev " << eth0 << " root handle "
            << CONTAINER_TX_HTB_HANDLE << " htb default 1\n";
-    script << "tc class add dev " << eth0 << " parent "
+    script << "@tc@ class add dev " << eth0 << " parent "
            << CONTAINER_TX_HTB_HANDLE << " classid "
            << CONTAINER_TX_HTB_CLASS_ID << " htb rate "
            << egressRateLimitPerContainer->bytes() * 8 << "bit\n";
@@ -4094,12 +4096,12 @@ string PortMappingIsolatorProcess::scripts(Info* info)
     // fq_codel, which has a larger buffer and better control on
     // buffer bloat.
     // TODO(cwang): Verity that fq_codel qdisc is available.
-    script << "tc qdisc add dev " << eth0
+    script << "@tc@ qdisc add dev " << eth0
            << " parent " << CONTAINER_TX_HTB_CLASS_ID << " fq_codel\n";
 
     // Display the htb qdisc and class created on eth0.
-    script << "tc qdisc show dev " << eth0 << "\n";
-    script << "tc class show dev " << eth0 << "\n";
+    script << "@tc@ qdisc show dev " << eth0 << "\n";
+    script << "@tc@ class show dev " << eth0 << "\n";
   }
 
   return script.str();
diff --git a/src/slave/containerizer/mesos/isolators/posix/disk.cpp b/src/slave/containerizer/mesos/isolators/posix/disk.cpp
index 50ecfd1..fa91803 100644
--- a/src/slave/containerizer/mesos/isolators/posix/disk.cpp
+++ b/src/slave/containerizer/mesos/isolators/posix/disk.cpp
@@ -633,7 +633,7 @@ private:
     // NOTE: The supervisor childhook will watch the parent process and kill
     // the 'du' process in case that the parent die.
     Try<Subprocess> s = subprocess(
-        "du",
+        "@du@",
         command,
         Subprocess::PATH(os::DEV_NULL),
         Subprocess::PIPE(),
diff --git a/src/slave/containerizer/mesos/provisioner/backends/copy.cpp b/src/slave/containerizer/mesos/provisioner/backends/copy.cpp
index f1cecd0..aa2a16a 100644
--- a/src/slave/containerizer/mesos/provisioner/backends/copy.cpp
+++ b/src/slave/containerizer/mesos/provisioner/backends/copy.cpp
@@ -269,7 +269,7 @@ Future<Nothing> CopyBackendProcess::_provision(
 #endif // __APPLE__ || __FreeBSD__
 
   Try<Subprocess> s = subprocess(
-      "cp",
+      "@cp@",
       args,
       Subprocess::PATH(os::DEV_NULL),
       Subprocess::PATH(os::DEV_NULL),
@@ -316,7 +316,7 @@ Future<bool> CopyBackendProcess::destroy(const string& rootfs)
   vector<string> argv{"rm", "-rf", rootfs};
 
   Try<Subprocess> s = subprocess(
-      "rm",
+      "@rm@",
       argv,
       Subprocess::PATH(os::DEV_NULL),
       Subprocess::FD(STDOUT_FILENO),
diff --git a/src/uri/fetchers/copy.cpp b/src/uri/fetchers/copy.cpp
index 713099e..3558dba 100644
--- a/src/uri/fetchers/copy.cpp
+++ b/src/uri/fetchers/copy.cpp
@@ -98,7 +98,7 @@ Future<Nothing> CopyFetcherPlugin::fetch(
   VLOG(1) << "Copying '" << uri.path() << "' to '" << directory << "'";
 
 #ifndef __WINDOWS__
-  const char* copyCommand = "cp";
+  const char* copyCommand = "@cp@";
   const vector<string> argv = {"cp", "-a", uri.path(), directory};
 #else // __WINDOWS__
   const char* copyCommand = os::Shell::name;
diff --git a/src/uri/fetchers/curl.cpp b/src/uri/fetchers/curl.cpp
index 1796620..6f65368 100644
--- a/src/uri/fetchers/curl.cpp
+++ b/src/uri/fetchers/curl.cpp
@@ -114,7 +114,7 @@ Future<Nothing> CurlFetcherPlugin::fetch(
   }
 
 #ifndef __WINDOWS__
-  const string curl = "curl";
+  const string curl = "@curl@";
 #else
   const string curl = "curl.exe";
 #endif // __WINDOWS__
diff --git a/src/uri/fetchers/docker.cpp b/src/uri/fetchers/docker.cpp
index 09feb68..4524b3a 100644
--- a/src/uri/fetchers/docker.cpp
+++ b/src/uri/fetchers/docker.cpp
@@ -156,7 +156,7 @@ static Future<http::Response> curl(
   string cmd = strings::join(" ", argv);
 
   Try<Subprocess> s = subprocess(
-      "curl",
+      "@curl@",
       argv,
       Subprocess::PATH(os::DEV_NULL),
       Subprocess::PIPE(),
@@ -282,7 +282,7 @@ static Future<int> download(
   string cmd = strings::join(" ", argv);
 
   Try<Subprocess> s = subprocess(
-      "curl",
+      "@curl@",
       argv,
       Subprocess::PATH(os::DEV_NULL),
       Subprocess::PIPE(),
