diff -u ParaView-v4.3.1-source/Utilities/VisItBridge/databases/Silo/avtSiloFileFormat.C ParaView-v4.3.1-source.new/Utilities/VisItBridge/databases/Silo/avtSiloFileFormat.C
--- ParaView-v4.3.1-source/Utilities/VisItBridge/databases/Silo/avtSiloFileFormat.C	2015-01-14 14:07:36.000000000 +0100
+++ ParaView-v4.3.1-source.new/Utilities/VisItBridge/databases/Silo/avtSiloFileFormat.C	2015-01-27 17:56:53.939327411 +0100
@@ -161,7 +161,7 @@
     string primary_objname_incl_any_abs_or_rel_path,
     string indirect_objname_incl_any_abs_or_rel_path);
 
-static DBgroupelmap * 
+static DBgroupelmap *
 GetCondensedGroupelMap(DBfile *dbfile, string mrgtnm_abspath,
     DBmrgtnode *rootNode, int forceSingle, int gpel_type);
 static void HandleMrgtreeNodelistVars(DBfile *dbfile, const string& mname,
@@ -240,7 +240,7 @@
 //    them.
 //
 //    Mark C. Miller, Mon Mar 16 23:33:32 PDT 2009
-//    Moved logic for 'old' extents interface to CommonPluginInfo where 
+//    Moved logic for 'old' extents interface to CommonPluginInfo where
 //    old (obsolete) options can be merged with current interface. Also, use
 //    const char* symbol names for options defined in avtSiloOptions.h.
 //
@@ -292,12 +292,12 @@
     : avtSTMDFileFormat(&toc_name, 1)
 {
     //
-    // Initialize class variables BEFORE processing read options 
+    // Initialize class variables BEFORE processing read options
     //
     forceSingle = 0;
     numNodeLists = 0;
     numAnnotIntLists = 0;
-    tocIndex = 0; 
+    tocIndex = 0;
     ignoreSpatialExtentsAAN = Auto;
     ignoreDataExtentsAAN = Auto;
     ignoreSpatialExtents = false;
@@ -363,10 +363,10 @@
     }
 
     //
-    // Set any necessary Silo library behavior 
+    // Set any necessary Silo library behavior
     //
     DBForceSingle(forceSingle);
-    
+
     //
     // If there is ever a problem with Silo, we want it to throw an
     // exception.
@@ -395,8 +395,8 @@
 //    Hank Childs, Mon Jan  7 18:51:24 PST 2002
 //    Fixed memory leak.
 //
-//    Kathleen Bonnell, Wed Oct  1 17:08:51 PDT 2003 
-//    Call CloseFile so that files are unregistered. 
+//    Kathleen Bonnell, Wed Oct  1 17:08:51 PDT 2003
+//    Call CloseFile so that files are unregistered.
 //
 //    Hank Childs, Wed Jan 14 11:58:41 PST 2004
 //    Use CleanUpResources so there can be one routine that does all the clean
@@ -421,7 +421,7 @@
 //    to GetMesh, GetVar, etc. All processors do call this method.
 //
 //  Programmer: Mark C. Miller
-//  Creation:   February 9, 2004 
+//  Creation:   February 9, 2004
 //
 //  Modifications:
 //    Cyrus Harrison, Mon Jun 14 15:34:22 PDT 2010
@@ -449,11 +449,11 @@
 //
 //  Purpose: Get file at specified index, assuming its already been opened
 //  and throw an exception if it hasn't. This is intended to replace various
-//  calls to OpenFile, that could ultimately result in MPI collective 
+//  calls to OpenFile, that could ultimately result in MPI collective
 //  communication if the file had not been opened in the past, and could
 //  cause VisIt to deadlock.
 //
-//  Programmer: Mark C. Miller 
+//  Programmer: Mark C. Miller
 //  Creation:   February 10, 2004
 //
 //  Modifications:
@@ -492,7 +492,7 @@
 //
 //    Hank Childs, Mon Mar 11 17:29:06 PST 2002
 //    Made call to GetTimeVaryingInformation.
-//    
+//
 //    Hank Childs, Fri Mar 22 10:32:33 PST 2002
 //    Added calls to support file descriptor management.
 //
@@ -515,7 +515,7 @@
 //    separating the name of the file as the filesystem sees it and the dir
 //    in the file to be used as the 'top dir' for this timestep. Note also,
 //    That there has to exist in the filesystem a real file (usually a symlink)
-//    named as <filename>:<dirname> that opens to the desired file. 
+//    named as <filename>:<dirname> that opens to the desired file.
 //
 //    Jeremy Meredith, Thu Aug  7 16:16:34 EDT 2008
 //    Added missing filename argument to an sprintf.
@@ -634,7 +634,7 @@
         if (nSiloObjects <= 0)
         {
             char str[1024];
-            SNPRINTF(str, sizeof(str), "Although the Silo library succesfully opened \"%s,\"\n" 
+            SNPRINTF(str, sizeof(str), "Although the Silo library succesfully opened \"%s,\"\n"
                      "the file contains no silo objects. It may be a PDB file.",
                      filenames[f]);
             EXCEPTION1(InvalidFilesException, str);
@@ -721,8 +721,8 @@
 //
 //  Purpose: Return the cycle number associated with this silo file
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   May 16, 2005 
+//  Programmer: Mark C. Miller
+//  Creation:   May 16, 2005
 //
 //  Modifications:
 //    Mark C. Miller, Tue May 31 20:12:42 PDT 2005
@@ -774,7 +774,7 @@
 // ****************************************************************************
 //  Method: avtSiloFileFormat::GetCycleFromFilename
 //
-//  Purpose: Try to get a cycle number from a file name 
+//  Purpose: Try to get a cycle number from a file name
 //
 //  Notes: Although all this method does is simply call the format's base
 //  class implementation of GuessCycle, doing this is a way for the Silo
@@ -782,8 +782,8 @@
 //  wouldn't know that Silo thinks those guesses are good. See notes in
 //  avtSTXXFileFormatInterface::SetDatabaseMetaData for further explanation.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   May 16, 2005 
+//  Programmer: Mark C. Miller
+//  Creation:   May 16, 2005
 //
 // ****************************************************************************
 
@@ -798,8 +798,8 @@
 //
 //  Purpose: Return the time associated with this silo file
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   May 16, 2005 
+//  Programmer: Mark C. Miller
+//  Creation:   May 16, 2005
 //
 //  Modifications:
 //    Mark C. Miller, Mon Mar 19 15:52:24 PDT 2007
@@ -936,7 +936,7 @@
 avtSiloFileFormat::OpenFile(const char *n, bool skipGlobalInfo)
 {
     //
-    // The directory of this file is all relative to the directory of the 
+    // The directory of this file is all relative to the directory of the
     // table of contents.  Reflect that here.
     //
     char name[1024];
@@ -1012,7 +1012,7 @@
 //
 //  Modifications:
 //
-//    Hank Childs, Fri Mar 22 11:10:18 PST 2002 
+//    Hank Childs, Fri Mar 22 11:10:18 PST 2002
 //    Added a method call to make sure that we are playing well with the file
 //    descriptor manager.
 //
@@ -1133,7 +1133,7 @@
 //
 //    Brad Whitlock, Mon Oct 22 18:33:37 PST 2001
 //    Changed the exception keywords to macros.
-// 
+//
 //    Jeremy Meredith, Thu Oct 25 13:02:18 PDT 2001
 //    Added code to read domain decomposition information.
 //
@@ -1189,10 +1189,10 @@
 
     //
     // We're just interested in metadata for now, so tell Silo not
-    // to read the extra data arrays, except for material names and 
+    // to read the extra data arrays, except for material names and
     // numbers and colors.
     //
-    DBSetDataReadMask(DBMatMatnames|DBMatMatnos|DBMatMatcolors);
+    DBSetDataReadMask2(DBMatMatnames|DBMatMatnos|DBMatMatcolors);
 
     //
     // Do a recursive search through the subdirectories.
@@ -1208,13 +1208,13 @@
 
     // To be nice to other functions, tell Silo to turn back on reading all
     // of the data.
-    DBSetDataReadMask(DBAll);
+    DBSetDataReadMask2(DBAll);
 }
 
 // ****************************************************************************
-//  Methods for reading information about different classes of Silo objects. 
+//  Methods for reading information about different classes of Silo objects.
 //
-//  This comment block is kept here for legacy reasons as it contains 
+//  This comment block is kept here for legacy reasons as it contains
 //  information prior to re-factoring of avtSiloFileFormat::ReadDir(). Most
 //  of the meat of that function was re-factored into the ReadXXX() methods,
 //  below, one for each class of Silo object.
@@ -1223,7 +1223,7 @@
 //
 //  Modifications:
 //    Jeremy Meredith, Wed Nov 21 14:11:35 PST 2001
-//    Fixed the logic so the structured domain boundary info works with 
+//    Fixed the logic so the structured domain boundary info works with
 //    more file types.
 //
 //    Eric Brugger, Tue Nov 27 16:21:17 PST 2001
@@ -1293,9 +1293,9 @@
 //    Hank Childs, Fri Sep 27 14:58:14 PDT 2002
 //    Added support for mesh units.
 //
-//    Kathleen Bonnell, Wed Oct 23 13:55:55 PDT 2002  
-//    Added tdims, so that topological dimension for multi-point-meshes will 
-//    be set correctly. 
+//    Kathleen Bonnell, Wed Oct 23 13:55:55 PDT 2002
+//    Added tdims, so that topological dimension for multi-point-meshes will
+//    be set correctly.
 //
 //    Hank Childs, Fri Oct 25 15:44:28 PDT 2002
 //    Fix a bug where the topological dimension was not being set correctly,
@@ -1352,9 +1352,9 @@
 //    at most one entry per semicolon, but you can have one less separator
 //    than num entries.  Second, it was walking off the end of the string.
 //
-//    Kathleen Bonnell, Thu Jul 22 12:30:22 PDT 2004 
+//    Kathleen Bonnell, Thu Jul 22 12:30:22 PDT 2004
 //    Use value of ascii_labels option for variables to set treatAsASCII
-//    in ScalarMetaData. 
+//    in ScalarMetaData.
 //
 //    Brad Whitlock, Tue Jul 20 15:48:04 PST 2004
 //    Added support for passing the variable units back up to VisIt via
@@ -1392,18 +1392,18 @@
 //    Made it more fault tolerant when multimats are corrupted
 //
 //    Mark C. Miller, Wed Nov 16 10:46:36 PST 2005
-//    Removed spoofing of CSG mesh as a surface mesh  
+//    Removed spoofing of CSG mesh as a surface mesh
 //
 //    Mark C. Miller, Wed Jan 18 19:58:47 PST 2006
 //    Made it more fault tolerant for multivar, multimat and multimatspecies
 //    objects that contained all EMPTY pieces.
 //
-//    Kathleen Bonnell, Wed Feb  8 09:41:45 PST 2006 
-//    Set mmd->meshCoordType from coord_sys. 
+//    Kathleen Bonnell, Wed Feb  8 09:41:45 PST 2006
+//    Set mmd->meshCoordType from coord_sys.
 //
 //    Mark C. Miller, Thu Mar  2 00:03:40 PST 2006
 //    Added support for curve objects
-// 
+//
 //    Hank Childs, Thu May 18 11:33:27 PDT 2006
 //    Fix UMR with mesh coord types and point meshes.
 //
@@ -1456,7 +1456,7 @@
 //    Mark C. Miller, Wed Feb 25 17:35:05 PST 2009
 //    Tightened logic for triggering ANNOTATION_INT nodelist search to ensure
 //    it happens only when ReadDir is in the root (topDir) directory. Also,
-//    Added a call to CloseFile(1) just prior to calling AddAnnotInt... as 
+//    Added a call to CloseFile(1) just prior to calling AddAnnotInt... as
 //    a work-around for a bug in HDF5.
 //
 //    Mark C. Miller, Mon Mar  2 11:50:08 PST 2009
@@ -1692,7 +1692,7 @@
 // ****************************************************************************
 
 void
-avtSiloFileFormat::ReadMultimeshes(DBfile *dbfile, 
+avtSiloFileFormat::ReadMultimeshes(DBfile *dbfile,
     int nmultimesh, char **multimesh_names,
     const char *dirname, avtDatabaseMetaData *md)
 {
@@ -1725,13 +1725,13 @@
                 {
                     if (mm->repr_block_idx >= mm->nblocks)
                     {
-                        debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                        debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                << "\" since repr_block_idx (" << mm->repr_block_idx
                                << ") >= nblocks (" << mm->nblocks << ")" << endl;
                         valid_var = false;
                     }
                     else
-                    { 
+                    {
                         meshnum = mm->repr_block_idx;
                         mb_meshname  = mm_ent->GenerateName(meshnum);
                     }
@@ -1741,7 +1741,7 @@
                     meshnum++;
                     if (meshnum >= mm->nblocks)
                     {
-                        debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                        debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                << "\" since all its blocks are EMPTY." << endl;
                         valid_var = false;
                         break;
@@ -1790,7 +1790,7 @@
                         DBucdmesh *um = DBGetUcdmesh(correctFile, realvar.c_str());
                         if (um == NULL)
                         {
-                            debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                            debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                    << "\" since its first non-empty block (" << mb_meshname
                                    << ") is invalid." << endl;
                             break;
@@ -1820,7 +1820,7 @@
 
                         if (ndims ==2 && um->coord_sys == DB_CYLINDRICAL)
                             mct = AVT_RZ;
-                        else 
+                        else
                             mct = AVT_XY;
 
                         DBFreeUcdmesh(um);
@@ -1838,7 +1838,7 @@
                         DBpointmesh *pm = DBGetPointmesh(correctFile, realvar.c_str());
                         if (pm == NULL)
                         {
-                            debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                            debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                    << "\" since its first non-empty block (" << mb_meshname
                                    << ") is invalid." << endl;
                             break;
@@ -1874,7 +1874,7 @@
                         DBquadmesh *qm = DBGetQuadmesh(correctFile, realvar.c_str());
                         if (qm == NULL)
                         {
-                            debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                            debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                    << "\" since its first non-empty block (" << mb_meshname
                                    << ") is invalid." << endl;
                             break;
@@ -1898,7 +1898,7 @@
 
                         if (ndims ==2 && qm->coord_sys == DB_CYLINDRICAL)
                             mct = AVT_RZ;
-                        else 
+                        else
                             mct = AVT_XY;
 
                         DBFreeQuadmesh(qm);
@@ -1915,13 +1915,13 @@
                         DBquadmesh *qm = DBGetQuadmesh(correctFile, realvar.c_str());
                         if (qm == NULL)
                         {
-                            debug1 << "Invalidating mesh \"" << multimesh_names[i] 
+                            debug1 << "Invalidating mesh \"" << multimesh_names[i]
                                    << "\" since its first non-empty block (" << mb_meshname
                                    << ") is invalid." << endl;
                             break;
                         }
                         ndims = qm->ndims;
-                        tdims = ndims; 
+                        tdims = ndims;
                         cellOrigin = qm->origin;
                         if (qm->units[0] != NULL)
                             xUnits = qm->units[0];
@@ -1939,7 +1939,7 @@
 
                         if (ndims ==2 && qm->coord_sys == DB_CYLINDRICAL)
                             mct = AVT_RZ;
-                        else 
+                        else
                             mct = AVT_XY;
 
                         DBFreeQuadmesh(qm);
@@ -1996,7 +1996,7 @@
 #ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,6,2)
                 if (mt == AVT_UNSTRUCTURED_MESH)
-                    mmd->disjointElements = hasDisjointElements || mm->disjoint_mode != 0; 
+                    mmd->disjointElements = hasDisjointElements || mm->disjoint_mode != 0;
 #else
                 if (mt == AVT_UNSTRUCTURED_MESH)
                     mmd->disjointElements = hasDisjointElements;
@@ -2168,7 +2168,7 @@
 
                 if (qm->ndims == 2 && qm->coord_sys == DB_CYLINDRICAL)
                     mmd->meshCoordType = AVT_RZ;
-    
+
                 mmd->validVariable = valid_var;
                 mmd->groupTitle = "blocks";
                 mmd->groupPieceName = "block";
@@ -2529,14 +2529,14 @@
 
            // We want to read the header for the csg zonelist too
            // so we can serve up the "zones" of a csg mesh as "blocks"
-           long mask = DBGetDataReadMask();
-           DBSetDataReadMask(mask|DBCSGMZonelist|DBCSGZonelistZoneNames);
+           long mask = DBGetDataReadMask2();
+           DBSetDataReadMask2(mask|DBCSGMZonelist|DBCSGZonelistZoneNames);
            csgm = DBGetCsgmesh(correctFile, realvar.c_str());
-           DBSetDataReadMask(mask);
+           DBSetDataReadMask2(mask);
            if (csgm == NULL || csgm->zones == NULL)
            {
                debug1 << "Unable to read mesh \"" << csgmesh_names[i]
-                      << "\". Skipping it" << endl; 
+                      << "\". Skipping it" << endl;
                valid_var = false;
                csgm = DBAllocCsgmesh();
                csgm->zones = DBAllocCSGZonelist();
@@ -2658,7 +2658,7 @@
         {
             int regno = strtol(region_pnames[i], 0, 10);
             regionNamesButMaterialNumbers = false;
-            debug3 << "        Comparing using regno=" << regno << "..." << endl; 
+            debug3 << "        Comparing using regno=" << regno << "..." << endl;
             for (j = 0; j < mmd->numMaterials; j++)
             {
                 // The 'materialNames' Silo plugin creates are either
@@ -2667,7 +2667,7 @@
                 errno = 0;
                 int matno = strtol(mmd->materialNames[j].c_str(), 0, 10);
                 debug3 << "            for \"" << mmd->materialNames[j]
-                       << "\" got matno=" << matno; 
+                       << "\" got matno=" << matno;
                 if (errno == 0 && regno == matno)
                 {
                     debug3 << " matched" << endl;
@@ -2788,13 +2788,13 @@
                 {
                     if (mv->repr_block_idx >= mv->nvars)
                     {
-                        debug1 << "Invalidating variable \"" << multivar_names[i] 
+                        debug1 << "Invalidating variable \"" << multivar_names[i]
                                << "\" since repr_block_idx (" << mv->repr_block_idx
                                << ") >= nvars (" << mv->nvars << ")" << endl;
                         valid_var = false;
                     }
                     else
-                    { 
+                    {
                         meshnum = mv->repr_block_idx;
                         mb_varname  = mv_ent->GenerateName(meshnum);
                     }
@@ -2804,7 +2804,7 @@
                     meshnum++;
                     if (meshnum >= mv->nvars)
                     {
-                        debug1 << "Invalidating variable \"" << multivar_names[i] 
+                        debug1 << "Invalidating variable \"" << multivar_names[i]
                                << "\" since all its blocks are EMPTY." << endl;
                         valid_var = false;
                         break;
@@ -2819,7 +2819,7 @@
                     if (mv->mmesh_name != 0)
                     {
                         meshname = mv->mmesh_name;
-                        debug5 << "Variable \"" << multivar_names[i] 
+                        debug5 << "Variable \"" << multivar_names[i]
                                << "\" indicates it is defined on mesh \""
                                << meshname.c_str() << "\"" << endl;
                     }
@@ -2833,7 +2833,7 @@
                         //       this variable.
                             meshname = DetermineMultiMeshForSubVariable(dbfile,
                                 multivar_names[i], mv_ent, dirname);
-                            debug5 << "Guessing variable \"" << multivar_names[i] 
+                            debug5 << "Guessing variable \"" << multivar_names[i]
                                    << "\" is defined on mesh \""
                                    << meshname.c_str() << "\"" << endl;
                     }
@@ -2879,7 +2879,7 @@
                             valid_var = false;
                             break;
                         }
-                        centering = (uv->centering == DB_ZONECENT ? AVT_ZONECENT 
+                        centering = (uv->centering == DB_ZONECENT ? AVT_ZONECENT
                                                                   : AVT_NODECENT);
                         if (uv->region_pnames && !selectedMats.size())
                             valid_var = GetRestrictedMaterialIndices(md, name_w_dir,
@@ -2891,7 +2891,7 @@
                         DBFreeUcdvar(uv);
                     }
                     break;
-        
+
                   case DB_QUADVAR:
                     {
                         DBquadvar *qv = DBGetQuadvar(correctFile, realvar.c_str());
@@ -2900,7 +2900,7 @@
                             valid_var = false;
                             break;
                         }
-                        centering = (qv->align[0] == 0. ? AVT_NODECENT 
+                        centering = (qv->align[0] == 0. ? AVT_NODECENT
                                                         : AVT_ZONECENT);
                         if (qv->region_pnames && !selectedMats.size())
                             valid_var = GetRestrictedMaterialIndices(md, name_w_dir,
@@ -2912,7 +2912,7 @@
                         DBFreeQuadvar(qv);
                     }
                     break;
-        
+
                   case DB_POINTVAR:
                     {
                         centering = AVT_NODECENT;   // Only one possible
@@ -3384,7 +3384,7 @@
 
             if (!DBIsEmptyCsgvar(csgv))
             {
-                char meshname[256]; 
+                char meshname[256];
                 DBInqMeshname(correctFile, realvar.c_str(), meshname);
 
                 //
@@ -3633,7 +3633,7 @@
                 RegisterDomainDirs(mm_ent, dirname);
             }
 
-            // use these temp vars 
+            // use these temp vars
             int    minfo_nmats = 0;
             int   *minfo_matnos = NULL;
             char **minfo_matnames = NULL;
@@ -3648,13 +3648,13 @@
                 {
                     if (mm->repr_block_idx >= mm->nmats)
                     {
-                        debug1 << "Invalidating material \"" << multimat_names[i] 
+                        debug1 << "Invalidating material \"" << multimat_names[i]
                                << "\" since repr_block_idx (" << mm->repr_block_idx
                                << ") >= nmats (" << mm->nmats << ")" << endl;
                         valid_var = false;
                     }
                     else
-                    { 
+                    {
                         meshnum = mm->repr_block_idx;
                         mb_matname = mm_ent->GenerateName(meshnum);
                     }
@@ -3664,7 +3664,7 @@
                     meshnum++;
                     if (meshnum >= mm->nmats)
                     {
-                        debug1 << "Invalidating material \"" << multimat_names[i] 
+                        debug1 << "Invalidating material \"" << multimat_names[i]
                                << "\" since all its blocks are EMPTY." << endl;
                         valid_var = false;
                         break;
@@ -3683,7 +3683,7 @@
 
                 if (mat == NULL)
                 {
-                    debug1 << "Invalidating material \"" << multimat_names[i] 
+                    debug1 << "Invalidating material \"" << multimat_names[i]
                            << "\" since its first non-empty block ";
                     if(valid_var)
                         debug1 << "(" << mb_matname << ") ";
@@ -3707,7 +3707,7 @@
 #endif
                     if (invalidateVar)
                     {
-                        debug1 << "Invalidating material \"" << multimat_names[i] 
+                        debug1 << "Invalidating material \"" << multimat_names[i]
                                << "\" since its first non-empty block ";
                         if(valid_var)
                             debug1 << "(" << mb_matname << ") ";
@@ -3955,7 +3955,7 @@
 //    handle freeing of multimat species during exceptions.
 //
 //    Mark C. Miller, Mon Mar 29 17:27:43 PDT 2010
-//    Reset Silo error level to DB_TOP as that is correct setting for 
+//    Reset Silo error level to DB_TOP as that is correct setting for
 //    newer versions of Silo library.
 //
 //    Mark C. Miller Tue Mar 30 16:28:48 PDT 2010
@@ -3969,7 +3969,7 @@
 //    structures.
 //
 //    Cyrus Harrison, Thu Mar 14 15:16:43 PDT 2013
-//    Support species names from silo species objects. 
+//    Support species names from silo species objects.
 //
 // ****************************************************************************
 void
@@ -4009,13 +4009,13 @@
             {
                 if (ms->repr_block_idx >= ms->nspec)
                 {
-                    debug1 << "Invalidating species \"" << multimatspecies_names[i] 
+                    debug1 << "Invalidating species \"" << multimatspecies_names[i]
                            << "\" since repr_block_idx (" << ms->repr_block_idx
                            << ") >= nspec (" << ms->nspec << ")" << endl;
                     valid_var = false;
                 }
                 else
-                { 
+                {
                     meshnum = ms->repr_block_idx;
                     mb_specname  = ms_ent->GenerateName(meshnum);
                 }
@@ -4025,7 +4025,7 @@
                 meshnum++;
                 if (meshnum >= ms->nspec)
                 {
-                    debug1 << "Invalidating species \"" << multimatspecies_names[i] 
+                    debug1 << "Invalidating species \"" << multimatspecies_names[i]
                            << "\" since all its blocks are EMPTY." << endl;
                     valid_var = false;
                     break;
@@ -4251,7 +4251,7 @@
 //      md       The meta-data object to put information into.
 //
 //  Programmer:  Mark C. Miller (Re-factored from orig. of Hank Childs)
-//  Creation:    June 18, 2009 
+//  Creation:    June 18, 2009
 //
 //  Modifications:
 //    Note: If you are looking for modification comments prior to re-factor,
@@ -4402,7 +4402,7 @@
                 ndir++;
             }
         }
-          
+
         delete [] searchpath_str;
     }
 
@@ -4494,7 +4494,7 @@
 //    Changed MPI_COMM_WORLD to VISIT_MPI_COMM
 //
 //    Brad Whitlock, Fri Mar 16 11:53:10 PDT 2007
-//    Make sure that SelectAll is called on the metadata so the atts and 
+//    Make sure that SelectAll is called on the metadata so the atts and
 //    attVectors that it contains will figure into the message size.
 //
 //    Mark C. Miller, Tue Apr 15 10:24:59 PDT 2008
@@ -4612,10 +4612,10 @@
 //  Method:  avtSiloFileFormat::StoreMultimeshInfo
 //
 //  Purpose: Update plugin's cache of multimesh variables and names used in
-//           facilitating matching variable to mesh 
+//           facilitating matching variable to mesh
 //
 //  Programmer:  Mark C. Miller (moved from ReadDir)
-//  Creation:    June 26, 2006 
+//  Creation:    June 26, 2006
 //
 //  Modifications:
 //    Mark C. Miller, Thu Jun 18 20:59:24 PDT 2009
@@ -4694,7 +4694,7 @@
                             AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION, -1, -1);
     if (*vr != NULL && !groupInfo.haveGroups)
     {
-        // The only way to get into this state is if we have selected 
+        // The only way to get into this state is if we have selected
         // "treatAllDBsAsTimeVarying".  If that's the case, the domain boundary
         // info is being re-used (incorrectly) and we decide not to use
         // the group info.
@@ -4741,12 +4741,12 @@
         EXCEPTION1(InvalidFilesException,
                    "Could not obtain Silo Table of Contents when looking for "
                    " decomposed mesh type.");
-    
+
     stringVector mmeshes;
-    int nmmesh = toc->nmultimesh;    
+    int nmmesh = toc->nmultimesh;
     for (int i = 0 ; i < nmmesh ; i++)
         mmeshes.push_back(toc->multimesh_names[i]);
-        
+
     // loop over meshes and look for first non empty
     for (int i = 0 ; i < nmmesh && res == AVT_UNKNOWN_MESH; i++)
     {
@@ -4773,7 +4773,7 @@
             DBFreeMultimesh(mm);
         }
     }
-    
+
     debug4 << "avtSiloFileFormat::FindDecomposedMeshType result = " << res << endl;
     // toc points to internal structure, so we do not need to free it.
     // set current dir back to where we were before this method
@@ -4808,7 +4808,7 @@
 //    Jeremy Meredith and Hank Childs, Thu Nov 20 15:28:24 PST 2003
 //    Do not try to re-read domain connectivity if it has already been
 //    cached.  This provides a nice speedup when changing time steps.  It also
-//    avoids a bug where changing time steps could cause problems because 
+//    avoids a bug where changing time steps could cause problems because
 //    the processors with no data don't get back to this function anyway.
 //
 //    Mark C. Miller, Wed Nov 29 14:56:26 PST 2006
@@ -4817,7 +4817,7 @@
 //
 //    Mark C. Miller, Mon Jan 22 22:09:01 PST 2007
 //    Changed MPI_COMM_WORLD to VISIT_MPI_COMM
-// 
+//
 //    Hank Childs, Mon Oct  8 13:01:31 PDT 2007
 //    Added an argument to force the operation.
 //
@@ -4826,7 +4826,7 @@
 //    are streaming, not about whether we are doing dynamic load balancing.
 //    And the two are no longer synonymous.
 //
-//    Added call to FindDecomposedMeshType() to help with creating the 
+//    Added call to FindDecomposedMeshType() to help with creating the
 //    correct type of domain boundries object.
 //
 //    Hank Childs, Wed Dec 22 15:14:33 PST 2010
@@ -4835,14 +4835,14 @@
 // ****************************************************************************
 
 void
-avtSiloFileFormat::GetConnectivityAndGroupInformation(DBfile *dbfile, 
+avtSiloFileFormat::GetConnectivityAndGroupInformation(DBfile *dbfile,
                                                       bool force)
 {
     //
     // This routine is not implemented for streaming.  We declared earlier that
     // the Silo format can never do streaming.  And yet here we are doing
-    // streaming.  This means we are likely pulling out a single chunk of 
-    // data.  If that's the case, we don't need the conn and group info.  
+    // streaming.  This means we are likely pulling out a single chunk of
+    // data.  If that's the case, we don't need the conn and group info.
     // So just return.
     //
     if (doingStreaming)
@@ -4925,7 +4925,7 @@
 #endif
 
     //
-    // If we found connectivity information, go ahead and create the 
+    // If we found connectivity information, go ahead and create the
     // appropriate data structure and register it.
     //
     if (!useLocalDomainBoundries &&
@@ -5039,12 +5039,12 @@
 
 void
 avtSiloFileFormat::GetConnectivityAndGroupInformationFromFile(DBfile *dbfile,
-               int &ndomains, int *&nneighbors, int *&extents, int &lneighbors, 
+               int &ndomains, int *&nneighbors, int *&extents, int &lneighbors,
                int *&neighbors, int &numGroups, int *&groupIds)
 {
     bool needGroupInfo = true;
     bool needConnectivityInfo = !avtDatabase::OnlyServeUpMetaData();
-   
+
     //
     // We can read in the connectivity info through this variable.  We cannot
     // assume its existence, though.
@@ -5417,7 +5417,7 @@
 //  Modifications:
 //
 //    Cyrus Harrison, Thu Feb 14 11:26:40 PST 2008
-//    Guard against read mask problem that occurs with treat all dbs as time 
+//    Guard against read mask problem that occurs with treat all dbs as time
 //    varying.
 //
 //    Cyrus harrison, Fri Oct  9 14:40:02 PDT 2009
@@ -5437,17 +5437,17 @@
     // loop indices
     int i,j;
 
-    // guard against improper read mask that occurs when treat all dbs as 
-    // time varying is enabled. 
-    long prev_read_mask = DBGetDataReadMask();
-    DBSetDataReadMask(prev_read_mask | DBMMADJNodelists | DBMMADJZonelists);
+    // guard against improper read mask that occurs when treat all dbs as
+    // time varying is enabled.
+    long prev_read_mask = DBGetDataReadMask2();
+    DBSetDataReadMask2(prev_read_mask | DBMMADJNodelists | DBMMADJZonelists);
 
     // Get the MultiMeshAdjacency object
     DBmultimeshadj *mmadj_obj = DBGetMultimeshadj(dbfile,
                                                   "Domain_Decomposition",
                                                   0,NULL);
     // restore prev read mask
-    DBSetDataReadMask(prev_read_mask);
+    DBSetDataReadMask2(prev_read_mask);
     bool ok = true;
     // Make sure we only have structured meshes.
     DBReadVar(dbfile, "NumDomains", &ndomains);
@@ -5489,7 +5489,7 @@
         // adj object neighbors array, back array and the node lists,
         // and fill "extents" from extents info from the node lists.
 
-        // Note: Silo's MultiMesh Adjacency Object supports unstructured 
+        // Note: Silo's MultiMesh Adjacency Object supports unstructured
         // and point meshes - but so far we only support structured meshes.
 
         int nnodelists = mmadj_obj->lneighbors;
@@ -5740,7 +5740,7 @@
     }
 
     int  len = 0;
-    while ((isalnum(*s) || *s == '_' || (allowSlash && *s == '/')) 
+    while ((isalnum(*s) || *s == '_' || (allowSlash && *s == '/'))
            && *s != '\0')
     {
         word[len] = *s;
@@ -5880,8 +5880,8 @@
     double  *extents_to_use = NULL;
     bool hideFromGUI;
 
-    long mask = DBGetDataReadMask();
-    DBSetDataReadMask(mask|DBCSGMZonelist|DBCSGZonelistZoneNames);
+    long mask = DBGetDataReadMask2();
+    DBSetDataReadMask2(mask|DBCSGMZonelist|DBCSGZonelistZoneNames);
 
     string mb_csgname = "";
     for (i = 0; i < mm->nblocks; i++)
@@ -5952,7 +5952,7 @@
         DBFreeCsgmesh(csgm);
 
     }
-    DBSetDataReadMask(mask);
+    DBSetDataReadMask2(mask);
 
 
     // a value for meshnum of -1 at this point indicates
@@ -6001,11 +6001,11 @@
 // ****************************************************************************
 //  Method: avtSiloFileFormat::GetNodelistsVar
 //
-//  Purpose: Return scalar variable representing (enumerated scalar) nodelists 
+//  Purpose: Return scalar variable representing (enumerated scalar) nodelists
 //           meshes
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   March 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   March 18, 2008
 //
 //  Modifications:
 //    Mark C. Miller, Tue Apr 15 19:53:08 PDT 2008
@@ -6023,7 +6023,7 @@
 //    Mark C. Miller, Tue Mar  3 19:33:23 PST 2009
 //    Added logic to get blockNum from groupInfo before attempting to use
 //    special vtk array.
-// 
+//
 //    Mark C. Miller, Thu Apr 12 23:08:49 PDT 2012
 //    Replaced vtkFloatArray with vtkBitArray and support of arbitrarily
 //    large numbers of nodelists
@@ -6100,7 +6100,7 @@
     if (blockNum == -1)
     {
         char msg[256];
-        SNPRINTF(msg, sizeof(msg), "Cannot find obtain block number " 
+        SNPRINTF(msg, sizeof(msg), "Cannot find obtain block number "
             "on mesh \"%s\" for domain %d to paint Nodelists variable", meshName.c_str(), domain);
         EXCEPTION1(ImproperUseException, msg);
     }
@@ -6127,7 +6127,7 @@
 
     //
     // Iterate over all nodesets for this block, finding those that have
-    // 'windows' on this block. 
+    // 'windows' on this block.
     //
     const vector<int> &windowsOnThisBlock = nlBlockToWindowsMap[blockNum];
     for (i = 0; i < windowsOnThisBlock.size(); i += 7)
@@ -6149,7 +6149,7 @@
         isec[3] = winExtents[3] < group_max_idx[1] ? winExtents[3] : group_max_idx[1];
         isec[4] = winExtents[4] > group_min_idx[2] ? winExtents[4] : group_min_idx[2];
         isec[5] = winExtents[5] < group_max_idx[2] ? winExtents[5] : group_max_idx[2];
-                    
+
         // shift back to domain logical coords
         isec[0] -= base_index[0];
         isec[1] -= base_index[0];
@@ -6158,9 +6158,9 @@
         isec[4] -= base_index[2];
         isec[5] -= base_index[2];
 
-        // For 2D, ensure we enter outermost loop, below, for one iteration 
+        // For 2D, ensure we enter outermost loop, below, for one iteration
         if (dims[2] == 0) isec[5] = isec[4] = 0;
-                    
+
         //
         // We've got a block window that overlaps with the current domain's
         // extents. This mean's the domain contains nodes that are part of
@@ -6184,10 +6184,10 @@
 // ****************************************************************************
 //  Function: compare_node_ids
 //
-//  Purpose: Callback for qsort calls to sort vector of nodes of a face. 
+//  Purpose: Callback for qsort calls to sort vector of nodes of a face.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 19, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   December 19, 2008
 //
 //  Modifications
 //    Mark C. Miller, Fri Mar 20 11:05:22 PDT 2009
@@ -6217,13 +6217,13 @@
 }
 
 // ****************************************************************************
-//  Function: compare_ev_pair 
+//  Function: compare_ev_pair
 //
-//  Purpose: Callback for qsort calls to sort vector of elemid/elemvalue 
+//  Purpose: Callback for qsort calls to sort vector of elemid/elemvalue
 //           meshes
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 19, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   December 19, 2008
 // ****************************************************************************
 
 typedef struct {int id; int val;} ev_pair_t;
@@ -6241,7 +6241,7 @@
 
 //
 // ****************************************************************************
-//  Function: PaintNodesForAnnotIntFacelist 
+//  Function: PaintNodesForAnnotIntFacelist
 //
 //  Purpose: Traverse a zonelist in edge- or face-centered order and paint
 //           values into node-centered variable on nodes associated with
@@ -6257,8 +6257,8 @@
 //  faces or edges we've already seen so we don't wind up counting them twice and
 //  screwing up the faceIdx or edgeIdx value.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 19, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   December 19, 2008
 //
 //  Modifications:
 //    Mark C. Miller, Sat Dec 20 08:31:29 PST 2008
@@ -6296,8 +6296,8 @@
                 // each edge is represented by 2 node ids in the zonelist's
                 // nodelist. Note that we are using counterclockwise order
                 // which is consistent with right-hand-rule for normal towards
-                // the eye-point and is also consistent with Silo user's 
-                // manual for 2D meshes. 
+                // the eye-point and is also consistent with Silo user's
+                // manual for 2D meshes.
                 //
                 int nedges = 0;
                 int edge[4][2];
@@ -6327,7 +6327,7 @@
                     }
                 }
                 nlIdx += zl->shapesize[seg];
-            
+
                 for (int i = 0; i < nedges; i++)
                 {
                     bool unseenEdge = false;
@@ -6505,7 +6505,7 @@
                         face[3][0] = zl->nodelist[nlIdx+1];
                         face[3][1] = zl->nodelist[nlIdx+2];
                         face[3][2] = zl->nodelist[nlIdx+6];
-                        face[3][3] = zl->nodelist[nlIdx+5]; 
+                        face[3][3] = zl->nodelist[nlIdx+5];
                         face[4][0] = zl->nodelist[nlIdx+2];
                         face[4][1] = zl->nodelist[nlIdx+3];
                         face[4][2] = zl->nodelist[nlIdx+7];
@@ -6518,7 +6518,7 @@
                     }
                 }
                 nlIdx += zl->shapesize[seg];
-            
+
                 for (int i = 0; i < nfaces; i++)
                 {
                     bool unseenFace = false;
@@ -6619,11 +6619,11 @@
 // ****************************************************************************
 //  Method: avtSiloFileFormat::GetAnnotIntNodelistsVar
 //
-//  Purpose: Return scalar variable representing (enumerated scalar) nodelists 
+//  Purpose: Return scalar variable representing (enumerated scalar) nodelists
 //           meshes based on contents of ANNOTATION_INT object.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   December 18, 2008
 //
 //  Modifications:
 //    Mark C. Miller, Wed Feb 25 17:36:51 PST 2009
@@ -6706,7 +6706,7 @@
     for (i = 0; i < ai->nelems; i++)
     {
         int len = strlen(ai->elemnames[i]);
-        if (listsname == "AnnotInt_Nodelists" && 
+        if (listsname == "AnnotInt_Nodelists" &&
             strncmp("_node",&(ai->elemnames[i][len-5]),5) == 0)
         {
             for (int j = 0; j < ai->elemlengths[i]; j++)
@@ -6716,7 +6716,7 @@
                 elemidv.push_back(idv);
             }
         }
-        else if (listsname == "AnnotInt_Facelists" && 
+        else if (listsname == "AnnotInt_Facelists" &&
             strncmp("_face",&(ai->elemnames[i][len-5]),5) == 0)
         {
             for (int j = 0; j < ai->elemlengths[i]; j++)
@@ -6750,7 +6750,7 @@
         //
 
         //
-        // Use mesh helper func. to determine file and mesh object name. 
+        // Use mesh helper func. to determine file and mesh object name.
         //
         int type;
         string directory_mesh;
@@ -6762,9 +6762,9 @@
         //
         // Read the mesh header and just the zonelist for it.
         //
-        long oldMask = DBSetDataReadMask(DBUMZonelist|DBZonelistInfo);
+        long oldMask = DBSetDataReadMask2(DBUMZonelist|DBZonelistInfo);
         DBucdmesh  *um = DBGetUcdmesh(domain_file, directory_mesh.c_str());
-        DBSetDataReadMask(oldMask);
+        DBSetDataReadMask2(oldMask);
 
         if (um == NULL)
         {
@@ -6795,7 +6795,7 @@
 // ****************************************************************************
 //  Method: avtSiloFileFormat::GetMrgTreeNodelistsVar
 //
-//  Purpose: Return scalar variable representing (enumerated scalar) nodelists 
+//  Purpose: Return scalar variable representing (enumerated scalar) nodelists
 //           of meshes based on contents of MRG Tree nodesets. Currently, this
 //           is implemented only for UCD meshes and only for NODEsets.
 //
@@ -6853,9 +6853,9 @@
     GetMeshHelper(&domain, meshName.c_str(), 0, 0, &domain_file, domain_mesh);
 
     // Only get the mesh header information, none of the problem sized data.
-    long oldMask = DBSetDataReadMask(0x0);
+    long oldMask = DBSetDataReadMask2(0x0);
     DBucdmesh  *um = DBGetUcdmesh(domain_file, domain_mesh.c_str());
-    DBSetDataReadMask(oldMask);
+    DBSetDataReadMask2(oldMask);
     if (!um)
     {
         debug3 << "Unable to get mesh \"" << meshName << "\" for domain " << domain << endl;
@@ -6879,7 +6879,7 @@
     }
     if (DBSetCwr(mrgt, listsname.substr(0,8).c_str()) < 0)
     {
-        debug3 << "MRG Tree \"" << mrgtnm_abspath << "\" for domain " << domain 
+        debug3 << "MRG Tree \"" << mrgtnm_abspath << "\" for domain " << domain
                << " has no top node named \"" << listsname.substr(0,8) << endl;
         DBFreeMrgtree(mrgt);
         return nlvar;
@@ -7010,7 +7010,7 @@
     debug5 << "Reading in from toc " << filenames[tocIndex] << endl;
 
     //
-    // Get the file handle, throw an exception if it hasn't been opened 
+    // Get the file handle, throw an exception if it hasn't been opened
     //
     DBfile *dbfile = GetFile(tocIndex);
 
@@ -7078,7 +7078,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_var;
@@ -7130,7 +7130,7 @@
 //  Modifications:
 //
 //    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
-//    vtkVectors has been deprecated in VTK 4.0, use vtkDataArray 
+//    vtkVectors has been deprecated in VTK 4.0, use vtkDataArray
 //    and vtkFloatArray instead.
 //
 //    Hank Childs, Fri May 17 14:59:39 PDT 2002
@@ -7225,7 +7225,7 @@
     {
         if (mv == NULL)
         {
-            GetMultiVar("", var, &mv_ent); 
+            GetMultiVar("", var, &mv_ent);
             if(mv_ent != NULL)
                 mv = mv_ent->DataObject();
         }
@@ -7249,7 +7249,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_var;
@@ -7285,12 +7285,12 @@
 // ****************************************************************************
 // Method: CopyUcdVar
 //
-// Purpose: 
+// Purpose:
 //   Copies data from a ucdvar into a new vtkDataArray.
 //
 // Arguments:
 //
-// Returns:    
+// Returns:
 //
 // Note:       I moved this code from GetUcdVar and I templated it.
 //
@@ -7298,7 +7298,7 @@
 // Creation:   Fri Aug  7 10:19:52 PDT 2009
 //
 // Modifications:
-//   
+//
 //    Mark C. Miller, Mon Oct 19 20:23:08 PDT 2009
 //    Replaced skipping logic (old way) with remapping logic for arb.
 //    polyhedral meshes.
@@ -7323,7 +7323,7 @@
     int j, k, n, cnt;
 
     //
-    // Handle remapping data to due zones that have been decomposed. 
+    // Handle remapping data to due zones that have been decomposed.
     //
     int nvtkcomps = uv->nvals==2?3:uv->nvals;
     vtkvar->SetNumberOfComponents(nvtkcomps);
@@ -7563,7 +7563,7 @@
 // ****************************************************************************
 // Method: CopyQuadVectorVar
 //
-// Purpose: 
+// Purpose:
 //   Copy quadvar vectors into a vtkDataArray.
 //
 // Arguments:
@@ -7698,7 +7698,7 @@
 // ****************************************************************************
 // Method: CopyPointVectorVar
 //
-// Purpose: 
+// Purpose:
 //   Copy Silo point data into a vtkDataArray.
 //
 // Arguments:
@@ -7715,7 +7715,7 @@
 //
 //    Mark C. Miller, Tue Oct 20 16:50:41 PDT 2009
 //    Made it static.
-//   
+//
 //    Kathleen Bonnell, Thu May  6 15:36:11 PDT 2010
 //    Fix error in vector dimensionality test.
 //
@@ -7844,7 +7844,7 @@
 //    Jeremy Meredith, Mon Dec 29 16:57:31 EST 2008
 //    Can't delete meshLocation here because it's used after the function
 //    returns in most cases.  Alas, can't defer to caller, because caller
-//    doesn't necessarily have a pointer to meshLocation (i.e. 
+//    doesn't necessarily have a pointer to meshLocation (i.e.
 //    directory_mesh might point to meshlocation+N, so even if you
 //    didn't allocate directory_mesh, you can't delete it in the caller
 //    by deleting directory_mesh -- it's not the same chunk of memory
@@ -7946,7 +7946,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     const char *mesh_dirname = Dirname(mesh);
@@ -7985,8 +7985,8 @@
 //    Mark C. Miller, Mon Feb 23 12:02:24 PST 2004
 //    Changed call to OpenFile() to GetFile()
 //
-//    Kathleen Bonnell, Tue Feb  8 17:00:46 PST 2005 
-//    Added domain to args for GetQuadMesh. 
+//    Kathleen Bonnell, Tue Feb  8 17:00:46 PST 2005
+//    Added domain to args for GetQuadMesh.
 //
 //    Mark C. Miller, Mon Feb 14 20:28:47 PST 2005
 //    Added test for DB_QUAD_CURV/RECT for valid type
@@ -8023,7 +8023,7 @@
 
 vtkDataSet *
 avtSiloFileFormat::GetMesh(int domain, const char *m)
-{ 
+{
     int type;
     string directory_mesh;
     DBmultimesh *mm;
@@ -8096,7 +8096,7 @@
 // ****************************************************************************
 // Function: CreateDataArray
 //
-// Purpose: 
+// Purpose:
 //   Creates a vtkDataArray suitable for the given Silo type. Also return the
 //   size of 1 element.
 //
@@ -8106,13 +8106,13 @@
 //
 // Returns:    A suitable vtkDataArray instance.
 //
-// Note:       
+// Note:
 //
 // Programmer: Brad Whitlock
 // Creation:   Fri Aug  7 10:39:35 PDT 2009
 //
 // Modifications:
-//   
+//
 //    Mark C. Miller, Tue Jan 12 17:49:18 PST 2010
 //    Made it it able to push data into the resultant vtkDataArray. Added
 //    support for DB_LONG_LONG.
@@ -8120,7 +8120,7 @@
 
 static vtkDataArray *
 CreateDataArray(int silotype, void *data, int numvals)
-{ 
+{
     vtkDataArray *da = 0;
     switch(silotype)
     {
@@ -8187,7 +8187,7 @@
 // ****************************************************************************
 // Method: ConvertToFloat
 //
-// Purpose: 
+// Purpose:
 //   Converts the input array to float, returning a new float array that must
 //   be freed by the caller. The exception is if the input was already float.
 //   In that case, the input array is returned unmodified.
@@ -8199,25 +8199,25 @@
 //
 // Returns:    A float array.
 //
-// Note:       
+// Note:
 //
 // Programmer: Brad Whitlock
 // Creation:   Fri Aug  7 10:51:03 PDT 2009
 //
 // Modifications:
-//   
+//
 //    Mark C. Miller, Tue Jul 20 19:21:34 PDT 2010
 //    Added support for LONG LONG types.
 // ****************************************************************************
 
 static float *
 ConvertToFloat(int silotype, void *data, int nels)
-{ 
+{
     float *retval = 0;
 
     if (!data) return 0;
     if (nels <= 0) return 0;
-    
+
     switch(silotype)
     {
     case DB_DOUBLE:
@@ -8291,7 +8291,7 @@
 //
 //    Mark C. Miller, Thu Sep  2 21:06:06 PDT 2010
 //    Replace new with malloc. Doh? We're using the data to populate a DBucdvar
-//    which is later going to be free'd by a DBFreeUcdvar() which assumes 
+//    which is later going to be free'd by a DBFreeUcdvar() which assumes
 //    it was malloc'd.
 //
 //    Mark C. Miller, Wed Sep  8 14:09:33 PDT 2010
@@ -8332,12 +8332,12 @@
             if (uv->mixvals)
             {
                 for (j = 0; j < mat->GetMixlen(); j++)
-                    newmixvals[i][j] = ((T**)uv->mixvals)[i][0]; 
+                    newmixvals[i][j] = ((T**)uv->mixvals)[i][0];
             }
             else
             {
                 for (j = 0; j < mat->GetMixlen(); j++)
-                    newmixvals[i][j] = ((T**)uv->vals)[i][0]; 
+                    newmixvals[i][j] = ((T**)uv->vals)[i][0];
             }
         }
     }
@@ -8457,7 +8457,7 @@
 //    mesh's zonelist to perform the traversal.
 // ****************************************************************************
 void
-avtSiloFileFormat::ExpandUcdvar(DBucdvar *uv,  
+avtSiloFileFormat::ExpandUcdvar(DBucdvar *uv,
     const char *vname, const char *tvn, int domain)
 {
     // Obtain the avtMaterial object associated with the mesh this
@@ -8496,7 +8496,7 @@
     // For node centered variables, we also need the mesh's zonelist.
     // Because VisIt's generic db always issues the associated GetMesh()
     // BEFORE issuing GetVar(), we can safely assume the mesh must be in
-    // the cache and look ONLY there for it. Failure to obtain it is a 
+    // the cache and look ONLY there for it. Failure to obtain it is a
     // problem we cannot recover from.
     vtkUnstructuredGrid  *ugrid = 0;
     if (uv->centering == DB_NODECENT)
@@ -8522,7 +8522,7 @@
     {
         char msg[256];
         SNPRINTF(msg, sizeof(msg), "Unable to determine material indices "
-            "variable \"%s\" is restricted to", vname); 
+            "variable \"%s\" is restricted to", vname);
         EXCEPTION1(InvalidVariableException, msg);
     }
 
@@ -8560,7 +8560,7 @@
 #ifdef DB_DTPTR
     uv->vals = (DB_DTPTR**) newvals;
 #else
-    uv->vals = (float**) newvals;
+    uv->vals = (void**) newvals;
 #endif
     if (uv->mixvals)
     {
@@ -8572,7 +8572,7 @@
 #ifdef DB_DTPTR
     uv->mixvals = (DB_DTPTR**) newmixvals;
 #else
-    uv->mixvals = (float**) newmixvals;
+    uv->mixvals = (void**) newmixvals;
 #endif
 }
 
@@ -8609,7 +8609,7 @@
 //    Account for funny data files that write out all NULL mixval arrays.
 //
 //    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
-//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray 
+//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray
 //    and vtkFloatArray instead.
 //
 //    Hank Childs, Fri Jul  5 15:03:23 PDT 2002
@@ -8713,7 +8713,7 @@
 
         avtMixedVariable *mv = new avtMixedVariable(mixvals, uv->mixlen, tvn);
         void_ref_ptr vr = void_ref_ptr(mv, avtMixedVariable::Destruct);
-        cache->CacheVoidRef(tvn, AUXILIARY_DATA_MIXED_VARIABLE, timestep, 
+        cache->CacheVoidRef(tvn, AUXILIARY_DATA_MIXED_VARIABLE, timestep,
                             domain, vr);
 
         if(mixvals != (float *)uv->mixvals[0])
@@ -8758,7 +8758,7 @@
 //    Account for funny data files that write out all NULL mixval arrays.
 //
 //    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
-//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray 
+//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray
 //    and vtkFloatArray instead.
 //
 //    Eric Brugger, Thu May 23 14:23:23 PDT 2002
@@ -8874,7 +8874,7 @@
 
         avtMixedVariable *mv = new avtMixedVariable(mixvals, qv->mixlen, tvn);
         void_ref_ptr vr = void_ref_ptr(mv, avtMixedVariable::Destruct);
-        cache->CacheVoidRef(tvn, AUXILIARY_DATA_MIXED_VARIABLE, timestep, 
+        cache->CacheVoidRef(tvn, AUXILIARY_DATA_MIXED_VARIABLE, timestep,
                             domain, vr);
 
         if(mixvals != (float*)qv->mixvals[0])
@@ -8912,7 +8912,7 @@
 //    Sped up routine.
 //
 //    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
-//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray 
+//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray
 //    and vtkFloatArray instead.
 //
 //    Brad Whitlock, Fri Aug  7 10:38:34 PDT 2009
@@ -8965,7 +8965,7 @@
 //  Purpose: Gets a CSG variable
 //
 //  Programmer: Mark C. Miller
-//  Creation:   December 3, 2006 
+//  Creation:   December 3, 2006
 //
 //  Modifications:
 //    Brad Whitlock, Fri Aug  7 11:01:59 PDT 2009
@@ -8996,7 +8996,7 @@
     //
     // Populate the variable.  This assumes it is a scalar variable.
     //
-    vtkDataArray *scalars = CreateDataArray(csgv->datatype, (void*)csgv->vals[0], csgv->nels); 
+    vtkDataArray *scalars = CreateDataArray(csgv->datatype, (void*)csgv->vals[0], csgv->nels);
     csgv->vals[0] = 0; // vtkDataArray no owns the data.
     DBFreeCsgvar(csgv);
 
@@ -9006,14 +9006,14 @@
 // ****************************************************************************
 // Method: CopyUnstructuredMeshCoordinates
 //
-// Purpose: 
+// Purpose:
 //   This function copies ucdmesh coordinates into an interleaved vtkPoints array.
 //
 // Arguments:
 //   T : The destination array.
 //   um : The ucdmesh.
 //
-// Returns:    
+// Returns:
 //
 // Note:       I moved this code from avtSiloFileFormat::GetUnstructuredMesh
 //             and templated it.
@@ -9022,7 +9022,7 @@
 // Creation:   Thu Aug  6 11:59:25 PDT 2009
 //
 // Modifications:
-//   
+//
 //    Mark C. Miller, Tue Oct 20 16:51:50 PDT 2009
 //    Made it static.
 // ****************************************************************************
@@ -9130,11 +9130,11 @@
     tmp.nels = lgzoneno;
     tmp.nvals = 1;
 #ifdef DB_DTPTR
-    tmp.vals = (DB_DTPTR**) new DB_DTPTR*[1]; 
-    tmp.vals[0] = (DB_DTPTR*) gzoneno; 
+    tmp.vals = (DB_DTPTR**) new DB_DTPTR*[1];
+    tmp.vals[0] = (DB_DTPTR*) gzoneno;
 #else
-    tmp.vals = (float**) new float*[1]; 
-    tmp.vals[0] = (float*) gzoneno; 
+    tmp.vals = (void**) new float*[1];
+    tmp.vals[0] = (float*) gzoneno;
 #endif
 
     vtkDataArray *arr;
@@ -9157,7 +9157,7 @@
     // so that it can be obtained through the GetAuxiliaryData call
     //
     void_ref_ptr vr = void_ref_ptr(arr, avtVariableCache::DestructVTKObject);
-    cache->CacheVoidRef(meshname, AUXILIARY_DATA_GLOBAL_ZONE_IDS, timestep, 
+    cache->CacheVoidRef(meshname, AUXILIARY_DATA_GLOBAL_ZONE_IDS, timestep,
         domain, vr);
 }
 
@@ -9321,10 +9321,10 @@
 //    Hank Childs, Thu Apr 26 16:09:39 PDT 2001
 //    Sped up routine.
 //
-//    Kathleen Bonnell, Wed May 23 15:41:14 PDT 2001 
-//    Added call to TranslateSiloPyramidToVTKPyramid. 
+//    Kathleen Bonnell, Wed May 23 15:41:14 PDT 2001
+//    Added call to TranslateSiloPyramidToVTKPyramid.
 //
-//    Kathleen Bonnell, Tue Jun 12 14:34:02 PDT 2001 
+//    Kathleen Bonnell, Tue Jun 12 14:34:02 PDT 2001
 //    Added code to determine and set a ghost-levels array.
 //
 //    Hank Childs, Thu Sep 20 16:08:21 PDT 2001
@@ -9365,7 +9365,7 @@
 //    that have arbitrary polyhedra embedded in an ordinary DBzonelist
 //
 //    Hank Childs, Wed Mar  9 07:53:16 PST 2005
-//    Do not send a C-array into a C++-construct.  It will eventually call 
+//    Do not send a C-array into a C++-construct.  It will eventually call
 //    "delete" when it should call "free".
 //
 //    Jeremy Meredith, Tue Jun  7 08:32:46 PDT 2005
@@ -9394,7 +9394,7 @@
 //
 //    Mark C. Miller, Tue Jan 12 17:53:17 PST 2010
 //    Use CreateDataArray for global node numbers and handle long long case
-//    as well. Vary interface to HandleGlobalZoneIds for versions of Silo. 
+//    as well. Vary interface to HandleGlobalZoneIds for versions of Silo.
 //
 //    Eric Brugger, Thu May 27 16:00:03 PDT 2010
 //    I added a call to a newly written method that remaps the zoneno
@@ -9459,7 +9459,7 @@
         EXCEPTION1(InvalidVariableException, "The Silo reader supports only "
             "float and double precision coordinates in unstructured meshes.");
     }
-    
+
     //
     // We already got the facelist read in free of charge.  Let's use it.
     // This is done before constructing the connectivity because this is used
@@ -9477,7 +9477,7 @@
                              sfl->nshapes, sfl->shapecnt, sfl->shapesize,
                              sfl->zoneno, sfl->origin);
         void_ref_ptr vr = void_ref_ptr(fl, avtFacelist::Destruct);
-        cache->CacheVoidRef(mesh, AUXILIARY_DATA_EXTERNAL_FACELIST, timestep, 
+        cache->CacheVoidRef(mesh, AUXILIARY_DATA_EXTERNAL_FACELIST, timestep,
                             domain, vr);
     }
 
@@ -9488,12 +9488,12 @@
     {
 #ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,7,1)
-        vtkDataArray *arr = CreateDataArray(um->gnznodtype, um->gnodeno, um->nnodes); 
+        vtkDataArray *arr = CreateDataArray(um->gnznodtype, um->gnodeno, um->nnodes);
 #else
-        vtkDataArray *arr = CreateDataArray(DB_INT, um->gnodeno, um->nnodes); 
+        vtkDataArray *arr = CreateDataArray(DB_INT, um->gnodeno, um->nnodes);
 #endif
 #else
-        vtkDataArray *arr = CreateDataArray(DB_INT, um->gnodeno, um->nnodes); 
+        vtkDataArray *arr = CreateDataArray(DB_INT, um->gnodeno, um->nnodes);
 #endif
         um->gnodeno = 0; // vtkDataArray now owns the data.
 
@@ -9502,7 +9502,7 @@
         // so that it can be obtained through the GetAuxiliaryData call
         //
         void_ref_ptr vr = void_ref_ptr(arr, avtVariableCache::DestructVTKObject);
-        cache->CacheVoidRef(mesh, AUXILIARY_DATA_GLOBAL_NODE_IDS, timestep, 
+        cache->CacheVoidRef(mesh, AUXILIARY_DATA_GLOBAL_NODE_IDS, timestep,
                             domain, vr);
     }
 
@@ -9514,7 +9514,7 @@
     vtkDataSet *rv = NULL;
     if (um->zones != NULL)
     {
-        vtkUnstructuredGrid  *ugrid = vtkUnstructuredGrid::New(); 
+        vtkUnstructuredGrid  *ugrid = vtkUnstructuredGrid::New();
         ugrid->SetPoints(points);
         ReadInConnectivity(ugrid, um, mesh, domain);
         rv = ugrid;
@@ -9551,7 +9551,7 @@
         vtkUnstructuredGrid  *ugrid = 0;
         if (rv == 0)
         {
-            ugrid = vtkUnstructuredGrid::New(); 
+            ugrid = vtkUnstructuredGrid::New();
             ugrid->SetPoints(points);
             rv = ugrid;
         }
@@ -9611,7 +9611,7 @@
     {
         std::pair<int, vector<int> > p(it->second[i]);
         if (canonicalFaceNodes == p.second) return p.first;
-    } 
+    }
 
     return -INT_MAX;
 }
@@ -9621,7 +9621,7 @@
 //
 //  Purpose: Support method for building a DBphzonelist object from a 'normal'
 //  DBzonelist object by building canonical face ordering and then looking it
-//  and its reverse ordered (opposite normal) variant in the hash and if 
+//  and its reverse ordered (opposite normal) variant in the hash and if
 //  neither is found, adding it to the hash as a new, unique face.
 //
 //  Creation: Mark C. Miller, Wed Jul 11 10:44:42 PDT 2012
@@ -9652,7 +9652,7 @@
             if (canonicalFaceNodes[j] < canonicalFaceNodes[lowIdx])
                 lowIdx = j;
         }
-        rotate(canonicalFaceNodes.begin(),canonicalFaceNodes.begin()+lowIdx,canonicalFaceNodes.end()); 
+        rotate(canonicalFaceNodes.begin(),canonicalFaceNodes.begin()+lowIdx,canonicalFaceNodes.end());
         if (pass == 0) faceNodesF = canonicalFaceNodes;
 
         // Lookup the face
@@ -9691,7 +9691,7 @@
 //    faces properly.
 // ****************************************************************************
 
-static DBphzonelist* 
+static DBphzonelist*
 MakePHZonelistFromZonelistArbFragment(const int *nl, int shapecnt)
 {
     vector<int> nodecnt, nodelist, facecnt, facelist;
@@ -9842,7 +9842,7 @@
             }
             else
             {
-                // Some polygons representations have the shapesize be 0 and 
+                // Some polygons representations have the shapesize be 0 and
                 // each polygons # of nodes encoded as the first point ID.
                 for (j = 0 ; j < zl->shapecnt[i] ; j++)
                 {
@@ -9893,7 +9893,7 @@
         //
         // Some users store out quads as hexahedrons -- they store quad
         // (a,b,c,d) as hex (a,b,c,d,a,b,c,d).  Unfortunately, we have
-        // to detect this and account for it.  I think it is safe to 
+        // to detect this and account for it.  I think it is safe to
         // assume that if the first hex is that way, they all are.
         // Similarly, if the first hex is not that way, none of them are.
         //
@@ -9925,7 +9925,7 @@
             // of the zonelist. Record their count, indices and
             // offset into nodelist for now.
             //
-            arbZoneIdxOffs.push_back(zoneIndex); 
+            arbZoneIdxOffs.push_back(zoneIndex);
             arbZoneCounts.push_back(shapecnt);
             arbZoneNlOffs.push_back(nodelist);
             zoneIndex += shapecnt;
@@ -10144,9 +10144,9 @@
             int gzOff = arbZoneIdxOffs[i];
 
             //
-            // Create a temp. Silo DBphzonelist object to call ReadInArbConnectivity. 
+            // Create a temp. Silo DBphzonelist object to call ReadInArbConnectivity.
             //
-            DBphzonelist *phzl = 
+            DBphzonelist *phzl =
                 MakePHZonelistFromZonelistArbFragment(nl, arbZoneCounts[i]);
 
             DBphzonelist *tmpphzl = um->phzones;
@@ -10179,7 +10179,7 @@
               << " because min_index & max_index are both zero!" << endl;
     }
     else if (first < 0 || first >= numCells ||
-             last  < 0 || last  >= numCells)  
+             last  < 0 || last  >= numCells)
     {
        // bad min or max index
        debug5 << "Invalid min/max index for determining ghost zones:  "
@@ -10193,7 +10193,7 @@
         // We now know that ghost zones are present.
         //
         debug5 << "Creating ghost zones, real zones are indexed"
-               << " from " << first << " to " << last 
+               << " from " << first << " to " << last
                << " of " << numCells << " Cells." << endl;
 
         //
@@ -10223,7 +10223,7 @@
         tmp.vals = (DB_DTPTR**) new DB_DTPTR*[1];
         tmp.vals[0] = (DB_DTPTR*) gvals;
 #else
-        tmp.vals = (float**) new float*[1];
+        tmp.vals = (void**) new float*[1];
         tmp.vals[0] = (float*) gvals;
 #endif
         vector<int> noremap;
@@ -10540,7 +10540,7 @@
 //    Fixed setting of 'mingn' when a new min is found.
 //
 //    Mark C. Miller, Wed Oct 28 20:47:40 PDT 2009
-//    Adjusted interface to take DBphzonelist* as second arg instead of 
+//    Adjusted interface to take DBphzonelist* as second arg instead of
 //    DBucdmesh*.
 // ****************************************************************************
 static void
@@ -10579,7 +10579,7 @@
         int gf = sgf < 0 ? ~sgf : sgf;      // gf = global face #
         int ncnt = phzl->nodecnt[gf];       // ncnt = # nodes for this face
         if (ncnt != 2) allFacesAre2NodeEdges = false;
-        for (int ln = 0; ln < ncnt; ln++)   // ln = local node # 
+        for (int ln = 0; ln < ncnt; ln++)   // ln = local node #
         {
             int nlidx = nloffs[gf]+ln;      // nlidx = index into nodelist
             int gn = phzl->nodelist[nlidx]; // gn = global node #
@@ -10651,13 +10651,13 @@
                 topcur = (topcur==ncnt-1)?0:topcur+1;
                 botlast = botcur;
                 botcur = (botcur==0)?ncnt-1:botcur-1;
-            } 
+            }
         }
     }
     else
     {
         //
-        // Loop over edges, creating triangles using 2 nodes on the 
+        // Loop over edges, creating triangles using 2 nodes on the
         // edge and the cell center.
         //
         for (lf = 0; lf < fcnt; lf++)
@@ -10737,14 +10737,14 @@
     DBphzonelist *phzl = um->phzones;
     if (!phzl)
         return;
-    
+
     int nsdims = um->ndims;
     if (nsdims != 2 && nsdims != 3)
         return;
 
     //
     // Go ahead and add an empty avtOriginalCellNumbers array now.
-    // We'll populate it as we proceed but, if we never encounter 
+    // We'll populate it as we proceed but, if we never encounter
     // truly arbitrary zones, we'll remove it at the end because we
     // won't actually need it.
     //
@@ -10807,7 +10807,7 @@
     vector<int> floffs;
     for (i = 0, sum = 0; i < phzl->nzones; sum += phzl->facecnt[i], i++)
         floffs.push_back(sum);
-    
+
     //
     // Main loop over all zones in this phzl
     //
@@ -10911,13 +10911,13 @@
 
                 //
                 // Detect an 'opposing' face to the first; one with no nodes
-                // in common with it. Can happen only for prism or hex elements. 
+                // in common with it. Can happen only for prism or hex elements.
                 // Since a hex has no tri faces, if we encounter a tri and the
                 // first face is currently a quad, we replace it with the tri.
                 // Thus, after iterating over all faces, opposingFace will be
                 // set to something other than -INT_MAX only if we have indeed
                 // encountered a prism or a hex. Only do this for 3D.
-                // 
+                //
                 if (nsdims == 3)
                 {
                     if (firstFaceNodes[3] == -INT_MAX) // first face is a tri
@@ -10935,7 +10935,7 @@
                             if (!hasNodesInCommonWithFirst)
                             {
                                 opposingFace = sgf;
-                                for (int ln = 0; ln < ncnt; ln++)    // ln = local node # 
+                                for (int ln = 0; ln < ncnt; ln++)    // ln = local node #
                                 {
                                     int nlidx = nloffs[gf]+ln;       // nlidx = index into nodelist
                                     int gn = phzl->nodelist[nlidx];  // gn = global node #
@@ -10988,7 +10988,7 @@
             } // done iterating over faces and collecting info about this zone
 
             //
-            // Now, based on information we gathered iterating over all the 
+            // Now, based on information we gathered iterating over all the
             // faces of this zone, decide what case it is and handle it.
             //
             int nids[8];
@@ -11026,7 +11026,7 @@
                     nids[j] = *it;
                 ArbInsertTet(ugrid, nids, ocdata, cellReMap);
             }
-            else if (fcnt == 5 && uniqnodes.size() == 5 && 
+            else if (fcnt == 5 && uniqnodes.size() == 5 &&
                      num3NodeFaces == 4 && num4NodeFaces == 1)    // Pyramid
             {
                 // Get first 4 nodes from first4NodeFace
@@ -11044,7 +11044,7 @@
 
                 ArbInsertPyramid(ugrid, nids, ocdata, cellReMap);
             }
-            else if (fcnt == 5 && uniqnodes.size() == 6 && 
+            else if (fcnt == 5 && uniqnodes.size() == 6 &&
                      num3NodeFaces == 2 && num4NodeFaces == 3)    // Prism/Wedge
             {
                 // The 6 integers to specify a prism can be conceptually organized
@@ -11159,7 +11159,7 @@
                 nids[5] = firstFaceNodes[1];
                 ArbInsertWedge(ugrid, nids, ocdata, cellReMap);
             }
-            else if (fcnt == 6 && uniqnodes.size() == 8 && 
+            else if (fcnt == 6 && uniqnodes.size() == 8 &&
                      num3NodeFaces == 0 && num4NodeFaces == 6)    // Hex
             {
                 // The 8 integers to specify a hex need to be ordered such that the
@@ -11328,13 +11328,13 @@
             gvals[i] = 0;
         for (i = phzl->hi_offset+1; i < phzl->nzones; i++)
             gvals[i] = val;
-       
+
         //
         // Remap the zone-centered array based on arb-poly remapping
         // computed above.
         //
         vector<int> noremap;
-        vector<int> *remap = &noremap;    
+        vector<int> *remap = &noremap;
         if (ugrid->GetNumberOfPoints() > um->nnodes)
             remap = cellReMap;
         DBucdvar tmp;
@@ -11346,7 +11346,7 @@
         tmp.vals = (DB_DTPTR**) new DB_DTPTR*[1];
         tmp.vals[0] = (DB_DTPTR*) gvals;
 #else
-        tmp.vals = (float**) new float*[1];
+        tmp.vals = (void**) new float*[1];
         tmp.vals[0] = (float*) gvals;
 #endif
         vtkDataArray *ghostZones = CopyUcdVar<unsigned char,vtkUnsignedCharArray>(&tmp, *remap);
@@ -11411,7 +11411,7 @@
 //    Moved code from avtSiloTimeStep, added file argument to account for
 //    Silo objects distributed across multiple files.
 //
-//    Kathleen Bonnell, Tue Jun 12 14:34:02 PDT 2001 
+//    Kathleen Bonnell, Tue Jun 12 14:34:02 PDT 2001
 //    Added call to method GetQuadGhostZones.
 //
 //    Hank Childs, Tue Mar  5 16:53:16 PST 2002
@@ -11420,9 +11420,9 @@
 //    Hank Childs, Tue Jun 25 16:29:12 PDT 2002
 //    Add the base indices as field data to the VTK dataset.
 //
-//    Kathleen Bonnell, Tue Feb  8 13:41:05 PST 2005 
+//    Kathleen Bonnell, Tue Feb  8 13:41:05 PST 2005
 //    Added int arg for domain, to be used in retrieving connectivity extents
-//    for setting base_index when necessary. 
+//    for setting base_index when necessary.
 //
 //    Jeremy Meredith, Tue Jun  7 08:32:46 PDT 2005
 //    Added support for "EMPTY" domains in multi-objects.
@@ -11524,13 +11524,13 @@
     //
     if (qm->base_index[0] == 0 &&
         qm->base_index[1] == 0 &&
-        qm->base_index[2] == 0) 
+        qm->base_index[2] == 0)
     {
         void_ref_ptr vr = cache->GetVoidRef("any_mesh",
                         AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION, -1, -1);
         if (*vr != NULL)
         {
-            avtStructuredDomainBoundaries *dbi = 
+            avtStructuredDomainBoundaries *dbi =
                 (avtStructuredDomainBoundaries*)*vr;
             if (dbi != NULL)
             {
@@ -11538,7 +11538,7 @@
                 dbi->GetExtents(domain, ext);
                 arr->SetValue(0, ext[0]);
                 arr->SetValue(1, ext[2]);
-                arr->SetValue(2, ext[4]); 
+                arr->SetValue(2, ext[4]);
             }
         }
     }
@@ -11567,7 +11567,7 @@
 //
 //  Modifications:
 //
-//    Hank Childs, Wed Mar  6 15:00:21 PST 2002  
+//    Hank Childs, Wed Mar  6 15:00:21 PST 2002
 //    Added better support for 2D, since sloppy coding had caused perfectly
 //    fine 2D meshes to be tagged as bad.
 //
@@ -11583,7 +11583,7 @@
         //
         if (qm->nnodes != qm->dims[0]*qm->dims[1]*qm->dims[2])
         {
-            if (qm->dims[0] > 100000 || qm->dims[1] > 100000 
+            if (qm->dims[0] > 100000 || qm->dims[1] > 100000
                 || qm->dims[2] > 100000)
             {
                 int orig[3];
@@ -11602,7 +11602,7 @@
                     qm->dims[1] = qm->max_index[1];
                     qm->dims[2] = qm->max_index[2];
                 }
-                else if (qm->nnodes == (qm->max_index[0]+1) * 
+                else if (qm->nnodes == (qm->max_index[0]+1) *
                                    (qm->max_index[1]+1) * (qm->max_index[2]+1))
                 {
                     qm->dims[0] = qm->max_index[0]+1;
@@ -11716,7 +11716,7 @@
                     qm->dims[0] = qm->max_index[0];
                     qm->dims[1] = qm->max_index[1];
                 }
-                else if (qm->nnodes == (qm->max_index[0]+1) * 
+                else if (qm->nnodes == (qm->max_index[0]+1) *
                                        (qm->max_index[1]+1))
                 {
                     qm->dims[0] = qm->max_index[0]+1;
@@ -11778,7 +11778,7 @@
 // ****************************************************************************
 // Method: CreateCurve
 //
-// Purpose: 
+// Purpose:
 //   Creates a curve from a DBcurve.
 //
 // Arguments:
@@ -11788,7 +11788,7 @@
 //
 // Returns:    A new vtkRectilinearGrid.
 //
-// Note:       
+// Note:
 //
 // Programmer: Mark Miller
 // Creation:   Thu Aug  6 12:16:00 PDT 2009
@@ -11835,8 +11835,8 @@
 //
 //  Returns:     The vtkDataSet corresponding to mn.
 //
-//  Programmer:  Mark C. Miller 
-//  Creation:    March 1, 2006 
+//  Programmer:  Mark C. Miller
+//  Creation:    March 1, 2006
 //
 //  Modifications:
 //    Kathleen Bonnell, Mon Jul 14 14:55:48 PDT 2008
@@ -11912,7 +11912,7 @@
 //
 //  Modifications:
 //
-//    Kathleen Bonnell, Thu Nov  8 09:20:50 PST 2001 
+//    Kathleen Bonnell, Thu Nov  8 09:20:50 PST 2001
 //    Use vtkFloatArray instead of vtkScalars for rgrid coordinates in
 //    order to match VTK 4.0 API.
 //
@@ -11936,7 +11936,7 @@
             "double precision coordinates for rectilinear meshes.");
     }
 
-    vtkRectilinearGrid   *rgrid   = vtkRectilinearGrid::New(); 
+    vtkRectilinearGrid   *rgrid   = vtkRectilinearGrid::New();
 
     //
     // Populate the coordinates.  Put in 3D points with z=0 if the mesh is 2D.
@@ -12040,7 +12040,7 @@
     }
     else
     {
-        unsigned int nyz = ny * nz; 
+        unsigned int nyz = ny * nz;
         for (unsigned int k = 0; k < nz; k++)
         {
             for (unsigned int j = 0; j < ny; j++)
@@ -12090,7 +12090,7 @@
     //
     // Create the VTK objects and connect them up.
     //
-    vtkStructuredGrid    *sgrid   = vtkStructuredGrid::New(); 
+    vtkStructuredGrid    *sgrid   = vtkStructuredGrid::New();
     vtkPoints            *points  = vtkPoints::New();
     sgrid->SetPoints(points);
     points->Delete();
@@ -12151,10 +12151,10 @@
 //    to the dataset.
 //
 //  Arguments:
-//      qm       A Silo quad mesh. 
-//      ds       The vtkDataSet in which to store the ghost level information. 
+//      qm       A Silo quad mesh.
+//      ds       The vtkDataSet in which to store the ghost level information.
 //
-//  Programmer:  Kathleen Bonnell 
+//  Programmer:  Kathleen Bonnell
 //  Creation:    June 12, 2001
 //
 //  Modifications:
@@ -12162,25 +12162,25 @@
 //    I modified the routine to always store the ghost zone array in row
 //    major order.
 //
-//    Kathleen Bonnell, Wed Jul 10 16:02:56 PDT 2002 
+//    Kathleen Bonnell, Wed Jul 10 16:02:56 PDT 2002
 //    I added a field-data array that indicates the extents of the real
-//    data.  Used during ghostzone removal.  
-//    
-//    Kathleen Bonnell, Wed Jun 25 13:45:04 PDT 2003 
+//    data.  Used during ghostzone removal.
+//
+//    Kathleen Bonnell, Wed Jun 25 13:45:04 PDT 2003
 //    Allocate space for realDims via SetNumberOfValues instead of Allocate.
 //    Allocate does not set some internal values needed for later calls to
-//    GetNumberOfTuples and the like. 
-//    
+//    GetNumberOfTuples and the like.
+//
 //    Hank Childs, Fri Aug 27 17:22:19 PDT 2004
 //    Rename ghost data array.
 //
 // ****************************************************************************
 
-void 
+void
 avtSiloFileFormat::GetQuadGhostZones(DBquadmesh *qm, vtkDataSet *ds)
 {
     //
-    // Find the dimensions of the quad mesh. 
+    // Find the dimensions of the quad mesh.
     //
     int dims[3];
     dims[0] = (qm->dims[0] > 0 ? qm->dims[0] : 1);
@@ -12201,14 +12201,14 @@
 
         if (first[i] < 0 || first[i] >= dims[i])
         {
-            debug1 << "bad Index on first[" << i << "] dims is: " 
+            debug1 << "bad Index on first[" << i << "] dims is: "
                    << dims[i] << endl;
             badIndex = true;
         }
 
         if (last[i] < 0 || last[i] >= dims[i])
         {
-            debug1 << "bad Index on last[" << i << "] dims is: " 
+            debug1 << "bad Index on last[" << i << "] dims is: "
                    << dims[i] << endl;
             badIndex = true;
         }
@@ -12229,7 +12229,7 @@
         // Initialize as all ghost levels
         //
         for (int ii = 0; ii < qm->nnodes; ii++)
-            ghostPoints[ii] = true; 
+            ghostPoints[ii] = true;
 
         //
         // Set real values
@@ -12239,7 +12239,7 @@
                 for (int i = first[0]; i <= last[0]; i++)
                 {
                     int index = k*dims[1]*dims[0] + j*dims[0] + i;
-                    ghostPoints[index] = false; 
+                    ghostPoints[index] = false;
                 }
 
         //
@@ -12249,14 +12249,14 @@
         //
         unsigned char realVal = 0;
         unsigned char ghostVal = 0;
-        avtGhostData::AddGhostZoneType(ghostVal, 
+        avtGhostData::AddGhostZoneType(ghostVal,
                                        DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
         int ncells = ds->GetNumberOfCells();
         vtkIdList *ptIds = vtkIdList::New();
         vtkUnsignedCharArray *ghostCells = vtkUnsignedCharArray::New();
         ghostCells->SetName("avtGhostZones");
         ghostCells->Allocate(ncells);
- 
+
         for (int i = 0; i < ncells; i++)
         {
             ds->GetCellPoints(i, ptIds);
@@ -12268,8 +12268,8 @@
                 ghostCells->InsertNextValue(ghostVal);
             else
                 ghostCells->InsertNextValue(realVal);
- 
-        } 
+
+        }
         ds->GetCellData()->AddArray(ghostCells);
         delete [] ghostPoints;
         ghostCells->Delete();
@@ -12294,14 +12294,14 @@
 // ****************************************************************************
 // Method: CopyPointMeshCoordinates
 //
-// Purpose: 
+// Purpose:
 //   Copies DBpointmesh coordinates into an interleaved form for vtkPoints.
 //
 // Arguments:
 //   T : The destination array for the point data.
 //   pm : The source point mesh.
 //
-// Returns:    
+// Returns:
 //
 // Note:       I moved this block from avtSiloFileFormat::GetPointMesh and
 //             templated it.
@@ -12310,7 +12310,7 @@
 // Creation:   Thu Aug  6 11:48:54 PDT 2009
 //
 // Modifications:
-//   
+//
 //    Mark C. Miller, Tue Oct 20 16:51:18 PDT 2009
 //    Made it static.
 // ****************************************************************************
@@ -12436,7 +12436,7 @@
     //
     // Create the VTK objects and connect them up.
     //
-    vtkUnstructuredGrid    *ugrid   = vtkUnstructuredGrid::New(); 
+    vtkUnstructuredGrid    *ugrid   = vtkUnstructuredGrid::New();
     ugrid->SetPoints(points);
     ugrid->Allocate(pm->nels);
     vtkIdType onevertex[1];
@@ -12453,12 +12453,12 @@
     {
 #ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,7,1)
-        vtkDataArray *arr = CreateDataArray(pm->gnznodtype, pm->gnodeno, pm->nels); 
+        vtkDataArray *arr = CreateDataArray(pm->gnznodtype, pm->gnodeno, pm->nels);
 #else
-        vtkDataArray *arr = CreateDataArray(DB_INT, pm->gnodeno, pm->nels); 
+        vtkDataArray *arr = CreateDataArray(DB_INT, pm->gnodeno, pm->nels);
 #endif
 #else
-        vtkDataArray *arr = CreateDataArray(DB_INT, pm->gnodeno, pm->nels); 
+        vtkDataArray *arr = CreateDataArray(DB_INT, pm->gnodeno, pm->nels);
 #endif
         pm->gnodeno = 0; // vtkDataArray now owns the data.
 
@@ -12467,7 +12467,7 @@
         // so that it can be obtained through the GetAuxiliaryData call
         //
         void_ref_ptr vr = void_ref_ptr(arr, avtVariableCache::DestructVTKObject);
-        cache->CacheVoidRef(meshname, AUXILIARY_DATA_GLOBAL_NODE_IDS, timestep, 
+        cache->CacheVoidRef(meshname, AUXILIARY_DATA_GLOBAL_NODE_IDS, timestep,
                             domain, vr);
     }
 
@@ -12488,11 +12488,11 @@
 //
 //  Returns:      The vtkDataSet for mn.
 //
-//  Programmer:   Mark C. Miller 
-//  Creation:     August 8, 2005 
+//  Programmer:   Mark C. Miller
+//  Creation:     August 8, 2005
 //
 //  Modifications:
-//  
+//
 //    Mark C. Miller, Wed Nov 16 10:46:36 PST 2005
 //    Added some more primitives. Moved discretization calls to
 //    generic database
@@ -12503,7 +12503,7 @@
 //    Mark C. Miller, Thu Aug 14 19:52:12 PDT 2008
 //    Added code to explicitly cache csg grid objects from within the plugin.
 //    Note that the plugin is caching its objects in the 'cache' object but
-//    is doing so in a 'place' that VisIt itself can never find due to 
+//    is doing so in a 'place' that VisIt itself can never find due to
 //    different name of the 'type' of the cache.
 //
 //    Mark C. Miller, Wed Aug 20 11:39:39 PDT 2008
@@ -12537,7 +12537,7 @@
     // We have to explicitly handle caching of CSG meshes here in the plugin
     // because of single vtkCSGGrid object maps to many VisIt domains. Also,
     // we cache the object using a 'type' (SILO_CSG_GRID) that is unique to
-    // the SILO plugin so that VisIt's Generic Database class will never 
+    // the SILO plugin so that VisIt's Generic Database class will never
     // find it.
     //
     vtkCSGGrid *cached_csggrid = (vtkCSGGrid*) cache->GetVTKObject(meshname,
@@ -12546,7 +12546,7 @@
     {
         debug5 << "Avoiding re-read of CSG grid by returning cached grid: name=\""
                << meshname << "\", d=" << dom << ", t=" << timestep << endl;
-        vtkCSGGrid *cache_copy = vtkCSGGrid::New(); 
+        vtkCSGGrid *cache_copy = vtkCSGGrid::New();
         cache_copy->ShallowCopy(cached_csggrid);
         return cache_copy;
     }
@@ -12568,7 +12568,7 @@
     //
     // Create the VTK objects and connect them up.
     //
-    vtkCSGGrid *csggrid   = vtkCSGGrid::New(); 
+    vtkCSGGrid *csggrid   = vtkCSGGrid::New();
 
     double minX = -10.0, minY = -10.0, minZ = -10.0;
     double maxX =  10.0, maxY =  10.0, maxZ =  10.0;
@@ -12607,12 +12607,12 @@
     // object.  So, we have to explicitly handle caching of CSG meshes here in the plugin
     // because of single vtkCSGGrid object maps to many VisIt domains. Also,
     // we cache the object using a 'type' (SILO_CSG_GRID) that is unique to
-    // the SILO plugin so that VisIt's Generic Database class will never 
+    // the SILO plugin so that VisIt's Generic Database class will never
     // find it.
     //
     cache->CacheVTKObject(meshname, "SILO_CSG_GRID", timestep, dom, "none", csggrid);
 
-    vtkCSGGrid *csgcopy = vtkCSGGrid::New(); 
+    vtkCSGGrid *csgcopy = vtkCSGGrid::New();
     csgcopy->ShallowCopy(csggrid);
     return csgcopy;
 
@@ -12903,7 +12903,7 @@
 //    when available.
 //
 //    Mark C. Miller, Tue Feb  6 19:39:35 PST 2007
-//    Added Brad's fix for reducing large amount of string matching in 
+//    Added Brad's fix for reducing large amount of string matching in
 //    'fuzzy' matching logic. Also added matching on block counts.
 //
 //    Cyrus Harrison, Wed Dec 21 15:22:21 PST 2011
@@ -13039,7 +13039,7 @@
     // levels above us determine what the right thing to do is.
     //
     char str[1024];
-    SNPRINTF(str, sizeof(str), "Was not able to match multivar \"%s\" and its first \n" 
+    SNPRINTF(str, sizeof(str), "Was not able to match multivar \"%s\" and its first \n"
                  "non-empty submesh \"%s\" in file %s to a multi-mesh.\n"
                  "This typically leads to the variable being invalidated\n"
                  "(grayed out) in the GUI",
@@ -13213,7 +13213,7 @@
 //    Add destructor functions.
 //
 //    Mark C. Miller, August 9, 2004
-//    Added code to read global node and zone ids 
+//    Added code to read global node and zone ids
 //
 //    Mark C. Miller, Mon Oct 18 13:02:37 PDT 2004
 //    Added support for data/spatial extents
@@ -13407,7 +13407,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_mat;
@@ -13524,7 +13524,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_spec;
@@ -13540,15 +13540,15 @@
 //
 //  Purpose:
 //      Allocate space for and determine the real mesh name for a ucd mesh,
-//      which may be a multimesh 
+//      which may be a multimesh
 //
 //  Arguments:
 //      dom     The domain of the mesh.
-//      mesh    The mesh we want the real name for 
+//      mesh    The mesh we want the real name for
 //
-//  Returns:    The real mesh name 
+//  Returns:    The real mesh name
 //
-//  Programmer: Mark C. Miller 
+//  Programmer: Mark C. Miller
 //  Creation:   August 4, 2004
 //
 //  Modifications:
@@ -13646,7 +13646,7 @@
 //    Changed call to OpenFile() to GetFile()
 //
 //    Mark C. Miller, August 9, 2004
-//    Moved code common to several auxiliary data 'Get' methods to 
+//    Moved code common to several auxiliary data 'Get' methods to
 //    AllocAndDetermineMeshnameForUcdmesh
 //
 //    Mark C. Miller, Tue Jun 28 17:28:56 PDT 2005
@@ -13672,7 +13672,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_mesh;
@@ -13696,7 +13696,7 @@
 //      Gets the global node ids from the Silo file
 //
 //  Programmer: Mark C. Miller
-//  Creation:   August 4, 2004 
+//  Creation:   August 4, 2004
 //
 //  Modifications:
 //    Mark C. Miller, Thu Oct 14 15:18:31 PDT 2004
@@ -13740,7 +13740,7 @@
 
     //
     // Some Silo objects are distributed across several files,
-    // so handle that here.  
+    // so handle that here.
     //
     DBfile *domain_file = dbfile;
     string directory_mesh;
@@ -13748,10 +13748,10 @@
 
     // We want to get just the global node ids.  So we need to get the ReadMask,
     // set it to read global node ids, then set it back.
-    long mask = DBGetDataReadMask();
-    DBSetDataReadMask(DBUMGlobNodeNo);
+    long mask = DBGetDataReadMask2();
+    DBSetDataReadMask2(DBUMGlobNodeNo);
     DBucdmesh *um = DBGetUcdmesh(domain_file, directory_mesh.c_str());
-    DBSetDataReadMask(mask);
+    DBSetDataReadMask2(mask);
     if (um == NULL)
         EXCEPTION1(InvalidVariableException, mesh);
 
@@ -13769,7 +13769,7 @@
         rv = CreateDataArray(DB_INT, um->gnodeno, um->nnodes);
 #endif
 #else
-        rv = CreateDataArray(DB_INT, um->gnodeno, um->nnodes); 
+        rv = CreateDataArray(DB_INT, um->gnodeno, um->nnodes);
 #endif
         um->gnodeno = 0; // vtkDataArray owns the data now.
 
@@ -13839,10 +13839,10 @@
 
     // We want to get just the global node ids.  So we need to get the ReadMask,
     // set it to read global node ids, then set it back.
-    long mask = DBGetDataReadMask();
-    DBSetDataReadMask(DBUMZonelist|DBZonelistGlobZoneNo|DBZonelistInfo);
+    long mask = DBGetDataReadMask2();
+    DBSetDataReadMask2(DBUMZonelist|DBZonelistGlobZoneNo|DBZonelistInfo);
     DBucdmesh *um = DBGetUcdmesh(domain_file, directory_mesh.c_str());
-    DBSetDataReadMask(mask);
+    DBSetDataReadMask2(mask);
     if (um == NULL)
         EXCEPTION1(InvalidVariableException, mesh);
 
@@ -13851,12 +13851,12 @@
     {
 #ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,7,1)
-        rv = CreateDataArray(um->zones->gnznodtype, um->zones->gzoneno, um->zones->nzones); 
+        rv = CreateDataArray(um->zones->gnznodtype, um->zones->gzoneno, um->zones->nzones);
 #else
-        rv = CreateDataArray(DB_INT, um->zones->gzoneno, um->zones->nzones); 
+        rv = CreateDataArray(DB_INT, um->zones->gzoneno, um->zones->nzones);
 #endif
 #else
-        rv = CreateDataArray(DB_INT, um->zones->gzoneno, um->zones->nzones); 
+        rv = CreateDataArray(DB_INT, um->zones->gzoneno, um->zones->nzones);
 #endif
         um->zones->gzoneno = 0; // vtkDataArray owns the data now.
     }
@@ -13875,7 +13875,7 @@
 //      Gets the spatial extents from a multimesh, if they exist in the file
 //
 //  Programmer: Mark C. Miller
-//  Creation:   October 14, 2004 
+//  Creation:   October 14, 2004
 //
 //  Modifications:
 //    Kathleen Bonnell, Mon Aug 14 16:40:30 PDT 2006
@@ -13918,7 +13918,7 @@
     if (mm == NULL || mm->extents == NULL)
         return NULL;
 
-    int ndims = mm->extentssize / 2; 
+    int ndims = mm->extentssize / 2;
     avtIntervalTree *itree = new avtIntervalTree(mm->nblocks, ndims);
 
     for (int i = 0; i < mm->nblocks; i++)
@@ -13946,10 +13946,10 @@
 //  Method: avtSiloFileFormat::GetDataExtents
 //
 //  Purpose:
-//      Gets the data extents from a multivar, if they exist in the file 
+//      Gets the data extents from a multivar, if they exist in the file
 //
 //  Programmer: Mark C. Miller
-//  Creation:   October 14, 2004 
+//  Creation:   October 14, 2004
 //
 //  Modifications:
 //    Kathleen Bonnell, Mon Aug 14 16:40:30 PDT 2006
@@ -13992,7 +13992,7 @@
     if (mv == NULL || mv->extents == NULL)
         return NULL;
 
-    int ncomps = mv->extentssize / 2; 
+    int ncomps = mv->extentssize / 2;
     int esize = mv->extentssize;
     avtIntervalTree *itree = new avtIntervalTree(mv->nvars, ncomps);
     double *range = new double[esize];
@@ -14056,8 +14056,8 @@
 //    were removed from the mesh
 //
 //    Cyrus Harrison, Thu Oct  4 11:11:26 PDT 200
-//    Removed limit of 128 characters for material names. I increased the 
-//    limit to 256 + room for the material number - to safely handle valid 
+//    Removed limit of 128 characters for material names. I increased the
+//    limit to 256 + room for the material number - to safely handle valid
 //    silo material names. This resolves '8257.
 //
 //    Mark C. Miller, Tue Dec 16 09:36:56 PST 2008
@@ -14085,7 +14085,7 @@
 //
 //    Mark C. Miller, Thu Oct 29 14:34:55 PDT 2009
 //    Replaced zone skipping logic (old way of handling meshes with arb. poly
-//    zones) to use remapping logic. 
+//    zones) to use remapping logic.
 //
 //    Mark C. Miller, Fri Oct 30 14:03:13 PDT 2009
 //    Handle Silo's DB_DTPTR configuration option.
@@ -14147,7 +14147,7 @@
         int nmat = silomat->nmat;
 #ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,6,3)
-        if (mm&&mm->nmatnos>0) 
+        if (mm&&mm->nmatnos>0)
             nmat = mm->nmatnos;
 #endif
 #endif
@@ -14165,10 +14165,10 @@
             if(dlen>max_dlen)
                 max_dlen = dlen;
         }
-        
+
         matnames = new char*[nmat];
         buffer = new char[nmat*(256+max_dlen)];
-        
+
         for (int i = 0 ; i < nmat ; i++)
         {
             matnames[i] = buffer + (256+max_dlen)*i;
@@ -14215,7 +14215,7 @@
         tmp.vals = (DB_DTPTR**) new DB_DTPTR*[1];
         tmp.vals[0] = (DB_DTPTR*) silomat->matlist;
 #else
-        tmp.vals = (float**) new float*[1];
+        tmp.vals = (void**) new float*[1];
         tmp.vals[0] = (float*) silomat->matlist;
 #endif
         matListArr = CopyUcdVar<int,vtkIntArray>(&tmp, *remap);
@@ -14296,7 +14296,7 @@
 //    have been changed from float* to void*.
 //
 //    Brad Whitlock, Fri Aug  7 11:48:39 PDT 2009
-//    Convert other data types to float for now since avtSpecies can't 
+//    Convert other data types to float for now since avtSpecies can't
 //    store them.
 //
 //    Cyrus Harrison, Wed Aug 25 12:21:54 PDT 2010
@@ -14420,10 +14420,10 @@
     // We want to get just the facelist.  So we need to get the ReadMask,
     // set it to read facelists, then set it back.
     VisitMutexLock("avtSiloFileFormat::CalcExternalFacelist");
-    long mask = DBGetDataReadMask();
-    DBSetDataReadMask(DBUMFacelist | DBFacelistInfo);
+    long mask = DBGetDataReadMask2();
+    DBSetDataReadMask2(DBUMFacelist | DBFacelistInfo);
     DBucdmesh *um = DBGetUcdmesh(correctFile, realvar.c_str());
-    DBSetDataReadMask(mask);
+    DBSetDataReadMask2(mask);
     VisitMutexUnlock("avtSiloFileFormat::CalcExternalFacelist");
     if (um == NULL)
         EXCEPTION1(InvalidVariableException, mesh);
@@ -14497,9 +14497,9 @@
             ioInfo.SetNDomains(0);
             EXCEPTION0(ImproperUseException);
         }
-        
+
         //
-        // If there are different sized meshes, then we need to give up.  
+        // If there are different sized meshes, then we need to give up.
         // Check to see.
         //
         int blocks = -1;
@@ -14870,7 +14870,7 @@
             DBFreeMultivar(mv);
         }
 
-        
+
     }
     return;
 }
@@ -15176,7 +15176,7 @@
         int partOfPathThatIsReallyTopDirName = 0;
         if (! (topdirname[0] == '/' && topdirname[1] == '\0'))
         {
-            while (varname[partOfPathThatIsReallyTopDirName] == 
+            while (varname[partOfPathThatIsReallyTopDirName] ==
                    topdirname[partOfPathThatIsReallyTopDirName])
                 partOfPathThatIsReallyTopDirName++;
         }
@@ -15194,7 +15194,7 @@
         // first one), then take out the slash -- since the var would be
         // referred to as "Mesh", not "/Mesh".
         //
-        int offset = (num_slash > 1 ? 0 : 1); 
+        int offset = (num_slash > 1 ? 0 : 1);
         char *rv = new char[strlen(varname+tdOffset)+1];
         strcpy(rv, varname+offset+tdOffset);
         return rv;
@@ -15208,7 +15208,7 @@
     int partOfPathThatIsReallyTopDirName2 = 0;
     if (! (topdirname[0] == '/' && topdirname[1] == '\0'))
     {
-        while (dirname[partOfPathThatIsReallyTopDirName2] == 
+        while (dirname[partOfPathThatIsReallyTopDirName2] ==
                topdirname[partOfPathThatIsReallyTopDirName2] &&
                dirname[partOfPathThatIsReallyTopDirName2] != '\0')
                 partOfPathThatIsReallyTopDirName2++;
@@ -15491,7 +15491,7 @@
 //    siloPyramid     A list of nodes from a Silo node list.
 //    vtkPyramid      The list of nodes in VTK ordering.
 //
-//  Programmer: Kathleen Bonnell 
+//  Programmer: Kathleen Bonnell
 //  Creation:   May 23, 2001
 //
 //  Modifications:
@@ -15505,9 +15505,9 @@
 TranslateSiloPyramidToVTKPyramid(const int *siloPyramid, vtkIdType vtkPyramid[5])
 {
     //
-    // The Silo pyramid stores the four base nodes as 0, 1, 2, 3 in 
-    // opposite order from the VTK wedge. When getting the exact translation, 
-    // it is useful to look at the face lists and edge lists in 
+    // The Silo pyramid stores the four base nodes as 0, 1, 2, 3 in
+    // opposite order from the VTK wedge. When getting the exact translation,
+    // it is useful to look at the face lists and edge lists in
     // vtkPyramid.cxx.
     //
     vtkPyramid[0] = siloPyramid[0];
@@ -15529,7 +15529,7 @@
 //    siloTetrahedron     A list of nodes from a Silo node list.
 //    vtkTetrahedron      The list of nodes in VTK ordering.
 //
-//  Programmer:  Hank Childs 
+//  Programmer:  Hank Childs
 //  Creation:    January 11, 2005
 //
 // ****************************************************************************
@@ -15548,12 +15548,12 @@
 }
 
 // ****************************************************************************
-//  Function: TetIsInverted 
+//  Function: TetIsInverted
 //
 //  Purpose: Determine if Tets in Silo are inverted from Silo's Normal ordering
 //
-//  Programmer:  Mark C. Miller 
-//  Creation:    March 21, 2007 
+//  Programmer:  Mark C. Miller
+//  Creation:    March 21, 2007
 //
 //  Modifications:
 //
@@ -15582,7 +15582,7 @@
     double n1Xn2[3] = {  n1[1]*n2[2] - n1[2]*n2[1],
                       -(n1[0]*n2[2] - n1[2]*n2[0]),
                         n1[0]*n2[1] - n1[1]*n2[0]};
-    
+
     //
     // Compute a dot-product of normal with a vector to the 4th point.
     // If the tet is specified as Silo normally expects it, this dot
@@ -15602,10 +15602,10 @@
 // ****************************************************************************
 //  Function: GetMultivarToMultimeshMap
 //
-//  Purpose: Handle explicit multivar to multimesh mapping convention 
+//  Purpose: Handle explicit multivar to multimesh mapping convention
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 12, 2006 
+//  Programmer: Mark C. Miller
+//  Creation:   December 12, 2006
 //
 // ****************************************************************************
 void
@@ -15679,10 +15679,10 @@
 // ****************************************************************************
 //  Function: GuessCodeNameFromTopLevelVars
 //
-//  Purpose: Guess name of the code that produced the data 
+//  Purpose: Guess name of the code that produced the data
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   July 9, 2007 
+//  Programmer: Mark C. Miller
+//  Creation:   July 9, 2007
 //
 //  Modifications:
 //
@@ -15722,8 +15722,8 @@
 //  Purpose: Add enumeration info for Ale3d's rlxstat variable. These names and
 //  values were taken directly from Ale3d's RelaxTest.h file.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   July 9, 2007 
+//  Programmer: Mark C. Miller
+//  Creation:   July 9, 2007
 //
 //  Modifications:
 //    Mark C. Miller, Mon Apr 14 15:41:21 PDT 2008
@@ -15774,10 +15774,10 @@
 // ****************************************************************************
 //  Method: AddNodelistEnumerations
 //
-//  Purpose: Add node list enumerations for block structured codes. 
+//  Purpose: Add node list enumerations for block structured codes.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   March 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   March 18, 2008
 //
 //  Modifications:
 //    Mark C. Miller, Tue Apr 29 23:33:55 PDT 2008
@@ -15883,10 +15883,10 @@
 // ****************************************************************************
 //  Method: AddAnnotIntNodelistEnumerations
 //
-//  Purpose: Add ANNOTATION_INT node list enumerations  
+//  Purpose: Add ANNOTATION_INT node list enumerations
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   December 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   December 18, 2008
 //
 //  Modifications:
 //    Mark C. Miller, Tue Dec 23 11:12:31 PST 2008
@@ -15898,7 +15898,7 @@
 //    use the plugin's file management routines and this is important because
 //    this method is being called from within ReadDir we cannot allow file
 //    pointer stuff to change out from underneath ReadDir while it is still
-//    completing. 
+//    completing.
 //
 //    Mark C. Miller, Mon Mar  2 11:46:47 PST 2009
 //    Undid previous change and instead added a call to the loop which has
@@ -16052,7 +16052,7 @@
             DBmrgtnode *patchesArrayNode = top->children[0];
 
             //
-            // Handle the names of the patches 
+            // Handle the names of the patches
             //
             if (strchr(patchesArrayNode->names[0],'%') == 0)
             {
@@ -16079,7 +16079,7 @@
     else if (top->num_children > 1)
     {
         //
-        // Individual MRG Tree nodes for each patch 
+        // Individual MRG Tree nodes for each patch
         //
         for (int q = 0; q < top->num_children; q++)
         {
@@ -16098,8 +16098,8 @@
 //  representing the same information as the possibly one or more groupel maps
 //  in the database.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   November 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   November 18, 2008
 //
 //  Modifications
 //    Mark C. Miller Wed Nov 19 20:30:19 PST 2008
@@ -16128,9 +16128,9 @@
 //    maps are gathered and condensed and the groupel type.
 // ****************************************************************************
 
-#ifdef SILO_VERSION_GE 
+#ifdef SILO_VERSION_GE
 #if SILO_VERSION_GE(4,6,3)
-static DBgroupelmap * 
+static DBgroupelmap *
 GetCondensedGroupelMap(DBfile *dbfile, string mrgtnm_abspath,
     DBmrgtnode *rootNode, int forceSingle, int gpel_type)
 {
@@ -16157,7 +16157,7 @@
         }
         else
             mapNode = rootNode;
-            
+
         //
         // Get the groupel map.
         //
@@ -16168,7 +16168,7 @@
         DBgroupelmap *gm = DBGetGroupelmap(dbfile, mapsName.c_str());
 
         //
-        // One pass to count parts of map we'll be needing and a 2nd 
+        // One pass to count parts of map we'll be needing and a 2nd
         // pass to allocate and transfer those parts to the returned map.
         //
         for (pass = 0; pass < 2 && gm; pass++)
@@ -16176,7 +16176,7 @@
             if (pass == 1) /* allocate on 2nd pass */
             {
                 retval = DBAllocGroupelmap(q, DB_NOTYPE);
-                /* We won't need segment_ids because the map is condensed */ 
+                /* We won't need segment_ids because the map is condensed */
                 free(retval->segment_ids);
                 retval->segment_ids = 0;
             }
@@ -16258,8 +16258,8 @@
 //  handles whatever naming scheme the database specifies for levels and
 //  patches.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   November 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   November 18, 2008
 //
 //  Modifications
 //
@@ -16287,7 +16287,7 @@
 #if SILO_VERSION_GE(4,6,3)
     int i, j;
     bool probablyAnAMRMesh = true;
-    DBgroupelmap *gm = 0; 
+    DBgroupelmap *gm = 0;
 
     if (mm == 0)
         return;
@@ -16356,7 +16356,7 @@
         for (j = 0; j < lvlgm->segment_lengths[i]; j++)
         {
             int patch_no = ((int**) lvlgm->segment_data)[i][j];
-            (*group_ids)[patch_no] = i; 
+            (*group_ids)[patch_no] = i;
         }
     }
     DBFreeGroupelmap(lvlgm);
@@ -16391,13 +16391,13 @@
 }
 
 // ****************************************************************************
-//  Function: BuildDomainAuxiliaryInfoForAMRMeshes 
+//  Function: BuildDomainAuxiliaryInfoForAMRMeshes
 //
-//  Purpose: Builds domain nesting and boundary objects for AMR meshes. 
+//  Purpose: Builds domain nesting and boundary objects for AMR meshes.
 //  patches.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   November 18, 2008 
+//  Programmer: Mark C. Miller
+//  Creation:   November 18, 2008
 //
 //  Modifications
 //    Mark C. Miller Wed Nov 19 20:30:19 PST 2008
@@ -16559,7 +16559,7 @@
         for (j = 0; j < lvlgm->segment_lengths[i]; j++)
         {
             int patch_no = ((int**) lvlgm->segment_data)[i][j];
-            levelId[patch_no] = i; 
+            levelId[patch_no] = i;
         }
     }
     DBFreeGroupelmap(lvlgm);
@@ -16608,7 +16608,7 @@
     //
     // The number of dimensions can be inferred from the number of components in
     // the ratios variable.
-    // 
+    //
     num_dims = ratvar->ncomps;
     debug5 << "num_dims = " << num_dims << endl;
 
@@ -16628,7 +16628,7 @@
     for (i = 1; i < num_levels; i++)
     {
         int **ratvar_data = (int **) ratvar->data;
-        ratios[0] = ratvar_data[0][i]; 
+        ratios[0] = ratvar_data[0][i];
         ratios[1] = ratvar_data[1][i];
         ratios[2] = num_dims == 3 ? (int) ratvar_data[2][i]: 0;
             debug5 << "ratios = " << ratios[0] << ", " << ratios[1] << ", " << ratios[2] << endl;
@@ -16817,8 +16817,8 @@
 //  3 ==> know how many materials, their numbers and names but not colors
 //  4 ==> know everything.
 //
-//  Programmer: Mark C. Miller 
-//  Creation:   March 19, 2009 
+//  Programmer: Mark C. Miller
+//  Creation:   March 19, 2009
 //
 //  Modifications:
 //
