From df52a846881fdd233da1353c9feae06bf3bca963 Mon Sep 17 00:00:00 2001
From: Averell Dalton <averell+nixpkgs@rxd4.com>
Date: Wed, 27 Feb 2019 09:44:05 +0100
Subject: [PATCH 1/4] libnvc: ldconfig and PATH fixes

Signed-off-by: Someone Serge <sergei.kozlukov@aalto.fi>
---
 src/common.h      |  2 +-
 src/ldcache.c     | 73 +++++++++++++++++++++++++++++++++++++++++++----
 src/nvc_info.c    |  7 +++--
 src/nvc_ldcache.c | 20 +++++++------
 4 files changed, 84 insertions(+), 18 deletions(-)

diff --git a/src/common.h b/src/common.h
index c91d349..58e7926 100644
--- a/src/common.h
+++ b/src/common.h
@@ -20,7 +20,7 @@
 #define PROC_OVERFLOW_UID         "/proc/sys/kernel/overflowuid"
 #define PROC_OVERFLOW_GID         "/proc/sys/kernel/overflowgid"
 
-#define LDCACHE_PATH              "/etc/ld.so.cache"
+#define LDCACHE_PATH              "/tmp/ld.so.conf.nvidia-host"
 #define LDCONFIG_PATH             "/sbin/ldconfig"
 #define LDCONFIG_ALT_PATH         "/sbin/ldconfig.real"
 
diff --git a/src/ldcache.c b/src/ldcache.c
index 38bab05..4ccdff4 100644
--- a/src/ldcache.c
+++ b/src/ldcache.c
@@ -9,7 +9,10 @@
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <fts.h>
+#include <gelf.h>
 
+#include "elftool.h"
 #include "ldcache.h"
 #include "utils.h"
 #include "xfuncs.h"
@@ -65,6 +68,15 @@ ldcache_open(struct ldcache *ctx)
         struct header_libc6 *h6;
         size_t padding;
 
+        bool cacheExists = access(ctx->path, F_OK) == 0;
+
+        if (!cacheExists) {
+                ctx->ptr = NULL;
+                ctx->size = 0;
+                ctx->addr = NULL;
+                return (0);
+        }
+
         ctx->addr = ctx->ptr = file_map(ctx->err, ctx->path, &ctx->size);
         if (ctx->addr == NULL)
                 return (-1);
@@ -97,6 +109,9 @@ ldcache_open(struct ldcache *ctx)
 int
 ldcache_close(struct ldcache *ctx)
 {
+        if (ctx->ptr == NULL)
+                return (0);
+
         if (file_unmap(ctx->err, ctx->path, ctx->addr, ctx->size) < 0)
                 return (-1);
 
@@ -111,16 +126,58 @@ ldcache_resolve(struct ldcache *ctx, uint32_t arch, const char *root, const char
     char *paths[], size_t size, ldcache_select_fn select, void *select_ctx)
 {
         char path[PATH_MAX];
-        struct header_libc6 *h;
+        struct header_libc6 *h = NULL;
+        int nLdEntries = 0;
         int override;
 
-        h = (struct header_libc6 *)ctx->ptr;
+        if (ctx != NULL && ctx->ptr != NULL) {
+                h = (struct header_libc6 *)ctx->ptr;
+                nLdEntries = h->nlibs;
+        }
         memset(paths, 0, size * sizeof(*paths));
 
-        for (uint32_t i = 0; i < h->nlibs; ++i) {
-                int32_t flags = h->libs[i].flags;
-                char *key = (char *)ctx->ptr + h->libs[i].key;
-                char *value = (char *)ctx->ptr + h->libs[i].value;
+        FTS *ftsp;
+        FTSENT *p = NULL;
+        char *ftsArgv[] = {"argv0", "@driverLink@/lib", NULL};
+        if (arch == LD_I386_LIB32) {
+                ftsArgv[1] = "@driverLink@-32/lib";
+        }
+        ftsp = fts_open(ftsArgv, FTS_LOGICAL | FTS_NOCHDIR, NULL);
+        bool driverLinkExists = ftsp != NULL && fts_children(ftsp, 0) != NULL;
+        bool moreChildren = driverLinkExists;
+
+        for (int iLd = 0; (driverLinkExists && moreChildren) || iLd < nLdEntries;) {
+                int32_t flags = 0;
+                char *key, *value;
+                if (driverLinkExists && moreChildren && (moreChildren = (p = fts_read(ftsp)) != NULL)) {
+                    key = p->fts_name;
+                    value = p->fts_path;
+
+                    struct elftool et;
+                    elftool_init(&et, ctx->err);
+                    if (elftool_open(&et, value) < 0) {
+                        error_reset(et.err);
+                        continue;
+                    }
+                    GElf_Ehdr ehdr;
+                    if (gelf_getehdr(et.elf , &ehdr) == NULL) {
+                        error_setx(ctx->err, "gelf_getehdr failed");
+                    }
+                    if (ehdr.e_machine == EM_386) {
+                        flags |= LD_I386_LIB32;
+                        flags |= LD_ELF;
+                    } else if (ehdr.e_machine == EM_X86_64) {
+                        /* FIXME */
+                        flags |= LD_X8664_LIB64;
+                        flags |= LD_ELF;
+                    }
+                    elftool_close(&et);
+                } else if (iLd < nLdEntries) {
+                    flags = h->libs[iLd].flags;
+                    key = (char *)ctx->ptr + h->libs[iLd].key;
+                    value = (char *)ctx->ptr + h->libs[iLd].value;
+                    iLd += 1;
+                }
 
                 if (!(flags & LD_ELF) || (flags & LD_ARCH_MASK) != arch)
                         continue;
@@ -143,5 +200,9 @@ ldcache_resolve(struct ldcache *ctx, uint32_t arch, const char *root, const char
                         break;
                 }
         }
+
+        if (ftsp != NULL) {
+                fts_close(ftsp);
+        }
         return (0);
 }
diff --git a/src/nvc_info.c b/src/nvc_info.c
index 2d203ae..7f21589 100644
--- a/src/nvc_info.c
+++ b/src/nvc_info.c
@@ -218,8 +218,9 @@ find_library_paths(struct error *err, struct dxcore_context *dxcore, struct nvc_
         if (path_resolve_full(err, path, root, ldcache) < 0)
                 return (-1);
         ldcache_init(&ld, err, path);
-        if (ldcache_open(&ld) < 0)
+        if (ldcache_open(&ld) < 0) {
                 return (-1);
+        }
 
         info->nlibs = size;
         info->libs = array_new(err, size);
@@ -239,7 +240,7 @@ find_library_paths(struct error *err, struct dxcore_context *dxcore, struct nvc_
         rv = 0;
 
  fail:
-        if (ldcache_close(&ld) < 0)
+        if (ld.ptr != NULL && ldcache_close(&ld) < 0)
                 return (-1);
         return (rv);
 }
@@ -254,7 +255,7 @@ find_binary_paths(struct error *err, struct dxcore_context* dxcore, struct nvc_d
         char path[PATH_MAX];
         int rv = -1;
 
-        if ((env = secure_getenv("PATH")) == NULL) {
+        if ((env = "/run/nvidia-docker/bin:/run/nvidia-docker/extras/bin") == NULL) {
                 error_setx(err, "environment variable PATH not found");
                 return (-1);
         }
diff --git a/src/nvc_ldcache.c b/src/nvc_ldcache.c
index db3b2f6..f15a6c9 100644
--- a/src/nvc_ldcache.c
+++ b/src/nvc_ldcache.c
@@ -361,32 +361,34 @@ nvc_ldcache_update(struct nvc_context *ctx, const struct nvc_container *cnt)
         bool drop_groups = true;
         bool host_ldconfig = false;
         int fd = -1;
+        bool ldconfigExists = false;
 
         if (validate_context(ctx) < 0)
                 return (-1);
         if (validate_args(ctx, cnt != NULL) < 0)
                 return (-1);
 
-        argv = (char * []){cnt->cfg.ldconfig, "-f", "/etc/ld.so.conf", "-C", "/etc/ld.so.cache", cnt->cfg.libs_dir, cnt->cfg.libs32_dir, NULL};
+        argv = (char * []){cnt->cfg.ldconfig, "-f", "/tmp/ld.so.conf.nvidia-host", "-C", "/tmp/ld.so.cache.nvidia-host", cnt->cfg.libs_dir, cnt->cfg.libs32_dir, NULL};
         if (*argv[0] == '@') {
                 /*
                  * We treat this path specially to be relative to the host filesystem.
                  * Force proc to be remounted since we're creating a PID namespace and fexecve depends on it.
                  */
                 ++argv[0];
-                if ((fd = xopen(&ctx->err, argv[0], O_RDONLY|O_CLOEXEC)) < 0)
-                        return (-1);
+                if ((fd = xopen(&ctx->err, argv[0], O_RDONLY|O_CLOEXEC)) < 0) {
+                    ldconfigExists = true;
+                }
                 host_ldconfig = true;
                 log_infof("executing %s from host at %s", argv[0], cnt->cfg.rootfs);
         } else {
                 log_infof("executing %s at %s", argv[0], cnt->cfg.rootfs);
         }
 
-        if ((child = create_process(&ctx->err, CLONE_NEWPID|CLONE_NEWIPC)) < 0) {
+        if (ldconfigExists && (child = create_process(&ctx->err, CLONE_NEWPID|CLONE_NEWIPC)) < 0) {
                 xclose(fd);
                 return (-1);
         }
-        if (child == 0) {
+        if (ldconfigExists && child == 0) {
                 prctl(PR_SET_NAME, (unsigned long)"nvc:[ldconfig]", 0, 0, 0);
 
                 if (ns_enter(&ctx->err, cnt->mnt_ns, CLONE_NEWNS) < 0)
@@ -412,12 +414,14 @@ nvc_ldcache_update(struct nvc_context *ctx, const struct nvc_container *cnt)
                 (ctx->err.code == ENOENT) ? _exit(EXIT_SUCCESS) : _exit(EXIT_FAILURE);
         }
 
-        xclose(fd);
-        if (waitpid(child, &status, 0) < 0) {
+        if (ldconfigExists) {
+                xclose(fd);
+        }
+        if (ldconfigExists && waitpid(child, &status, 0) < 0) {
                 error_set(&ctx->err, "process reaping failed");
                 return (-1);
         }
-        if (WIFSIGNALED(status)) {
+        if (ldconfigExists && WIFSIGNALED(status)) {
                 error_setx(&ctx->err, "process %s terminated with signal %d", argv[0], WTERMSIG(status));
                 return (-1);
         }
-- 
2.42.0

