From 44ed96cd84a193f7e85fe01d43c78a3e9e1c048e Mon Sep 17 00:00:00 2001
From: Emily <vcs@emily.moe>
Date: Tue, 31 Mar 2020 02:53:00 +0100
Subject: [PATCH] fileserver: Use hash of path as ETag in Nix store

Co-authored-by: Yegor Timoshenko <yegortimoshenko@riseup.net>
---
 modules/caddyhttp/fileserver/staticfiles.go | 61 ++++++++++++++++++++-
 1 file changed, 59 insertions(+), 2 deletions(-)

diff --git a/modules/caddyhttp/fileserver/staticfiles.go b/modules/caddyhttp/fileserver/staticfiles.go
index 732894da..39ec429b 100644
--- a/modules/caddyhttp/fileserver/staticfiles.go
+++ b/modules/caddyhttp/fileserver/staticfiles.go
@@ -16,6 +16,8 @@ package fileserver
 
 import (
 	"bytes"
+	"crypto/sha512"
+	"encoding/hex"
 	"fmt"
 	"html/template"
 	"io"
@@ -181,9 +183,19 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 	}
 	defer file.Close()
 
+	// default to zero time so that http.ServeContent omits the
+	// Last-Modified header when the file is in the Nix store; see
+	// https://github.com/NixOS/nixpkgs/pull/76697
+	var modTime time.Time
+
 	// set the ETag - note that a conditional If-None-Match request is handled
 	// by http.ServeContent below, which checks against this ETag value
-	w.Header().Set("ETag", calculateEtag(info))
+	if etag, ok := calculateNixStoreEtag(info, filename); ok {
+		w.Header().Set("ETag", etag)
+	} else {
+		w.Header().Set("ETag", calculateEtag(info))
+		modTime = info.ModTime()
+	}
 
 	if w.Header().Get("Content-Type") == "" {
 		mtyp := mime.TypeByExtension(filepath.Ext(filename))
@@ -219,7 +231,7 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 	// that errors generated by ServeContent are written immediately
 	// to the response, so we cannot handle them (but errors there
 	// are rare)
-	http.ServeContent(w, r, info.Name(), info.ModTime(), file)
+	http.ServeContent(w, r, info.Name(), modTime, file)
 
 	return nil
 }
@@ -361,6 +373,51 @@ func calculateEtag(d os.FileInfo) string {
 	return `"` + t + s + `"`
 }
 
+func calculateNixStoreEtag(d os.FileInfo, path string) (string, bool) {
+	// Nix store files have mtime = 1
+	if d.ModTime().Unix() != 1 {
+		return "", false
+	}
+
+	var err error
+
+	// avoid running filepath.Abs unless necessary, as it calls
+	// filepath.Clean which is (relatively) expensive
+	if !filepath.IsAbs(path) {
+		path, err = filepath.Abs(path)
+		if err != nil {
+			return "", false
+		}
+	}
+
+	const storePrefix = "@storeDir@/"
+
+	if !strings.HasPrefix(path, storePrefix) {
+		// Since mtime = 1, most likely a link into the store, e.g.:
+		//
+		//     /var/www/riot.example.com
+		//       -> /nix/store/00000000000000000000000000000000-riot-web
+		//
+		// Note that filepath.EvalSymlinks is relatively expensive (~15 Âµs in
+		// an HTTP/2 microbenchmark while testing this patch), so you probably
+		// want to avoid relying on this codepath if you're optimizing for raw
+		// request throughput (i.e., don't serve any mtime = 1 files that
+		// aren't explicitly rooted in a derivation or explicit /nix/store
+		// path in the Caddy configuration).
+		path, err = filepath.EvalSymlinks(path)
+		if err != nil || !strings.HasPrefix(path, storePrefix) {
+			return "", false
+		}
+	}
+
+	// Hash the entire path so that ETag changes when switching /foo from:
+	//     /nix/store/00000000000000000000000000000000-www/a/foo
+	// to:
+	//     /nix/store/00000000000000000000000000000000-www/b/foo
+	pathDigest := sha512.Sum512_224([]byte(path))
+	return `"` + hex.EncodeToString(pathDigest[:]) + `"`, true
+}
+
 func redirect(w http.ResponseWriter, r *http.Request, to string) error {
 	for strings.HasPrefix(to, "//") {
 		// prevent path-based open redirects
-- 
2.25.1

