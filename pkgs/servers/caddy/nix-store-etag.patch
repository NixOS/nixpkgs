From 44ed96cd84a193f7e85fe01d43c78a3e9e1c048e Mon Sep 17 00:00:00 2001
From: Emily <vcs@emily.moe>
Date: Tue, 31 Mar 2020 02:53:00 +0100
Subject: [PATCH] fileserver: Use hash of path as ETag in Nix store

Co-authored-by: Yegor Timoshenko <yegortimoshenko@riseup.net>
---
 modules/caddyhttp/fileserver/staticfiles.go | 61 ++++++++++++++++++++-
 1 file changed, 59 insertions(+), 2 deletions(-)

diff --git a/modules/caddyhttp/fileserver/staticfiles.go b/modules/caddyhttp/fileserver/staticfiles.go
index c0fde660..b4444107 100644
--- a/modules/caddyhttp/fileserver/staticfiles.go
+++ b/modules/caddyhttp/fileserver/staticfiles.go
@@ -17,6 +17,8 @@ package fileserver
 import (
 	"encoding/json"
 	"errors"
+	"crypto/sha512"
+	"encoding/hex"
 	"fmt"
 	"io"
 	"io/fs"
@@ -392,6 +394,11 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 		break
 	}
 
+	// default to zero time so that http.ServeContent omits the
+	// Last-Modified header when the file is in the Nix store; see
+	// https://github.com/NixOS/nixpkgs/pull/76697
+	var modTime time.Time
+
 	// no precompressed file found, use the actual file
 	if file == nil {
 		fsrv.logger.Debug("opening file", zap.String("filename", filename))
@@ -407,7 +414,12 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 		}
 		defer file.Close()
 
-		etag = calculateEtag(info)
+		if nixEtag, ok := calculateNixStoreEtag(info, filename); ok {
+			etag = nixEtag;
+		} else {
+			etag = calculateEtag(info)
+			modTime = info.ModTime()
+		}
 	}
 
 	// at this point, we're serving a file; Go std lib supports only
@@ -465,7 +477,7 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 	// that errors generated by ServeContent are written immediately
 	// to the response, so we cannot handle them (but errors there
 	// are rare)
-	http.ServeContent(w, r, info.Name(), info.ModTime(), file.(io.ReadSeeker))
+	http.ServeContent(w, r, info.Name(), modTime, file.(io.ReadSeeker))
 
 	return nil
 }
@@ -612,6 +624,51 @@ func calculateEtag(d os.FileInfo) string {
 	return `"` + t + s + `"`
 }
 
+func calculateNixStoreEtag(d os.FileInfo, path string) (string, bool) {
+	// Nix store files have mtime = 1
+	if d.ModTime().Unix() != 1 {
+		return "", false
+	}
+
+	var err error
+
+	// avoid running filepath.Abs unless necessary, as it calls
+	// filepath.Clean which is (relatively) expensive
+	if !filepath.IsAbs(path) {
+		path, err = filepath.Abs(path)
+		if err != nil {
+			return "", false
+		}
+	}
+
+	const storePrefix = "@storeDir@/"
+
+	if !strings.HasPrefix(path, storePrefix) {
+		// Since mtime = 1, most likely a link into the store, e.g.:
+		//
+		//     /var/www/riot.example.com
+		//       -> /nix/store/00000000000000000000000000000000-riot-web
+		//
+		// Note that filepath.EvalSymlinks is relatively expensive (~15 Âµs in
+		// an HTTP/2 microbenchmark while testing this patch), so you probably
+		// want to avoid relying on this codepath if you're optimizing for raw
+		// request throughput (i.e., don't serve any mtime = 1 files that
+		// aren't explicitly rooted in a derivation or explicit /nix/store
+		// path in the Caddy configuration).
+		path, err = filepath.EvalSymlinks(path)
+		if err != nil || !strings.HasPrefix(path, storePrefix) {
+			return "", false
+		}
+	}
+
+	// Hash the entire path so that ETag changes when switching /foo from:
+	//     /nix/store/00000000000000000000000000000000-www/a/foo
+	// to:
+	//     /nix/store/00000000000000000000000000000000-www/b/foo
+	pathDigest := sha512.Sum512_224([]byte(path))
+	return `"` + hex.EncodeToString(pathDigest[:]) + `"`, true
+}
+
 func redirect(w http.ResponseWriter, r *http.Request, to string) error {
 	for strings.HasPrefix(to, "//") {
 		// prevent path-based open redirects
-- 
2.38.4

