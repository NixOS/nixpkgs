From b73e525c9320a2a95d8a77eb7f6091549e5de6b8 Mon Sep 17 00:00:00 2001
From: Asher <ash@coder.com>
Date: Fri, 3 Mar 2023 09:12:34 +0000
Subject: [PATCH] Add origin checks to web sockets (#6048)

* Move splitOnFirstEquals to util

I will be making use of this to parse the forwarded header.

* Type splitOnFirstEquals with two items

Also add some test cases.

* Check origin header on web sockets

* Update changelog with origin check

* Fix web sockets not closing with error code

(cherry picked from commit d477972c68fc8c8e8d610aa7287db87ba90e55c7)
---
 src/common/http.ts                   |   1 +
 src/node/cli.ts                      |  14 +--
 src/node/http.ts                     |  75 ++++++++++++++-
 src/node/routes/domainProxy.ts       |   6 +-
 src/node/routes/errors.ts            |   8 +-
 src/node/routes/pathProxy.ts         |   3 +-
 src/node/routes/vscode.ts            |   4 +-
 src/node/util.ts                     |  10 ++
 src/node/wsRouter.ts                 |   3 +
 test/unit/node/proxy.test.ts         |  48 ++++++++--
 test/unit/node/routes/health.test.ts |   4 +-
 test/unit/node/util.test.ts          | 133 +++++++++++++++++++++++++++
 test/utils/httpserver.ts             |  16 +++-
 13 files changed, 293 insertions(+), 32 deletions(-)

diff --git a/src/common/http.ts b/src/common/http.ts
index 5709c455..4235df17 100644
--- a/src/common/http.ts
+++ b/src/common/http.ts
@@ -4,6 +4,7 @@ export enum HttpCode {
   NotFound = 404,
   BadRequest = 400,
   Unauthorized = 401,
+  Forbidden = 403,
   LargePayload = 413,
   ServerError = 500,
 }
diff --git a/src/node/cli.ts b/src/node/cli.ts
index 6565fbc9..d954787d 100644
--- a/src/node/cli.ts
+++ b/src/node/cli.ts
@@ -11,6 +11,7 @@ import {
   paths,
   isNodeJSErrnoException,
   isFile,
+  splitOnFirstEquals,
 } from "./util"
 
 const DEFAULT_SOCKET_PATH = path.join(os.tmpdir(), "vscode-ipc")
@@ -265,19 +266,6 @@ export const optionDescriptions = (): string[] => {
   })
 }
 
-export function splitOnFirstEquals(str: string): string[] {
-  // we use regex instead of "=" to ensure we split at the first
-  // "=" and return the following substring with it
-  // important for the hashed-password which looks like this
-  // $argon2i$v=19$m=4096,t=3,p=1$0qR/o+0t00hsbJFQCKSfdQ$oFcM4rL6o+B7oxpuA4qlXubypbBPsf+8L531U7P9HYY
-  // 2 means return two items
-  // Source: https://stackoverflow.com/a/4607799/3015595
-  // We use the ? to say the the substr after the = is optional
-  const split = str.split(/=(.+)?/, 2)
-
-  return split
-}
-
 /**
  * Parse arguments into UserProvidedArgs.  This should not go beyond checking
  * that arguments are valid types and have values when required.
diff --git a/src/node/http.ts b/src/node/http.ts
index dbd72d84..f77a8610 100644
--- a/src/node/http.ts
+++ b/src/node/http.ts
@@ -12,7 +12,15 @@ import { version as codeServerVersion } from "./constants"
 import { Heart } from "./heart"
 import { CoderSettings, SettingsProvider } from "./settings"
 import { UpdateProvider } from "./update"
-import { getPasswordMethod, IsCookieValidArgs, isCookieValid, sanitizeString, escapeHtml, escapeJSON } from "./util"
+import {
+  getPasswordMethod,
+  IsCookieValidArgs,
+  isCookieValid,
+  sanitizeString,
+  escapeHtml,
+  escapeJSON,
+  splitOnFirstEquals,
+} from "./util"
 
 /**
  * Base options included on every page.
@@ -295,3 +303,68 @@ export const getCookieOptions = (req: express.Request): express.CookieOptions =>
 export const self = (req: express.Request): string => {
   return normalize(`${req.baseUrl}${req.originalUrl.endsWith("/") ? "/" : ""}`, true)
 }
+
+function getFirstHeader(req: http.IncomingMessage, headerName: string): string | undefined {
+  const val = req.headers[headerName]
+  return Array.isArray(val) ? val[0] : val
+}
+
+/**
+ * Throw an error if origin checks fail. Call `next` if provided.
+ */
+export function ensureOrigin(req: express.Request, _?: express.Response, next?: express.NextFunction): void {
+  if (!authenticateOrigin(req)) {
+    throw new HttpError("Forbidden", HttpCode.Forbidden)
+  }
+  if (next) {
+    next()
+  }
+}
+
+/**
+ * Authenticate the request origin against the host.
+ */
+export function authenticateOrigin(req: express.Request): boolean {
+  // A missing origin probably means the source is non-browser.  Not sure we
+  // have a use case for this but let it through.
+  const originRaw = getFirstHeader(req, "origin")
+  if (!originRaw) {
+    return true
+  }
+
+  let origin: string
+  try {
+    origin = new URL(originRaw).host.trim().toLowerCase()
+  } catch (error) {
+    return false // Malformed URL.
+  }
+
+  // Honor Forwarded if present.
+  const forwardedRaw = getFirstHeader(req, "forwarded")
+  if (forwardedRaw) {
+    const parts = forwardedRaw.split(/[;,]/)
+    for (let i = 0; i < parts.length; ++i) {
+      const [key, value] = splitOnFirstEquals(parts[i])
+      if (key.trim().toLowerCase() === "host" && value) {
+        return origin === value.trim().toLowerCase()
+      }
+    }
+  }
+
+  // Honor X-Forwarded-Host if present.
+  const xHost = getFirstHeader(req, "x-forwarded-host")
+  if (xHost) {
+    return origin === xHost.trim().toLowerCase()
+  }
+
+  // A missing host likely means the reverse proxy has not been configured to
+  // forward the host which means we cannot perform the check.  Emit a warning
+  // so an admin can fix the issue.
+  const host = getFirstHeader(req, "host")
+  if (!host) {
+    logger.warn(`no host headers found; blocking request to ${req.originalUrl}`)
+    return false
+  }
+
+  return origin === host.trim().toLowerCase()
+}
diff --git a/src/node/routes/domainProxy.ts b/src/node/routes/domainProxy.ts
index 83194b8c..3d8273c4 100644
--- a/src/node/routes/domainProxy.ts
+++ b/src/node/routes/domainProxy.ts
@@ -1,6 +1,6 @@
 import { Request, Router } from "express"
 import { HttpCode, HttpError } from "../../common/http"
-import { authenticated, ensureAuthenticated, redirect, self } from "../http"
+import { authenticated, ensureAuthenticated, ensureOrigin, redirect, self } from "../http"
 import { proxy } from "../proxy"
 import { Router as WsRouter } from "../wsRouter"
 
@@ -78,10 +78,8 @@ wsRouter.ws("*", async (req, _, next) => {
   if (!port) {
     return next()
   }
-
-  // Must be authenticated to use the proxy.
+  ensureOrigin(req)
   await ensureAuthenticated(req)
-
   proxy.ws(req, req.ws, req.head, {
     ignorePath: true,
     target: `http://0.0.0.0:${port}${req.originalUrl}`,
diff --git a/src/node/routes/errors.ts b/src/node/routes/errors.ts
index 9b5fdae9..712bba60 100644
--- a/src/node/routes/errors.ts
+++ b/src/node/routes/errors.ts
@@ -63,5 +63,11 @@ export const errorHandler: express.ErrorRequestHandler = async (err, req, res, n
 
 export const wsErrorHandler: express.ErrorRequestHandler = async (err, req, res, next) => {
   logger.error(`${err.message} ${err.stack}`)
-  ;(req as WebsocketRequest).ws.end()
+  let statusCode = 500
+  if (errorHasStatusCode(err)) {
+    statusCode = err.statusCode
+  } else if (errorHasCode(err) && notFoundCodes.includes(err.code)) {
+    statusCode = HttpCode.NotFound
+  }
+  ;(req as WebsocketRequest).ws.end(`HTTP/1.1 ${statusCode} ${err.message}\r\n\r\n`)
 }
diff --git a/src/node/routes/pathProxy.ts b/src/node/routes/pathProxy.ts
index 6c20ab6b..cb7c9487 100644
--- a/src/node/routes/pathProxy.ts
+++ b/src/node/routes/pathProxy.ts
@@ -3,7 +3,7 @@ import * as path from "path"
 import * as qs from "qs"
 import * as pluginapi from "../../../typings/pluginapi"
 import { HttpCode, HttpError } from "../../common/http"
-import { authenticated, ensureAuthenticated, redirect, self } from "../http"
+import { authenticated, ensureAuthenticated, ensureOrigin, redirect, self } from "../http"
 import { proxy as _proxy } from "../proxy"
 
 const getProxyTarget = (req: Request, passthroughPath?: boolean): string => {
@@ -50,6 +50,7 @@ export async function wsProxy(
     passthroughPath?: boolean
   },
 ): Promise<void> {
+  ensureOrigin(req)
   await ensureAuthenticated(req)
   _proxy.ws(req, req.ws, req.head, {
     ignorePath: true,
diff --git a/src/node/routes/vscode.ts b/src/node/routes/vscode.ts
index 963fe660..91435426 100644
--- a/src/node/routes/vscode.ts
+++ b/src/node/routes/vscode.ts
@@ -4,7 +4,7 @@ import { WebsocketRequest } from "../../../typings/pluginapi"
 import { logError } from "../../common/util"
 import { toVsCodeArgs } from "../cli"
 import { isDevMode } from "../constants"
-import { authenticated, ensureAuthenticated, redirect, self } from "../http"
+import { authenticated, ensureAuthenticated, ensureOrigin, redirect, self } from "../http"
 import { loadAMDModule } from "../util"
 import { Router as WsRouter } from "../wsRouter"
 import { errorHandler } from "./errors"
@@ -121,7 +121,7 @@ export class CodeServerRouteWrapper {
   constructor() {
     this.router.get("/", this.ensureCodeServerLoaded, this.$root)
     this.router.all("*", ensureAuthenticated, this.ensureCodeServerLoaded, this.$proxyRequest)
-    this._wsRouterWrapper.ws("/", ensureAuthenticated, this.ensureCodeServerLoaded, this.$proxyWebsocket)
+    this._wsRouterWrapper.ws("*", ensureOrigin, ensureAuthenticated, this.ensureCodeServerLoaded, this.$proxyWebsocket)
   }
 
   dispose() {
diff --git a/src/node/util.ts b/src/node/util.ts
index 56ae83e3..9b388b3f 100644
--- a/src/node/util.ts
+++ b/src/node/util.ts
@@ -522,3 +522,13 @@ export const loadAMDModule = async <T>(amdPath: string, exportName: string): Pro
 
   return module[exportName] as T
 }
+
+/**
+ * Split a string on the first equals.  The result will always be an array with
+ * two items regardless of how many equals there are.  The second item will be
+ * undefined if empty or missing.
+ */
+export function splitOnFirstEquals(str: string): [string, string | undefined] {
+  const split = str.split(/=(.+)?/, 2)
+  return [split[0], split[1]]
+}
diff --git a/src/node/wsRouter.ts b/src/node/wsRouter.ts
index 0c60a5fa..813638ce 100644
--- a/src/node/wsRouter.ts
+++ b/src/node/wsRouter.ts
@@ -31,6 +31,9 @@ export class WebsocketRouter {
   /**
    * Handle a websocket at this route. Note that websockets are immediately
    * paused when they come in.
+   *
+   * If the origin header exists it must match the host or the connection will
+   * be prevented.
    */
   public ws(route: expressCore.PathParams, ...handlers: pluginapi.WebSocketHandler[]): void {
     this.router.get(
diff --git a/test/unit/node/proxy.test.ts b/test/unit/node/proxy.test.ts
index 55ea4367..9502c942 100644
--- a/test/unit/node/proxy.test.ts
+++ b/test/unit/node/proxy.test.ts
@@ -4,21 +4,26 @@ import * as http from "http"
 import nodeFetch from "node-fetch"
 import { HttpCode } from "../../../src/common/http"
 import { proxy } from "../../../src/node/proxy"
-import { getAvailablePort } from "../../utils/helpers"
+import { wss, Router as WsRouter } from "../../../src/node/wsRouter"
+import { getAvailablePort, mockLogger } from "../../utils/helpers"
 import * as httpserver from "../../utils/httpserver"
 import * as integration from "../../utils/integration"
 
 describe("proxy", () => {
   const nhooyrDevServer = new httpserver.HttpServer()
+  const wsApp = express.default()
+  const wsRouter = WsRouter()
   let codeServer: httpserver.HttpServer | undefined
   let proxyPath: string
   let absProxyPath: string
   let e: express.Express
 
   beforeAll(async () => {
+    wsApp.use("/", wsRouter.router)
     await nhooyrDevServer.listen((req, res) => {
       e(req, res)
     })
+    nhooyrDevServer.listenUpgrade(wsApp)
     proxyPath = `/proxy/${nhooyrDevServer.port()}/wsup`
     absProxyPath = proxyPath.replace("/proxy/", "/absproxy/")
   })
@@ -29,6 +34,7 @@ describe("proxy", () => {
 
   beforeEach(() => {
     e = express.default()
+    mockLogger()
   })
 
   afterEach(async () => {
@@ -36,6 +42,7 @@ describe("proxy", () => {
       await codeServer.dispose()
       codeServer = undefined
     }
+    jest.clearAllMocks()
   })
 
   it("should rewrite the base path", async () => {
@@ -151,6 +158,35 @@ describe("proxy", () => {
     expect(resp.status).toBe(500)
     expect(resp.statusText).toMatch("Internal Server Error")
   })
+
+  it("should pass origin check", async () => {
+    wsRouter.ws("/wsup", async (req) => {
+      wss.handleUpgrade(req, req.ws, req.head, (ws) => {
+        ws.send("hello")
+        req.ws.resume()
+      })
+    })
+    codeServer = await integration.setup(["--auth=none"], "")
+    const ws = await codeServer.wsWait(proxyPath, {
+      headers: {
+        host: "localhost:8080",
+        origin: "https://localhost:8080",
+      },
+    })
+    ws.terminate()
+  })
+
+  it("should fail origin check", async () => {
+    await expect(async () => {
+      codeServer = await integration.setup(["--auth=none"], "")
+      await codeServer.wsWait(proxyPath, {
+        headers: {
+          host: "localhost:8080",
+          origin: "https://evil.org",
+        },
+      })
+    }).rejects.toThrow()
+  })
 })
 
 // NOTE@jsjoeio
@@ -190,18 +226,18 @@ describe("proxy (standalone)", () => {
     })
 
     // Start both servers
-    await proxyTarget.listen(PROXY_PORT)
-    await testServer.listen(PORT)
+    proxyTarget.listen(PROXY_PORT)
+    testServer.listen(PORT)
   })
 
   afterEach(async () => {
-    await testServer.close()
-    await proxyTarget.close()
+    testServer.close()
+    proxyTarget.close()
   })
 
   it("should return a 500 when proxy target errors ", async () => {
     // Close the proxy target so that proxy errors
-    await proxyTarget.close()
+    proxyTarget.close()
     const errorResp = await nodeFetch(`${URL}/error`)
     expect(errorResp.status).toBe(HttpCode.ServerError)
     expect(errorResp.statusText).toBe("Internal Server Error")
diff --git a/test/unit/node/routes/health.test.ts b/test/unit/node/routes/health.test.ts
index 77dd6a94..5f56b4a1 100644
--- a/test/unit/node/routes/health.test.ts
+++ b/test/unit/node/routes/health.test.ts
@@ -23,7 +23,9 @@ describe("health", () => {
     codeServer = await integration.setup(["--auth=none"], "")
     const ws = codeServer.ws("/healthz")
     const message = await new Promise((resolve, reject) => {
-      ws.on("error", console.error)
+      ws.on("error", (err) => {
+        console.error("[healthz]", err)
+      })
       ws.on("message", (message) => {
         try {
           const j = JSON.parse(message.toString())
diff --git a/test/unit/node/util.test.ts b/test/unit/node/util.test.ts
index 45289229..39c0e8ee 100644
--- a/test/unit/node/util.test.ts
+++ b/test/unit/node/util.test.ts
@@ -514,3 +514,136 @@ describe("humanPath", () => {
     expect(actual).toBe(expected)
   })
 })
+
+describe("isWsl", () => {
+  const testName = "wsl"
+
+  beforeAll(async () => {
+    await clean(testName)
+  })
+
+  describe("on Linux (microsoft)", () => {
+    it("should return true", async () => {
+      const fileName = "proc-version"
+      const osRelease = "5.4.0-1066-gke"
+      const pathToFile = path.join(await tempDirHelper(testName), fileName)
+      await fs.writeFile(
+        pathToFile,
+        "Linux version 3.4.0-Microsoft (Microsoft@Microsoft.com) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Wed Dec 31 14:42:53 PST 2014",
+      )
+      expect(await util.isWsl("linux", osRelease, pathToFile)).toBe(true)
+    })
+  })
+  describe("on Linux (non-microsoft)", () => {
+    it("should return false", async () => {
+      const fileName = "proc-version2"
+      const osRelease = "Linux"
+      const pathToFile = path.join(await tempDirHelper(testName), fileName)
+      await fs.writeFile(
+        pathToFile,
+        "Linux version 5.4.0-1066-gke (buildd@lcy02-amd64-039) (gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04)) #69-Ubuntu SMP Fri Mar 11 13:52:45 UTC 202",
+      )
+      expect(await util.isWsl("linux", osRelease, pathToFile)).toBe(false)
+    })
+  })
+  describe("on Win32 with microsoft in /proc/version", () => {
+    it("should return false", async () => {
+      const fileName = "proc-version3"
+      const osRelease = "3.4.0-Microsoft"
+      const pathToFile = path.join(await tempDirHelper(testName), fileName)
+      await fs.writeFile(
+        pathToFile,
+        "Linux version 3.4.0-Microsoft (Microsoft@Microsoft.com) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Wed Dec 31 14:42:53 PST 2014",
+      )
+      expect(await util.isWsl("win32", osRelease, pathToFile)).toBe(false)
+    })
+  })
+  describe("on Darwin", () => {
+    it("should return false", async () => {
+      const fileName = "proc-version4"
+      const osRelease =
+        "Darwin Roadrunner.local 10.3.0 Darwin Kernel Version 10.3.0: Fri Feb 26 11:58:09 PST 2010; root:xnu-1504.3.12~1/RELEASE_I386 i386"
+      const pathToFile = path.join(await tempDirHelper(testName), fileName)
+      expect(await util.isWsl("darwin", osRelease, pathToFile)).toBe(false)
+    })
+  })
+})
+
+describe("open", () => {
+  it("should throw an error if address is a string", async () => {
+    const address = "localhost:3000"
+    await expect(util.open(address)).rejects.toThrow("Cannot open socket paths")
+  })
+})
+describe("constructOpenOptions", () => {
+  it("should return options for darwin", () => {
+    const platform: NodeJS.Platform | "wsl" = "darwin"
+    const url = new URL("localhost:8080")
+    const { args, command, urlSearch } = util.constructOpenOptions(platform, url.search)
+    expect(args).toStrictEqual([])
+    expect(command).toBe("open")
+    expect(urlSearch).toBe("")
+  })
+  it("should return options for linux", () => {
+    const platform: NodeJS.Platform | "wsl" = "linux"
+    const url = new URL("localhost:8080")
+    const { args, command, urlSearch } = util.constructOpenOptions(platform, url.search)
+    expect(args).toStrictEqual([])
+    expect(command).toBe("xdg-open")
+    expect(urlSearch).toBe("")
+  })
+  it("should return options for win32", () => {
+    const platform: NodeJS.Platform | "wsl" = "win32"
+    const url = new URL("localhost:8080?q=&test")
+    const { args, command, urlSearch } = util.constructOpenOptions(platform, url.search)
+    expect(args).toStrictEqual(["/c", "start", '""', "/b"])
+    expect(command).toBe("cmd")
+    expect(urlSearch).toBe("?q=^&test")
+  })
+  it("should return options for wsl", () => {
+    const platform: NodeJS.Platform | "wsl" = "wsl"
+    const url = new URL("localhost:8080?q=&test")
+    const { args, command, urlSearch } = util.constructOpenOptions(platform, url.search)
+    expect(args).toStrictEqual(["/c", "start", '""', "/b"])
+    expect(command).toBe("cmd.exe")
+    expect(urlSearch).toBe("?q=^&test")
+  })
+})
+
+describe("splitOnFirstEquals", () => {
+  const tests = [
+    {
+      name: "empty",
+      key: "",
+      value: "",
+    },
+    {
+      name: "split on first equals",
+      key: "foo",
+      value: "bar",
+    },
+    {
+      name: "split on first equals even with multiple equals",
+      key: "foo",
+      value: "bar=baz",
+    },
+    {
+      name: "split with empty value",
+      key: "foo",
+      value: "",
+    },
+    {
+      name: "split with no value",
+      key: "foo",
+      value: undefined,
+    },
+  ]
+  tests.forEach((test) => {
+    it("should ${test.name}", () => {
+      const input = test.key && typeof test.value !== "undefined" ? `${test.key}=${test.value}` : test.key
+      const [key, value] = util.splitOnFirstEquals(input)
+      expect(key).toStrictEqual(test.key)
+      expect(value).toStrictEqual(test.value || undefined)
+    })
+  })
+})
diff --git a/test/utils/httpserver.ts b/test/utils/httpserver.ts
index 53d43de9..595ed348 100644
--- a/test/utils/httpserver.ts
+++ b/test/utils/httpserver.ts
@@ -7,7 +7,6 @@ import { Disposable } from "../../src/common/emitter"
 import * as util from "../../src/common/util"
 import { ensureAddress } from "../../src/node/app"
 import { disposer } from "../../src/node/http"
-
 import { handleUpgrade } from "../../src/node/wsRouter"
 
 // Perhaps an abstraction similar to this should be used in app.ts as well.
@@ -76,14 +75,25 @@ export class HttpServer {
   /**
    * Open a websocket against the request path.
    */
-  public ws(requestPath: string): Websocket {
+  public ws(requestPath: string, options?: Websocket.ClientOptions): Websocket {
     const address = ensureAddress(this.hs, "ws")
     if (typeof address === "string") {
       throw new Error("Cannot open websocket to socket path")
     }
     address.pathname = requestPath
 
-    return new Websocket(address.toString())
+    return new Websocket(address.toString(), options)
+  }
+
+  /**
+   * Open a websocket and wait for it to fully open.
+   */
+  public wsWait(requestPath: string, options?: Websocket.ClientOptions): Promise<Websocket> {
+    const ws = this.ws(requestPath, options)
+    return new Promise<Websocket>((resolve, reject) => {
+      ws.on("error", (err) => reject(err))
+      ws.on("open", () => resolve(ws))
+    })
   }
 
   public port(): number {
-- 
2.40.0

