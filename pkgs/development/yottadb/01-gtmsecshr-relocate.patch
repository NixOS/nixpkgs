diff --git a/sr_unix/gtmsecshr.c b/sr_unix/gtmsecshr.c
index 331dd504..1fa6c569 100755
--- a/sr_unix/gtmsecshr.c
+++ b/sr_unix/gtmsecshr.c
@@ -315,8 +315,8 @@ void gtmsecshr_init(char_ptr_t argv[], char **rundir, int *rundir_len)
 	int		file_des, save_errno, len = 0;
 	int		create_attempts = 0;
 	int		secshr_sem;
-	int		semop_res, rndirln, modlen, ydbdistlen;
-	char		*name_ptr, *rndir, *tmp_ptr, ydbdist[YDB_PATH_MAX];
+	int		semop_res, rndirln, modlen, parentdirlen;
+	char		*name_ptr, *rndir, *tmp_ptr, parentdir[YDB_PATH_MAX];
 	char		gtmsecshr_realpath[YDB_PATH_MAX];
 	char		*path, *chrrv;
 	pid_t		pid;
@@ -356,27 +356,31 @@ void gtmsecshr_init(char_ptr_t argv[], char **rundir, int *rundir_len)
 			RTS_ERROR_LITERAL("Server 1"), process_id, ERR_GTMSECSHRNOARG0);
 		gtmsecshr_exit(UNABLETODETERMINEPATH, FALSE);
 	}
-	path = ydb_dist;
-	chrrv = realpath(path, ydbdist);
+	/* NOTE: can we not do `realpath(ydb_dist)` directly, without `path`?
+	 * The first argument is not supposed to be modified in any way and
+	 * we're not using `path` anywhere else...
+	 */
+	path = ydb_dist;  /* ydb_dist is GBLREF */
+	chrrv = realpath(SECSHR_PARENT_DIR(path), parentdir);
 	if (NULL != chrrv)
 	{
-		ydbdistlen = STRLEN(ydbdist);
+		parentdirlen = STRLEN(parentdir);
 		/* Now compute the length of the string "$ydb_dist/gtmsecshrdir/gtmsecshr" */
-		if (SIZEOF(ydbdist) >= (ydbdistlen + STR_LIT_LEN(GTMSECSHR_DIR_SUFFIX) + 1 + SIZEOF(GTMSECSHR_EXECUTABLE)))
+		if (SIZEOF(parentdir) >= (parentdirlen + STR_LIT_LEN(GTMSECSHR_DIR_SUFFIX) + 1 + SIZEOF(GTMSECSHR_EXECUTABLE)))
 		{
-			tmp_ptr = ydbdist + ydbdistlen;
+			tmp_ptr = parentdir + parentdirlen;
 			memcpy(tmp_ptr, GTMSECSHR_DIR_SUFFIX, STR_LIT_LEN(GTMSECSHR_DIR_SUFFIX));
 			tmp_ptr += STR_LIT_LEN(GTMSECSHR_DIR_SUFFIX);
 			*tmp_ptr++ = '/';
 			memcpy(tmp_ptr, GTMSECSHR_EXECUTABLE, STR_LIT_LEN(GTMSECSHR_EXECUTABLE));
 			tmp_ptr += STR_LIT_LEN(GTMSECSHR_EXECUTABLE);
 			*tmp_ptr = '\0';
-			ydbdistlen = tmp_ptr - ydbdist;
+			parentdirlen = tmp_ptr - parentdir;
 		} else
-			ydbdistlen = 0;
+			parentdirlen = 0;
 	} else
-		ydbdistlen = 0;
-	if ((rndirln != ydbdistlen) || (0 != memcmp(rndir, ydbdist, rndirln)))
+		parentdirlen = 0;
+	if ((rndirln != parentdirlen) || (0 != memcmp(rndir, parentdir, rndirln)))
 	{
 		send_msg_csa(CSA_ARG(NULL) VARLSTCNT(6) ERR_GTMSECSHRSTART, 3,
 			RTS_ERROR_LITERAL("Server 2"), process_id, ERR_GTMSECSHRBADDIR);
@@ -386,12 +390,12 @@ void gtmsecshr_init(char_ptr_t argv[], char **rundir, int *rundir_len)
 	/* Take off the "/gtmsecshr" suffix (leaves "$ydb_dist/gtmsecshrdir") and use this to compare current working directory */
 	rndirln -= SIZEOF(GTMSECSHR_EXECUTABLE); /* SIZEOF includes 1 for trailing null byte but we use that for leading '/') */
 	rndir[rndirln] = '\0';			/* Terminate directory string (executable/dir name already checked) */
-	chrrv = getcwd(ydbdist, YDB_PATH_MAX);	/* Use ydbdist 'cause it's convenient */
+	chrrv = getcwd(parentdir, YDB_PATH_MAX);	/* Use parentdir 'cause it's convenient */
 	if (NULL != chrrv)
-		ydbdistlen = STRLEN(ydbdist);
+		parentdirlen = STRLEN(parentdir);
 	else
-		ydbdistlen = 0;
-	if ((rndirln != ydbdistlen) || (0 != memcmp(rndir, ydbdist, rndirln)))
+		parentdirlen = 0;
+	if ((rndirln != parentdirlen) || (0 != memcmp(rndir, parentdir, rndirln)))
 	{
 		send_msg_csa(CSA_ARG(NULL) VARLSTCNT(6) ERR_GTMSECSHRSTART, 3,
 			RTS_ERROR_LITERAL("Server 3"), process_id, ERR_GTMSECSHRBADDIR);
diff --git a/sr_unix/gtmsecshr.h b/sr_unix/gtmsecshr.h
index 80c41c7f..96ec47e2 100755
--- a/sr_unix/gtmsecshr.h
+++ b/sr_unix/gtmsecshr.h
@@ -62,6 +62,14 @@
 #define GTMSECSHR_DIR_SUFFIX		"/gtmsecshrdir"
 #define GTMSECSHR_EXECUTABLE		"gtmsecshr"

+#ifdef YDB_EXTERNAL_SECSHR_PARENT_DIR
+#define SECSHR_PARENT_DIR(x)      (YDB_EXTERNAL_SECSHR_PARENT_DIR)
+#define SECSHR_PARENT_DIR_LEN(x)  (STR_LIT_LEN(YDB_EXTERNAL_SECSHR_PARENT_DIR))
+#else
+#define SECSHR_PARENT_DIR(x)      (x)
+#define SECSHR_PARENT_DIR_LEN(x)  (x)
+#endif
+
 #define	ROOTUID				0

 #ifdef SHORT_GTMSECSHR_TIMEOUT
diff --git a/sr_unix/gtmsecshr_wrapper.c b/sr_unix/gtmsecshr_wrapper.c
index a9999cb5..d572a12e 100644
--- a/sr_unix/gtmsecshr_wrapper.c
+++ b/sr_unix/gtmsecshr_wrapper.c
@@ -70,6 +70,15 @@
 #define MAX_ENV_NAME_LEN 2048
 #define	PERMALL		07777

+/* NOTE: duplicate to gtmsecshr.h definitions, can we safely include it instead? */
+#ifdef YDB_EXTERNAL_SECSHR_PARENT_DIR
+#define SECSHR_PARENT_DIR(x)      (YDB_EXTERNAL_SECSHR_PARENT_DIR)
+#define SECSHR_PARENT_DIR_LEN(x)  (STR_LIT_LEN(YDB_EXTERNAL_SECSHR_PARENT_DIR))
+#else
+#define SECSHR_PARENT_DIR(x)      (x)
+#define SECSHR_PARENT_DIR_LEN(x)  (x)
+#endif
+
 /* Build up some defines for use with AIX and reading /etc/environment to pick up a default TZ value plus some defines
  * for testing AIX errors in this wrapper with white box test cases.
  */
@@ -310,7 +319,7 @@ int main()
 	if (env_var_ptr = ydb_getenv(YDBENVINDX_DIST_ONLY, NULL_SUFFIX, NULL_IS_YDB_ENV_MATCH))	/* Warning - assignment */
 	{
 		if (MAX_ALLOWABLE_LEN <
-				(strlen(env_var_ptr) + STR_LIT_LEN(SUB_PATH_TO_GTMSECSHRDIR) + STR_LIT_LEN(GTMSECSHR_BASENAME)))
+				SECSHR_PARENT_DIR_LEN(strlen(env_var_ptr)) + STR_LIT_LEN(SUB_PATH_TO_GTMSECSHRDIR) + STR_LIT_LEN(GTMSECSHR_BASENAME))
 		{
 			SYSLOG(LOG_USER | LOG_INFO, ERR_SECSHRYDBDIST2LONG);
 			ret = -1;
@@ -319,13 +328,13 @@ int main()
 			snprintf(ydb_dist_val, SIZEOF(ydb_dist_val), "%s", env_var_ptr);
 			/* point the path to the real gtmsecshr - for display purposes only */
 			snprintf(gtm_secshr_path, MAX_ENV_VAR_VAL_LEN, "%s%s%s",
-					env_var_ptr, SUB_PATH_TO_GTMSECSHRDIR, GTMSECSHR_BASENAME);
+					SECSHR_PARENT_DIR(env_var_ptr), SUB_PATH_TO_GTMSECSHRDIR, GTMSECSHR_BASENAME);
 			strsanitize(gtm_secshr_path, gtm_secshr_path_display);
 			/* point the path to the real gtmsecshrdir */
-			snprintf(gtm_secshrdir_path, MAX_ENV_VAR_VAL_LEN, "%s%s", env_var_ptr, SUB_PATH_TO_GTMSECSHRDIR);
+			snprintf(gtm_secshrdir_path, MAX_ENV_VAR_VAL_LEN, "%s%s", SECSHR_PARENT_DIR(env_var_ptr), SUB_PATH_TO_GTMSECSHRDIR);
 			strsanitize(gtm_secshrdir_path, gtm_secshrdir_path_display);
 			/* the path to gtmsecshr wrapper that we want to display in a PS listing */
-			snprintf(gtm_secshr_orig_path, MAX_ENV_VAR_VAL_LEN, "%s%s", env_var_ptr, GTMSECSHR_BASENAME);
+			snprintf(gtm_secshr_orig_path, MAX_ENV_VAR_VAL_LEN, "%s%s", SECSHR_PARENT_DIR(env_var_ptr), GTMSECSHR_BASENAME);
 		}
 	} else
 	{
diff --git a/sr_unix/secshr_client.c b/sr_unix/secshr_client.c
index f9a5a6e8..aa6892d4 100755
--- a/sr_unix/secshr_client.c
+++ b/sr_unix/secshr_client.c
@@ -198,11 +198,11 @@ int send_mesg2gtmsecshr(unsigned int code, unsigned int id, char *path, int path
 	if (!gtmsecshr_file_check_done)
 	{
 		len = STRLEN(ydb_dist);
-		memcpy(gtmsecshr_path, ydb_dist, len);
-		gtmsecshr_path[len] =  '/';
-		memcpy(gtmsecshr_path + len + 1, GTMSECSHR_EXECUTABLE, STRLEN(GTMSECSHR_EXECUTABLE));
+		memcpy(gtmsecshr_path, SECSHR_PARENT_DIR(ydb_dist), SECSHR_PARENT_DIR_LEN(len));
+		gtmsecshr_path[SECSHR_PARENT_DIR_LEN(len)] =  '/';
+		memcpy(gtmsecshr_path + SECSHR_PARENT_DIR_LEN(len) + 1, GTMSECSHR_EXECUTABLE, STRLEN(GTMSECSHR_EXECUTABLE));
 		gtmsecshr_pathname.addr = gtmsecshr_path;
-		gtmsecshr_pathname.len = len + 1 + STRLEN(GTMSECSHR_EXECUTABLE);
+		gtmsecshr_pathname.len = SECSHR_PARENT_DIR_LEN(len) + 1 + STRLEN(GTMSECSHR_EXECUTABLE);
 		assertpro(YDB_PATH_MAX > gtmsecshr_pathname.len);
 		gtmsecshr_pathname.addr[gtmsecshr_pathname.len] = '\0';
 		if (-1 == Stat(gtmsecshr_pathname.addr, &stat_buf))
diff --git a/sr_unix/ydb_init.c b/sr_unix/ydb_init.c
index 9df28a39..c8d30466 100644
--- a/sr_unix/ydb_init.c
+++ b/sr_unix/ydb_init.c
@@ -287,10 +287,10 @@ int ydb_init()
 		else if (YDB_DIST_PATH_MAX <= dist_len)
 			rts_error_csa(CSA_ARG(NULL) VARLSTCNT(3) ERR_DISTPATHMAX, 1, YDB_DIST_PATH_MAX);
 		/* Verify that $ydb_dist/gtmsecshr is available with setuid root */
-		memcpy(path, ydb_dist, dist_len);
-		path[dist_len] =  '/';
-		memcpy(path + dist_len + 1, GTMSECSHR_EXECUTABLE, STRLEN(GTMSECSHR_EXECUTABLE));
-		path_len = dist_len + 1 + STRLEN(GTMSECSHR_EXECUTABLE);
+		memcpy(path, SECSHR_PARENT_DIR(ydb_dist), SECSHR_PARENT_DIR_LEN(dist_len));
+		path[SECSHR_PARENT_DIR_LEN(dist_len)] =  '/';
+		memcpy(path + SECSHR_PARENT_DIR_LEN(dist_len) + 1, GTMSECSHR_EXECUTABLE, STRLEN(GTMSECSHR_EXECUTABLE));
+		path_len = SECSHR_PARENT_DIR_LEN(dist_len) + 1 + STRLEN(GTMSECSHR_EXECUTABLE);
 		assertpro(YDB_PATH_MAX > path_len);
 		path[path_len] = '\0';
 		if (-1 == Stat(path, &stat_buf))
