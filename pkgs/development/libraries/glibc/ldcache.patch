diff --git a/elf/dl-load.c b/elf/dl-load.c
index 5b0ff41ee1..fc507542fb 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -1999,6 +1999,80 @@ open_path (const char *name, size_t namelen, int mode,
   return -1;
 }
 
+static const char *
+_dl_find_nixos_cache(struct link_map *loader)
+{
+  const ElfW(Phdr) *phdr = loader->l_phdr, *pend = phdr + loader->l_phnum;
+  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+    _dl_debug_printf("find nixos cache %lx -> %lx\n", (long) phdr, (long) pend);
+  for (; phdr != pend; phdr++) {
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf("  try phdr %lx\n", (long) phdr);
+    if (phdr->p_type != PT_NOTE) continue;
+    const ElfW(Nhdr) *nhdr = (const void *) (phdr->p_vaddr + loader->l_addr);
+    size_t size = phdr->p_memsz;
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf("    found notes %lx size %lx\n", (long) nhdr, (long) size);
+    while (size >= sizeof *nhdr) {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+        _dl_debug_printf("      check note namesz %x descsz %x\n", nhdr->n_namesz, nhdr->n_descsz);
+      const size_t noteSize = sizeof *nhdr + ALIGN_UP(nhdr->n_namesz, 4) + ALIGN_UP(nhdr->n_descsz, 4);
+      if (size < noteSize) break;
+      size -= noteSize;
+      const char *nname = (const char *) (nhdr + 1);
+      const char *desc = (const char *) (nhdr + 1) + ALIGN_UP(nhdr->n_namesz, 4);
+      if (nhdr->n_namesz == sizeof ELF_NOTE_NIXOS
+          && memcmp(nname, ELF_NOTE_NIXOS, sizeof ELF_NOTE_NIXOS) == 0
+          && nhdr->n_type == NT_NIXOS_LD_CACHE
+          && nhdr->n_descsz > 2
+          && desc[nhdr->n_descsz - 2] == '\0'
+          && desc[nhdr->n_descsz - 1] == '\0') {
+        if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+          _dl_debug_printf("      found!\n");
+        return desc;
+      }
+      nhdr = (const void *) nhdr + noteSize;
+    }
+  }
+
+  return NULL;
+}
+
+static int
+_dl_lookup_nixos_cache(struct link_map *loader, const char *name, char **realname)
+{
+  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+    _dl_debug_printf("lookup from cache %s\n", name);
+  const char *entries = _dl_find_nixos_cache(loader);
+  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+    _dl_debug_printf("  cache is %lx\n", (long) entries);
+  if (entries == NULL)
+    return 0;
+
+  while (entries[0] != '\0') {
+    const char *ename = entries;
+    const char *epath = ename + strlen(ename) + 1;
+    if (epath[0] == '\0') {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+        _dl_debug_printf("    broken cache\n");
+      return 0;
+    }
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf("    match %s\n", ename);
+    if (strcmp(name, ename) == 0) {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+        _dl_debug_printf("    found: %s\n", epath);
+      *realname = strdup(epath);
+      return *realname != NULL;
+    }
+    entries = epath + strlen(epath) + 1;
+  }
+
+  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+    _dl_debug_printf("  not found\n");
+  return 0;
+}
+
 /* Map in the shared object file NAME.  */
 
 struct link_map *
@@ -2142,6 +2216,22 @@ _dl_map_object (struct link_map *loader, const char *name,
 			loader ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded,
 			LA_SER_LIBPATH, &found_other_class);
 
+      /* look at nixos resolution cache notes, if available. we'll only
+         check the loader itself (no fallbacks) because this is only a
+         cache, and on some architectures (eg armv7) neither loader nor
+         the GL(dl_ns)[x]._ns_loaded fallback are set during initial
+         load when running ld.so explicitly. loader *is* set when running
+         normally, so we'll always hit the cache if it exists. */
+      if (loader != NULL
+          && fd == -1
+          && _dl_lookup_nixos_cache(loader, name, &realname)) {
+        fd = open_verify (realname, fd, &fb, loader,
+                          LA_SER_RUNPATH, mode, &found_other_class,
+                          false);
+        if (fd == -1)
+          free(realname);
+      }
+
       /* Look at the RUNPATH information for this binary.  */
       if (fd == -1 && loader != NULL
 	  && cache_rpath (loader, &loader->l_runpath_dirs,
diff --git a/elf/elf.h b/elf/elf.h
index 0735f6b579..7b9b74a4bc 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -1261,12 +1261,23 @@ typedef struct
 /* Note entries for freedesktop.org have this name.  */
 #define ELF_NOTE_FDO		"FDO"
 
+/* Note entries for Nixpkgs/NixOS have this name.  */
+#define ELF_NOTE_NIXOS	"NixOS"
+
 /* Defined types of notes for Solaris.  */
 
 /* Value of descriptor (one word) is desired pagesize for the binary.  */
 #define ELF_NOTE_PAGESIZE_HINT	1
 
 
+/* Defined note types for Nixpkgs/NixOS systems.  */
+
+/* Linker resolution cache. The descriptor consists of pairs of
+   null-terminated strings: (needed, libpath).
+   needed should match a DT_NEEDED entry, libpath provides the
+   search path for this single entry. */
+#define NT_NIXOS_LD_CACHE 0x63a86cb6
+
 /* Defined note types for GNU systems.  */
 
 /* ABI information.  The descriptor consists of words:
