diff --git a/elf/dl-load.c b/elf/dl-load.c
index aaaaaaa..bbbbbbb 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -90,20 +90,22 @@ struct filebuf
 #if __WORDSIZE == 32
 # define FILEBUF_SIZE 512
 #else
 # define FILEBUF_SIZE 832
 #endif
   char buf[FILEBUF_SIZE] __attribute__ ((aligned (__alignof (ElfW(Ehdr)))));
 };
 
 /* This is the decomposed LD_LIBRARY_PATH search path.  */
 static struct r_search_path_struct env_path_list attribute_relro;
+/* This is the decomposed LD_FALLBACK_PATH search path.  */
+static struct r_search_path_struct fallback_path_list attribute_relro;
 
 /* List of the hardware capabilities we might end up using.  */
 static const struct r_strlenpair *capstr attribute_relro;
 static size_t ncapstr attribute_relro;
 static size_t max_capstrlen attribute_relro;
 
 
 /* Get the generated information about the trusted directories.  Use
    an array of concatenated strings to avoid relocations.  See
    gen-trusted-dirs.awk.  */
@@ -612,21 +614,21 @@ cache_rpath (struct link_map *l,
     }
 
   /* Make sure the cache information is available.  */
   return decompose_rpath (sp, (const char *) (D_PTR (l, l_info[DT_STRTAB])
 					      + l->l_info[tag]->d_un.d_val),
 			  l, what);
 }
 
 
 void
-_dl_init_paths (const char *llp)
+_dl_init_paths (const char *llp, const char *lfp)
 {
   size_t idx;
   const char *strp;
   struct r_search_path_elem *pelem, **aelem;
   size_t round_size;
   struct link_map __attribute__ ((unused)) *l = NULL;
   /* Initialize to please the compiler.  */
   const char *errstring = NULL;
 
   /* Fill in the information about the application's RPATH and the
@@ -760,20 +762,59 @@ _dl_init_paths (const char *llp)
       if (env_path_list.dirs[0] == NULL)
 	{
 	  free (env_path_list.dirs);
 	  env_path_list.dirs = (void *) -1;
 	}
 
       env_path_list.malloced = 0;
     }
   else
     env_path_list.dirs = (void *) -1;
+
+  /* Made by copying the above followed by
+      %s/llp/lfp/g
+      %s/env_path_list/fallback_path_list/g
+      %s/LIBRARY_PATH/FALLBACK_PATH/g
+   */
+  if (lfp != NULL && *lfp != '\0')
+    {
+      char *lfp_tmp = strdupa (lfp);
+
+      /* Decompose the LD_FALLBACK_PATH contents.  First determine how many
+	 elements it has.  */
+      size_t nlfp = 1;
+      for (const char *cp = lfp_tmp; *cp != '\0'; ++cp)
+	if (*cp == ':' || *cp == ';')
+	  ++nlfp;
+
+      fallback_path_list.dirs = (struct r_search_path_elem **)
+	malloc ((nlfp + 1) * sizeof (struct r_search_path_elem *));
+      if (fallback_path_list.dirs == NULL)
+	{
+	  errstring = N_("cannot create cache for search path");
+	  goto signal_error;
+	}
+
+      (void) fillin_rpath (lfp_tmp, fallback_path_list.dirs, ":;",
+			   "LD_FALLBACK_PATH", NULL, l);
+
+      if (fallback_path_list.dirs[0] == NULL)
+	{
+	  free (fallback_path_list.dirs);
+	  fallback_path_list.dirs = (void *) -1;
+	}
+
+      fallback_path_list.malloced = 0;
+    }
+  else
+    fallback_path_list.dirs = (void *) -1;
+
 }
 
 
 static void
 __attribute__ ((noreturn, noinline))
 lose (int code, int fd, const char *name, char *realname, struct link_map *l,
       const char *msg, struct r_debug *r, Lmid_t nsid)
 {
   /* The file might already be closed.  */
   if (fd != -1)
@@ -1822,23 +1863,23 @@ open_path (const char *name, size_t namelen, int mode,
   while (*++dirs != NULL);
 
   /* Remove the whole path if none of the directories exists.  */
   if (__glibc_unlikely (! any))
     {
       /* Paths which were allocated using the minimal malloc() in ld.so
 	 must not be freed using the general free() in libc.  */
       if (sps->malloced)
 	free (sps->dirs);
 
-      /* rtld_search_dirs and env_path_list are attribute_relro, therefore
+      /* rtld_search_dirs, env_path_list, and fallback_path_list are attribute_relro, therefore
 	 avoid writing into it.  */
-      if (sps != &rtld_search_dirs && sps != &env_path_list)
+      if (sps != &rtld_search_dirs && sps != &env_path_list && sps != &fallback_path_list)
 	sps->dirs = (void *) -1;
     }
 
   return -1;
 }
 
 /* Map in the shared object file NAME.  */
 
 struct link_map *
 _dl_map_object (struct link_map *loader, const char *name,
@@ -2058,20 +2099,27 @@ _dl_map_object (struct link_map *loader, const char *name,
 				    false);
 		  if (__glibc_likely (fd != -1))
 		    realname = cached;
 		  else
 		    free (cached);
 		}
 	    }
 	}
 #endif
 
+      /* Try the LD_FALLBACK_PATH environment variable. */
+      if (fd == -1 && fallback_path_list.dirs != (void *) -1)
+	fd = open_path (name, namelen, mode, &fallback_path_list,
+			&realname, &fb,
+			loader ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded,
+			LA_SER_DEFAULT, &found_other_class);
+
       /* Finally, try the default path.  */
       if (fd == -1
 	  && ((l = loader ?: GL(dl_ns)[nsid]._ns_loaded) == NULL
 	      || __glibc_likely (!(l->l_flags_1 & DF_1_NODEFLIB)))
 	  && rtld_search_dirs.dirs != (void *) -1)
 	fd = open_path (name, namelen, mode, &rtld_search_dirs,
 			&realname, &fb, l, LA_SER_DEFAULT, &found_other_class);
 
       /* Add another newline when we are tracing the library loading.  */
       if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
@@ -2241,19 +2289,22 @@ _dl_rtld_di_serinfo (struct link_map *loader, Dl_serinfo *si, bool counting)
   add_path (&p, &env_path_list, XXX_ENV);
 
   /* Look at the RUNPATH information for this binary.  */
   if (cache_rpath (loader, &loader->l_runpath_dirs, DT_RUNPATH, "RUNPATH"))
     add_path (&p, &loader->l_runpath_dirs, XXX_RUNPATH);
 
   /* XXX
      Here is where ld.so.cache gets checked, but we don't have
      a way to indicate that in the results for Dl_serinfo.  */
 
+  /* Try the LD_FALLBACK_PATH environment variable.  */
+  add_path (&p, &fallback_path_list, XXX_default);
+
   /* Finally, try the default path.  */
   if (!(loader->l_flags_1 & DF_1_NODEFLIB))
     add_path (&p, &rtld_search_dirs, XXX_default);
 
   if (counting)
     /* Count the struct size before the string area, which we didn't
        know before we completed dls_cnt.  */
     si->dls_size += (char *) &si->dls_serpath[si->dls_cnt] - (char *) si;
 }
diff --git a/elf/dl-support.c b/elf/dl-support.c
index 114f77a..ad67d48 100644
--- a/elf/dl-support.c
+++ b/elf/dl-support.c
@@ -315,21 +315,21 @@ _dl_non_dynamic_init (void)
     HP_TIMING_NOW (_dl_cpuclock_offset);
 
   _dl_verbose = *(getenv ("LD_WARN") ?: "") == '\0' ? 0 : 1;
 
   /* Set up the data structures for the system-supplied DSO early,
      so they can influence _dl_init_paths.  */
   setup_vdso (NULL, NULL);
 
   /* Initialize the data structures for the search paths for shared
      objects.  */
-  _dl_init_paths (getenv ("LD_LIBRARY_PATH"));
+  _dl_init_paths (getenv ("LD_LIBRARY_PATH"), getenv ("LD_FALLBACK_PATH"));
 
   /* Remember the last search directory added at startup.  */
   _dl_init_all_dirs = GL(dl_all_dirs);
 
   _dl_lazy = *(getenv ("LD_BIND_NOW") ?: "") == '\0';
 
   _dl_bind_not = *(getenv ("LD_BIND_NOT") ?: "") != '\0';
 
   _dl_dynamic_weak = *(getenv ("LD_DYNAMIC_WEAK") ?: "") == '\0';
 
diff --git a/elf/rtld.c b/elf/rtld.c
index 453f56e..48b319e 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -814,20 +814,22 @@ security_init (void)
   /* We do not need the _dl_random value anymore.  The less
      information we leave behind, the better, so clear the
      variable.  */
   _dl_random = NULL;
 }
 
 #include "setup-vdso.h"
 
 /* The library search path.  */
 static const char *library_path attribute_relro;
+/* The fallback library search path.  */
+static const char *fallback_path attribute_relro;
 /* The list preloaded objects.  */
 static const char *preloadlist attribute_relro;
 /* Nonzero if information about versions has to be printed.  */
 static int version_info attribute_relro;
 
 /* The LD_PRELOAD environment variable gives list of libraries
    separated by white space or colons that are loaded before the
    executable's dependencies and prepended to the global scope list.
    (If the binary is running setuid all elements containing a '/' are
    ignored since it is insecure.)  Return the number of preloads
@@ -1311,21 +1313,21 @@ of this helper program; chances are you did not intend to run this program.\n\
   /* Set up the data structures for the system-supplied DSO early,
      so they can influence _dl_init_paths.  */
   setup_vdso (main_map, &first_preload);
 
 #ifdef DL_SYSDEP_OSCHECK
   DL_SYSDEP_OSCHECK (_dl_fatal_printf);
 #endif
 
   /* Initialize the data structures for the search paths for shared
      objects.  */
-  _dl_init_paths (library_path);
+  _dl_init_paths (library_path, fallback_path);
 
   /* Initialize _r_debug.  */
   struct r_debug *r = _dl_debug_initialize (GL(dl_rtld_map).l_addr,
 					    LM_ID_BASE);
   r->r_state = RT_CONSISTENT;
 
   /* Put the link_map for ourselves on the chain so it can be found by
      name.  Note that at this point the global chain of link maps contains
      exactly one element, which is pointed to by dl_loaded.  */
   if (! GL(dl_rtld_map).l_name)
@@ -2575,20 +2577,29 @@ process_envvars (enum mode *modep)
 	      && memcmp (envline, "DYNAMIC_WEAK", 12) == 0)
 	    GLRO(dl_dynamic_weak) = 1;
 	  break;
 
 	case 13:
 	  /* We might have some extra environment variable with length 13
 	     to handle.  */
 #ifdef EXTRA_LD_ENVVARS_13
 	  EXTRA_LD_ENVVARS_13
 #endif
+
+	  /* The library fallback search path.  */
+	  if (!__libc_enable_secure
+	      && memcmp (envline, "FALLBACK_PATH", 13) == 0)
+	    {
+	      fallback_path = &envline[14];
+	      break;
+	    }
+
 	  if (!__libc_enable_secure
 	      && memcmp (envline, "USE_LOAD_BIAS", 13) == 0)
 	    {
 	      GLRO(dl_use_load_bias) = envline[14] == '1' ? -1 : 0;
 	      break;
 	    }
 	  break;
 
 	case 14:
 	  /* Where to place the profiling data file.  */
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index 0ea2786..7786212 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -974,21 +974,21 @@ extern void _dl_sort_maps (struct link_map **maps, unsigned int nmaps,
 extern void _dl_debug_state (void);
 rtld_hidden_proto (_dl_debug_state)
 
 /* Initialize `struct r_debug' if it has not already been done.  The
    argument is the run-time load address of the dynamic linker, to be put
    in the `r_ldbase' member.  Returns the address of the structure.  */
 extern struct r_debug *_dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
      attribute_hidden;
 
 /* Initialize the basic data structure for the search paths.  */
-extern void _dl_init_paths (const char *library_path) attribute_hidden;
+extern void _dl_init_paths (const char *library_path, const char *fallback_path) attribute_hidden;
 
 /* Gather the information needed to install the profiling tables and start
    the timers.  */
 extern void _dl_start_profile (void) attribute_hidden;
 
 /* The actual functions used to keep book on the calls.  */
 extern void _dl_mcount (ElfW(Addr) frompc, ElfW(Addr) selfpc);
 rtld_hidden_proto (_dl_mcount)
 
 /* This function is simply a wrapper around the _dl_mcount function
diff --git a/sysdeps/generic/unsecvars.h b/sysdeps/generic/unsecvars.h
index 5ea8a4a..0d01562 100644
--- a/sysdeps/generic/unsecvars.h
+++ b/sysdeps/generic/unsecvars.h
@@ -11,20 +11,21 @@
   "GCONV_PATH\0"							      \
   "GETCONF_DIR\0"							      \
   GLIBC_TUNABLES_ENVVAR							      \
   "HOSTALIASES\0"							      \
   "LD_AUDIT\0"								      \
   "LD_DEBUG\0"								      \
   "LD_DEBUG_OUTPUT\0"							      \
   "LD_DYNAMIC_WEAK\0"							      \
   "LD_HWCAP_MASK\0"							      \
   "LD_LIBRARY_PATH\0"							      \
+  "LD_FALLBACK_PATH\0"							      \
   "LD_ORIGIN_PATH\0"							      \
   "LD_PRELOAD\0"							      \
   "LD_PROFILE\0"							      \
   "LD_SHOW_AUXV\0"							      \
   "LD_USE_LOAD_BIAS\0"							      \
   "LOCALDOMAIN\0"							      \
   "LOCPATH\0"								      \
   "MALLOC_TRACE\0"							      \
   "NIS_PATH\0"								      \
   "NLSPATH\0"								      \
