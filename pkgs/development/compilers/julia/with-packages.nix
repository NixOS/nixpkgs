{ lib, callPackage, julia, fetchurl }:

# The function `withPackages` can be used to create a Julia environment
# with a specified set of packages as shown by the following example
#
# pkgs.julia-bin.withPackages
#   (p: with p; [ Plots ])
#   (p: with p; [
#     { pname = "Tokenize";
#       version = "0.5.25";
#       src = fetchurl {
#         url = "https://pkg.julialang.org/package/0796e94c-ce3b-5d07-9a54-7f471281c624/90538bf898832b6ebd900fa40f223e695970e3a5";
#         name = "julia-bin-1.8.3-Tokenize-0.5.25.tar.gz";
#         sha256 = "00437718f09d81958e86c2131f3f8b63e0975494e505f6c7b62f872a5a102f51";
#       };
#       juliaPath = "Tokenize/d4Pxs";
#     }
#
#     { pname = "CSTParser";
#       version = "3.3.6";
#       src = fetchurl {
#         url = "https://pkg.julialang.org/package/00ebfdb7-1f24-5e51-bd34-a7502290713f/3ddd48d200eb8ddf9cb3e0189fc059fd49b97c1f";
#         name = "julia-bin-1.8.3-CSTParser-3.3.6.tar.gz";
#         sha256 = "647fc5588cb87362d216401a0a4124d41b80a85618a94098a737ad38ae5786c4";
#       };
#       juliaPath = "CSTParser/VcYj6";
#       requiredJuliaPackages = [ Tokenize ];
#     }
#   ])
#
# The first argument specifies a list of packages available in `<nixpkgs>`. The second one
# a list of upstream packages specified by a package definition. These definitions can be
# automatically generated by `julia2nix`. For all of them the package attribute name
# is equal to the `pname` of the package.
#
# The reason for using the attribute `requiredJuliaPackages` rather than
# `propagatedBuildInputs` is that the dependencies must be installed as well.
#
# Packages artifacts are specified in a similar way with the addition of the
# `isArtifact` attribute. This is so because they need to be treated differently.
# The attribute 'juliaPath' is the relative path in the collection of packages
# and is calculated by Julia's package manager and uniquely identify a package.

let juliaPackages = lib.recurseIntoAttrs
      (callPackage ../../../top-level/julia-packages.nix { inherit julia; }).pkgs;

    dropDuplicates = nixPkgsList: upPkgsList:
      let isInNixList = p: lib.elem p.juliaPath nixPkgsPath;
          nixPkgsPath = builtins.catAttrs "juliaPath" nixPkgsList;
      in lib.foldl' (acc: e: if isInNixList e then acc else acc ++ [ e ]) nixPkgsList upPkgsList;

    withPackages = nix: upstream:
      let nixPackages = (nix juliaPackages);
          packagesFromUpstream = ps: builtins.map (p: upstreamPkgs."${p.pname}") ps;

          juliaUpstreamPackagesFromList = pkgsList:
            lib.foldr (p: a: a // { ${p.pname} = juliaPackages.buildJuliaPackage (p // { packageCollection = "upstream"; }); }) {} pkgsList;

          upstreamPackages = (packagesFromUpstream upstreamPkgsList);

          upstreamPkgsList = upstream upstreamPkgs;

          upstreamPkgs = juliaUpstreamPackagesFromList upstreamPkgsList;

      in callPackage ./build-env.nix {
        inherit julia;
        extraPackages = dropDuplicates (juliaPackages.computeRequiredJuliaPackages nixPackages) upstreamPackages;
      };

    juliaWithPkgs = julia.overrideAttrs (finalAttrs: previousAttrs:
      { passthru = let passthru' = { juliaPackages = juliaPackages;
                                     withPackages = withPackages;
                                   };
                   in if previousAttrs ? passthru
                      then previousAttrs.passthru // passthru'
                      else passthru';
      });

in juliaWithPkgs
