#! /bin/sh

if [ "$1" = "--playback" ]; then
  shift
  PLAYBACK=1
fi

# setup-hook opens a file descriptor directing to stderr so that the
# played-back stderr is not interfered with
[ -n "${RECORD_PLAYBACK_LOG_FD:-}" ] || RECORD_PLAYBACK_LOG_FD=2

# If someone can explain why wrapping the printfs in curly braces and
# directing fd2 to /dev/null is necessary to avoid "Bad file
# descriptor" error when invoked from buildRubyGems's 'gem build', I'd
# much appreciate it. (Observed on darwin, so maybe that's to blame.)
warn() {
  { printf "$@" >&$RECORD_PLAYBACK_LOG_FD; } 2>/dev/null
  { printf "\n" >&$RECORD_PLAYBACK_LOG_FD; } 2>/dev/null
}

cmd="$1"; shift
dir=".record-playback/$cmd/$(printf %s "$*" | sha256sum | cut -d' ' -f1)"

if [ -n "$PLAYBACK" ]; then
  if [ ! -d "$dir" ]; then
    warn "failed to playback \`%s %s': %.28s...: no recorded output found" "$cmd" "$*" "$dir"
    exit 100
  fi

  warn "playing back \`%s %s' from %.28s..." "$cmd" "$*" "$dir"
  (exec cat "$dir"/stdout) &
  (exec cat "$dir"/stderr >&2) &
  wait
  exit "$(cat "$dir"/exitval)"
else
  warn "recording \`%s %s' in %.28s..." "$cmd" "$*" "$dir"
  mkdir -p "$dir"
  printf "%s" "$*" > "$dir"/args
  exitval=0
  "$cmd" "$@" 1>"$dir"/stdout 2>"$dir"/stderr || exitval="$?"
  printf %s "$exitval" >"$dir"/exitval
fi
