#! /bin/sh -e

url=$1
rev=$2
hash=$3

if test -z "$url"; then
    echo "syntax: nix-prefetch-svn URL [REVISION]" >&2
    exit 1
fi

test -n "$rev" || rev="HEAD"

# Use a restrictive umask to ensure that the output in the Nix store
# is not group- or world-writable.  Nix 0.10 complains about this.
umask 0022

# Determine the hash, unless it was given.
if test -z "$hash"; then

    # !!! hacky; we should have a way to query the location of the store.
    if storeDir=$(which nix-store); then
        storeDir=$(dirname $(dirname "$storeDir"))/store
    else
        storeDir=/nix/store
    fi

    # !!! race? should be relatively safe, `svn export' barfs if $tmpPath exists.
    tmpPath1=$storeDir/svn-checkout-tmp-$$

    # Test whether we have write permission in the store.  If not,
    # fetch to /tmp and don't copy to the store.  This is a hack to
    # make this script at least work somewhat in setuid installations.
    if ! touch $tmpPath1 2> /dev/null; then
        echo "(cannot write to the store, result won't be cached)" >&2
        dummyMode=1
        tmpPath1=/tmp/nix-prefetch-svn-$$ # !!! security?
    fi
    rm -f $tmpPath1

    # Perform the checkout.
    svn export -r "$rev" "$url" $tmpPath1 >&2

    # Compute the hash.
    hash=$(nix-hash $tmpPath1)
    echo "hash is $hash" >&2

    # Rename it so that the fetchsvn builder can find it.
    if test "$dummyMode" != 1; then
        tmpPath2=$storeDir/svn-checkout-tmp-$hash
        test -e $tmpPath2 || mv $tmpPath1 $tmpPath2 # !!! race
    fi
fi

# Create a Nix expression that does a fetchsvn.
nixExpr=$(dirname $(readlink -f $0))/../../system/i686-linux.nix
storeExpr=$( \
  echo "(import $nixExpr).fetchsvn {url=\"$url\"; rev=\"$rev\"; md5=\"$hash\";}" \
  | nix-instantiate -)

# Realise it.
finalPath=$(nix-store -r $storeExpr)

echo "path is $finalPath" >&2

if test -n "$tmpPath1" -o -n "$tmpPath2"; then
    rm -rf $tmpPath1 $tmpPath2 || true
fi

echo $hash

if test -n "$PRINT_PATH"; then
    echo $finalPath
fi
