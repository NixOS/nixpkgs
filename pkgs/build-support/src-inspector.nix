{ lib
, stdenv
, unzip
, runCommand
, writeText
, jq
}:

let
  mkSrcInspection = src: stdenv.mkDerivation {
    name = "${src.name or "unknown"}-inspection";
    inherit src;
    sourceRoot = ".";

    preUnpack = ''
      # a wheel is just a zip file
      if [[ "$src" = *.whl ]] ; then
        origSrc="$src"
        src="$(mktemp -d)/src.zip"
        ln -s "$origSrc" "$src"
      fi
    '';

    nativeBuildInputs = [ unzip ];

    dontPatch = true;
    dontConfigure = true;
    dontBuild = true;
    dontFixup = true;

    installPhase = ''
      mkdir -p $out
      find . \
        -type f \
        -size +0c \
        -name '*.jar' > $out/binaryBytecode || true
      # detect ELF, Mach-O (+multi-arch), PE executables
      find . \
        -type f \
        -size +0c \
        -exec sed -e '1b p ; Q1 ; :p ; /^\x7fELF/Q0 ; /^[\xce\xcf]\xfa\xed\xfe/Q0 ; /^\xca\xfe\xba\xbe/Q0 ; /^MZ/Q0 ; Q1' '{}' ';' \
        -print > $out/binaryNativeCode || true
    '';
  };

  inspectAllSrcs = allSourceFiles: builtins.mapAttrs (_: mkSrcInspection) allSourceFiles;

in rec {
  /* Generate a json structure of suspected non-source file contents used by
     packages in attrs pkgsForInspection.

     Results of the form:

     {
       "package-attr": {
         "src-name": {
           "source-type-name": [
             "./file/path/in/src"
           ]
         }
       }
     }

     Packages are expected to have a passthru named `allSourceFiles`, exposing
     all upstream source files used by the package as an attrset.
  */
  mkSrcInspectionReportJSON = pkgsForInspection: runCommand "src-inspection-report.json" {
    nativeBuildInputs = [ jq ];
    pkgsInspectionsJson = writeText "pkgs-inspections.json" (
      builtins.toJSON (builtins.mapAttrs (name: drv:
        if (builtins.tryEval (drv.drvPath or null)).success && lib.isDerivation drv && drv ? allSourceFiles
        then (inspectAllSrcs drv.allSourceFiles)
        else {}
      ) pkgsForInspection)
    );
  } ''
    suspectedFilesJsonL="$(mktemp)"

    # generate a separate object for each suspected file seen
    jq -cr 'to_entries | .[] | . as $pkg | .value
      | to_entries | .[] | . as $src | .value
      | @sh "export pkgKey=\($pkg.key) srcKey=\($src.key) inspDir=\(.)"' "$pkgsInspectionsJson" | while read -r varDefs ; do
      eval "$varDefs"  # unpack variables

      find "$inspDir" -type f -size +0c | while read -r inspectionFile ; do
        while read -r suspectedFile ; do
          export suspectedFile suspectedSrcType="$(basename $inspectionFile)"

          jq -cn '{(env.pkgKey): {(env.srcKey): {(env.suspectedSrcType): {(env.suspectedFile): true}}}}' \
            >> $suspectedFilesJsonL
        done < $inspectionFile
      done
    done

    # merge json-lines to a single final report object
    jq 'reduce .[] as $item ({}; . * $item) | .[][][] |= keys' -s $suspectedFilesJsonL > $out
  '';

  /* Generate an aggregated structure of suspected sourceTypes for packages in
     pkgsForInspection based on the contents of their source files.

     Results of the form:

     {
       "package-attr": [
         "source-type-name"
       ]
     }

     suitable for use with `applyInspectedSrcTypesJSON`. See mkSrcInspectionReportJSON
     for more details.
  */
  mkInspectedSrcTypesJSON = pkgsForInspection: runCommand "inspected-src-types.json" {
    nativeBuildInputs = [ jq ];
    reportJSON = mkSrcInspectionReportJSON pkgsForInspection;
  } ''
    jq '.[] |= ([.[] | keys] | flatten | unique)' "$reportJSON" > "$out"
  '';

  /* Supplied with the path of a json file containing suspected sourceTypes
     (as generated by mkInspectedSrcTypesJSON), returns an extension-function
     suitable for applying to an attrset of packages.
  */
  inspectedSrcTypesJSONExtension = jsonPath: self: super: builtins.mapAttrs (key: value: let
      inspectedSrcTypes = builtins.fromJSON (builtins.readFile jsonPath);
    in
      (if inspectedSrcTypes ? ${key} then value.overrideAttrs (oldAttrs: {
        meta = {
          sourceProvenance = (oldAttrs.meta.sourceProvenance or [])
            ++ (builtins.map (s: lib.sourceTypes.${s}) inspectedSrcTypes.${key});
        } // (oldAttrs.meta or {});
      }) else value)
  ) super;
}
