# This file defines the structure of the `config` nixpkgs option.

{ config, lib, ... }:

with lib;

let

  mkMassRebuild = args: mkOption (builtins.removeAttrs args [ "feature" ] // {
    type = args.type or (types.uniq types.bool);
    default = args.default or false;
    description = lib.mdDoc ((args.description or ''
      Whether to ${args.feature} while building nixpkgs packages.
    '') + ''
      Changing the default may cause a mass rebuild.
    '');
  });

  options = {

    /* Internal stuff */

    # Hide built-in module system options from docs.
    _module.args = mkOption {
      internal = true;
    };

    # Should be replaced by importing <nixos/modules/misc/assertions.nix> in the future
    # see also https://github.com/NixOS/nixpkgs/pull/207187
    warnings = mkOption {
      type = types.listOf types.str;
      default = [];
      internal = true;
    };
    assertions = mkOption {
      type = types.listOf types.anything;
      default = [];
      internal = true;
    };

    /* Config options */

    warnUndeclaredOptions = mkOption {
      description = lib.mdDoc "Whether to warn when `config` contains an unrecognized attribute.";
      type = types.bool;
      default = false;
    };

    doCheckByDefault = mkMassRebuild {
      feature = "run `checkPhase` by default";
    };

    strictDepsByDefault = mkMassRebuild {
      feature = "set `strictDeps` to true by default";
    };

    structuredAttrsByDefault = mkMassRebuild {
      feature = "set `__structuredAttrs` to true by default";
    };

    enableParallelBuildingByDefault = mkMassRebuild {
      feature = "set `enableParallelBuilding` to true by default";
    };

    configurePlatformsByDefault = mkMassRebuild {
      feature = "set `configurePlatforms` to `[\"build\" \"host\"]` by default";
    };

    contentAddressedByDefault = mkMassRebuild {
      feature = "set `__contentAddressed` to true by default";
    };

    allowAliases = mkOption {
      type = types.bool;
      default = true;
      description = lib.mdDoc ''
        Whether to expose old attribute names for compatibility.

        The recommended setting is to enable this, as it
        improves backward compatibity, easing updates.

        The only reason to disable aliases is for continuous
        integration purposes. For instance, Nixpkgs should
        not depend on aliases in its internal code. Projects
        that aren't Nixpkgs should be cautious of instantly
        removing all usages of aliases, as migrating too soon
        can break compatibility with the stable Nixpkgs releases.
      '';
    };

    allowUnfree = mkOption {
      type = types.bool;
      default = false;
      # getEnv part is in check-meta.nix
      defaultText = literalExpression ''false || builtins.getEnv "NIXPKGS_ALLOW_UNFREE" == "1"'';
      description = lib.mdDoc ''
        Whether to allow unfree packages.

        See [Installing unfree packages](https://nixos.org/manual/nixpkgs/stable/#sec-allow-unfree) in the NixOS manual.
      '';
    };

    allowBroken = mkOption {
      type = types.bool;
      default = false;
      # getEnv part is in check-meta.nix
      defaultText = literalExpression ''false || builtins.getEnv "NIXPKGS_ALLOW_BROKEN" == "1"'';
      description = lib.mdDoc ''
        Whether to allow broken packages.

        See [Installing broken packages](https://nixos.org/manual/nixpkgs/stable/#sec-allow-broken) in the NixOS manual.
      '';
    };

    allowUnsupportedSystem = mkOption {
      type = types.bool;
      default = false;
      # getEnv part is in check-meta.nix
      defaultText = literalExpression ''false || builtins.getEnv "NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM" == "1"'';
      description = lib.mdDoc ''
        Whether to allow unsupported packages.

        See [Installing packages on unsupported systems](https://nixos.org/manual/nixpkgs/stable/#sec-allow-unsupported-system) in the NixOS manual.
      '';
    };

    cudaSupport = mkMassRebuild {
      type = types.bool;
      default = false;
      feature = "build packages with CUDA support by default";
    };

    checkMeta = mkOption {
      type = types.bool;
      default = false;
      description = lib.mdDoc ''
        Whether to check that the `meta` attribute of derivations are correct during evaluation time.
      '';
    };

    problems =
      let
        inherit (import ../stdenv/generic/problems.nix { inherit lib; }) problemHandlers problemKinds;
        handlerType = types.enum problemHandlers;
        problemKindType = types.enum problemKinds;
      in
      {
        handlers = mkOption {
          type = with types; attrsOf (attrsOf handlerType);
          default = {};
          description = ''
            Specify how to handle packages with problems.
            Each key has the format `packageName.problemName`, each value is one of "error", "warn" or "ignore".

            This option takes precedence over anything in `problems.matchers`.

            Package names are taken from `lib.getName`, which looks at the `pname` first and falls back to extracting the "pname" part from the `name` attribute.

            See <link xlink:href="https://nixos.org/manual/nixpkgs/stable/#sec-ignore-problems">Installing packages with problems</link> in the NixOS manual.
          '';
        };

        matchers = mkOption {
          type = types.listOf (
            types.submodule ({config, ...}: {
              options = {
                package = mkOption {
                  type = types.nullOr types.str;
                  description = "Match problems of packages with this name";
                  default = null;
                };
                name = mkOption {
                  type = types.nullOr types.str;
                  description = "Match problems with this problem name";
                  default = null;
                };
                kind = mkOption {
                  type = types.nullOr problemKindType;
                  description = "Match problems of this problem kind";
                  default = null;
                };
                handler = mkOption {
                  type = handlerType;
                  description = "Specify the handler for matched problems";
                };

                # Temporary hack to get assertions in submodules, see global assertions below
                assertions = mkOption {
                  type = types.listOf types.anything;
                  default = [];
                  internal = true;
                };
              };
              config = {
                assertions = [
                  {
                    assertion = !(config.package != null && config.name != null);
                    message = ''A matcher cannot match on both a package and problem name as this would not be a wildcard, for that use `problems.handlers = { ${toString config.package}.${toString config.name} = "${toString config.handler}"; };` instead'';
                  }
                ];
              };
            })
          );
          default = [];
          description = ''
            A more powerful and less ergonomic version of `problems.handlers`.
            Each value is a matcher, that may match onto certain properties of a problem and specify a handler for them.

            If multiple matchers match a problem, the handler with the highest severity (error > warn > ignore) will be used.
            Values in `problems.handlers` always take precedence over matchers.

            Any matchers must not contain both a `package` and `name` field, for this should be handled by using `problems.handlers` instead.
          '';
          example = [
            {
              kind = "maintainerless";
              handler = "warn";
            }
            {
              package = "myPackageICareAbout";
              handler = "error";
            }
          ];
        };
      };
  };

in {

  freeformType =
    let t = lib.types.lazyAttrsOf lib.types.raw;
    in t // {
      merge = loc: defs:
        let r = t.merge loc defs;
        in r // { _undeclared = r; };
    };

  imports = [
    (mkRemovedOptionModule ["showDerivationWarnings"] "See `config.problems.matchers` and the respective documentation. Be aware that the semantics have changed!")
  ];


  inherit options;

  config = {
    warnings = lib.optionals config.warnUndeclaredOptions (
      lib.mapAttrsToList (k: v: "undeclared Nixpkgs option set: config.${k}") config._undeclared or {}
    );

    assertions =
      # Collect the assertions from the problems.matchers.* submodules, propagate them into here
      lib.concatMap (matcher: matcher.assertions) config.problems.matchers;

    # Put the default value for matchers in here (as in, not as an *actual* mkDefault default value),
    # to force it being merged with any custom values instead of being overridden.
    problems.matchers = [
      # Be loud and clear about package removals
      {
        kind = "removal";
        handler = "error";
      }
      {
        kind = "maintainerless";
        handler = "ignore";
      }
      # Wildcard for everything else
      {
        handler = "ignore";
      }
    ];
  };

}
