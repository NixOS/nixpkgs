mod appearance;
mod entries;
mod install;

use std::{
	collections::HashSet,
	fmt::Write as _,
	fs,
	os::{linux::fs::MetadataExt, unix::fs::PermissionsExt},
	path::{Path, PathBuf},
	sync::LazyLock,
};

use eyre::{Context, Result};

use crate::{config::Config, grub::Grub};

pub struct Builder<'conf> {
	config: Config<'conf>,

	grub_boot: Grub,
	grub_store: Option<Grub>,

	default_config: &'conf Path,
	copied: HashSet<PathBuf>,

	inner: String,
}

impl<'conf> Builder<'conf> {
	pub fn new(mut config: Config<'conf>, default_config: &'conf Path) -> Result<Self> {
		unless_dry_run(|| {
			let grub = config.boot_path.join("grub");
			fs::create_dir_all(&grub).context("Failed to create GRUB directory in boot path")?;
			fs::set_permissions(&grub, fs::Permissions::from_mode(0o700))
				.context("Failed to make GRUB directory executable")?;
			Ok(())
		})?;

		// Discover whether the bootPath is on the same filesystem as / and
		// the Nix store.  If not, then all kernels and initrds must be copied
		// to the bootPath.
		if let Ok(metadata) = config.boot_path.metadata() {
			if metadata.st_dev() != Path::new(config.store_dir).metadata()?.st_dev() {
				config.copy_kernels = true;
			}
		}

		let grub_boot = Grub::new(config.boot_path, &config)?;
		let grub_store = if !config.copy_kernels {
			Some(Grub::new(config.store_path, &config)?)
		} else {
			None
		};

		Ok(Self {
			config,
			grub_boot,
			grub_store,
			default_config,
			copied: HashSet::new(),
			inner: String::from("# Automatically generated.  DO NOT EDIT THIS FILE!\n\n"),
		})
	}

	pub fn users(&mut self) -> Result<&mut Self> {
		for (name, password) in self.config.users.0.iter() {
			writeln!(
				&mut self.inner,
				"{} {name} {}",
				if password.is_hashed {
					"password_pbkdf2"
				} else {
					"password"
				},
				password.content
			)?
		}

		let usernames: Vec<_> = self.config.users.0.keys().copied().collect();
		if !usernames.is_empty() {
			writeln!(
				&mut self.inner,
				r#"set superusers="{}""#,
				usernames.join(" ")
			)?;
		}

		if let Some(store) = &self.grub_store {
			writeln!(&mut self.inner, "{}", store.search)?;
		}

		Ok(self)
	}

	pub fn default_entry(&mut self) -> Result<&mut Self> {
		// FIXME: should use grub-mkconfig.
		let default_entry = if self.config.save_default() {
			r#""${saved_entry}""#
		} else {
			self.config.default_entry
		};

		let Config {
			timeout,
			timeout_style,
			..
		} = &self.config;

		writeln!(
			&mut self.inner,
			r#"{search}
if [ -s $prefix/grubenv ]; then
  load_env
fi

# ‘grub-reboot’ sets a one-time saved entry, which we process here and
# then delete.
if [ "${{next_entry}}" ]; then
  set default="${{next_entry}}"
  set next_entry=
  save_env next_entry
  set timeout=1
  set boot_once=true
else
  set default={default_entry}
  set timeout={timeout}
fi
set timeout_style={timeout_style}

function savedefault {{
  if [ -z "${{boot_once}}"]; then
    saved_entry="${{chosen}}"
    save_env saved_entry
  fi
}}

# Setup the graphics stack for bios and efi systems
if [ "${{grub_platform}}" = "efi" ]; then
  insmod efi_gop
  insmod efi_uga
else
  insmod vbe
fi
"#,
			search = self.grub_boot.search,
		)?;

		Ok(self)
	}
}

pub(crate) fn unless_dry_run(f: impl FnOnce() -> Result<()>) -> Result<()> {
	static DRY_RUN: LazyLock<bool> =
		LazyLock::new(|| std::env::var("DRY_RUN").as_deref() == Ok("true"));

	if !*DRY_RUN { f() } else { Ok(()) }
}
