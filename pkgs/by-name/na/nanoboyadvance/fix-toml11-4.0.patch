From 41aa0b0c81d6e7b604c1646d52d8418ed2d8d99a Mon Sep 17 00:00:00 2001
From: Emily <hello@emily.moe>
Date: Mon, 15 Sep 2025 20:45:57 +0100
Subject: [PATCH] Platform: Core: Update to toml11 4.4.0

Comments are now preserved by default, and the APi gets a bit
simpler. Many Linux distributions have already moved to the new major
version, so this eases packaging.
---
 src/platform/core/CMakeLists.txt              |   4 +-
 src/platform/core/include/platform/config.hpp |   4 +-
 src/platform/core/src/config.cpp              | 176 ++++++++----------
 src/platform/qt/src/config.cpp                |  88 ++++-----
 src/platform/qt/src/config.hpp                |   4 +-
 5 files changed, 121 insertions(+), 155 deletions(-)

diff --git a/src/platform/core/CMakeLists.txt b/src/platform/core/CMakeLists.txt
index ddb4241f..02a97420 100644
--- a/src/platform/core/CMakeLists.txt
+++ b/src/platform/core/CMakeLists.txt
@@ -35,11 +35,11 @@ glad_add_library(glad_gl_core_33 STATIC
 )
 
 if(USE_SYSTEM_TOML11)
-  find_package(toml11 3.7 REQUIRED)
+  find_package(toml11 4.0 REQUIRED)
 else()
   FetchContent_Declare(toml11
     GIT_REPOSITORY https://github.com/ToruNiina/toml11.git
-    GIT_TAG        d4eb5f3c9d8557b3820c80d55c41068839341b27 # v3.8.1
+    GIT_TAG        be08ba2be2a964edcdb3d3e3ea8d100abc26f286 # v4.4.0
   )
   set(toml11_INSTALL OFF CACHE BOOL "" FORCE)
   FetchContent_MakeAvailable(toml11)
diff --git a/src/platform/core/include/platform/config.hpp b/src/platform/core/include/platform/config.hpp
index 89c6278a..7b0233d4 100644
--- a/src/platform/core/include/platform/config.hpp
+++ b/src/platform/core/include/platform/config.hpp
@@ -47,9 +47,7 @@ struct PlatformConfig : Config {
 
 protected:
   virtual void LoadCustomData(toml::value const& data) {}
-  virtual void SaveCustomData(
-    toml::basic_value<toml::preserve_comments>& data
-  ) {};
+  virtual void SaveCustomData(toml::value& data) {}
 };
 
 } // namespace nba
diff --git a/src/platform/core/src/config.cpp b/src/platform/core/src/config.cpp
index be382c94..e6a8e221 100644
--- a/src/platform/core/src/config.cpp
+++ b/src/platform/core/src/config.cpp
@@ -29,124 +29,108 @@ void PlatformConfig::Load(std::string const& path) {
   }
 
   if(data.contains("general")) {
-    auto general_result = toml::expect<toml::value>(data.at("general"));
-
-    if(general_result.is_ok()) {
-      auto general = general_result.unwrap();
-      this->bios_path = toml::find_or<std::string>(general, "bios_path", "bios.bin");
-      this->skip_bios = toml::find_or<toml::boolean>(general, "bios_skip", false);
-      this->save_folder = toml::find_or<std::string>(general, "save_folder", "");
-    }
+    auto general = data.at("general");
+    this->bios_path = toml::find_or<std::string>(general, "bios_path", "bios.bin");
+    this->skip_bios = toml::find_or<bool>(general, "bios_skip", false);
+    this->save_folder = toml::find_or<std::string>(general, "save_folder", "");
   }
 
   if(data.contains("cartridge")) {
-    auto cartridge_result = toml::expect<toml::value>(data.at("cartridge"));
-
-    if(cartridge_result.is_ok()) {
-      auto cartridge = cartridge_result.unwrap();
-      auto save_type = toml::find_or<std::string>(cartridge, "save_type", "detect");
-
-      const std::map<std::string, Config::BackupType> save_types{
-        { "detect",     Config::BackupType::Detect    },
-        { "none",       Config::BackupType::None      },
-        { "sram",       Config::BackupType::SRAM      },
-        { "flash64",    Config::BackupType::FLASH_64  },
-        { "flash128",   Config::BackupType::FLASH_128 },
-        { "eeprom512",  Config::BackupType::EEPROM_4  },
-        { "eeprom8192", Config::BackupType::EEPROM_64 }
-      };
-
-      auto match = save_types.find(save_type);
-
-      if(match == save_types.end()) {
-        Log<Warn>("Config: backup type '{0}' is not valid, defaulting to auto-detect.", save_type);
-        this->cartridge.backup_type = Config::BackupType::Detect;
-      } else {
-        this->cartridge.backup_type = match->second;
-      }
-
-      this->cartridge.force_rtc = toml::find_or<toml::boolean>(cartridge, "force_rtc", false);
-      this->cartridge.force_solar_sensor = toml::find_or<toml::boolean>(cartridge, "force_solar_sensor", false);
-      this->cartridge.solar_sensor_level = toml::find_or<int>(cartridge, "solar_sensor_level", 156);
+    auto cartridge = data.at("cartridge");
+    auto save_type = toml::find_or<std::string>(cartridge, "save_type", "detect");
+
+    const std::map<std::string, Config::BackupType> save_types{
+      { "detect",     Config::BackupType::Detect    },
+      { "none",       Config::BackupType::None      },
+      { "sram",       Config::BackupType::SRAM      },
+      { "flash64",    Config::BackupType::FLASH_64  },
+      { "flash128",   Config::BackupType::FLASH_128 },
+      { "eeprom512",  Config::BackupType::EEPROM_4  },
+      { "eeprom8192", Config::BackupType::EEPROM_64 }
+    };
+
+    auto match = save_types.find(save_type);
+
+    if(match == save_types.end()) {
+      Log<Warn>("Config: backup type '{0}' is not valid, defaulting to auto-detect.", save_type);
+      this->cartridge.backup_type = Config::BackupType::Detect;
+    } else {
+      this->cartridge.backup_type = match->second;
     }
+
+    this->cartridge.force_rtc = toml::find_or<bool>(cartridge, "force_rtc", false);
+    this->cartridge.force_solar_sensor = toml::find_or<bool>(cartridge, "force_solar_sensor", false);
+    this->cartridge.solar_sensor_level = toml::find_or<int>(cartridge, "solar_sensor_level", 156);
   }
 
   if(data.contains("video")) {
-    auto video_result = toml::expect<toml::value>(data.at("video"));
-
-    if(video_result.is_ok()) {
-      auto video = video_result.unwrap();
+    auto video = data.at("video");
   
-      const std::map<std::string, Video::Filter> filters{
-        { "nearest", Video::Filter::Nearest },
-        { "linear",  Video::Filter::Linear  },
-        { "sharp",   Video::Filter::Sharp   },
-        { "xbrz",    Video::Filter::xBRZ    },
-        { "lcd1x",   Video::Filter::Lcd1x   }
-      };
-
-      const std::map<std::string, Video::Color> color_corrections{
-        { "none",  Video::Color::No    },
-        { "higan", Video::Color::higan },
-        { "agb",   Video::Color::AGB   }
-      };
-
-      auto filter = toml::find_or<std::string>(video, "filter", "nearest");
-      auto filter_match = filters.find(filter);
-      if(filter_match != filters.end()) {
-        this->video.filter = filter_match->second;
-      }
-
-      auto color_correction = toml::find_or<std::string>(video, "color_correction", "ags");
-      auto color_correction_match = color_corrections.find(color_correction);
-      if(color_correction_match != color_corrections.end()) {
-        this->video.color = color_correction_match->second;  
-      }
-
-      this->video.lcd_ghosting = toml::find_or<bool>(video, "lcd_ghosting", true);
+    const std::map<std::string, Video::Filter> filters{
+      { "nearest", Video::Filter::Nearest },
+      { "linear",  Video::Filter::Linear  },
+      { "sharp",   Video::Filter::Sharp   },
+      { "xbrz",    Video::Filter::xBRZ    },
+      { "lcd1x",   Video::Filter::Lcd1x   }
+    };
+
+    const std::map<std::string, Video::Color> color_corrections{
+      { "none",  Video::Color::No    },
+      { "higan", Video::Color::higan },
+      { "agb",   Video::Color::AGB   }
+    };
+
+    auto filter = toml::find_or<std::string>(video, "filter", "nearest");
+    auto filter_match = filters.find(filter);
+    if(filter_match != filters.end()) {
+      this->video.filter = filter_match->second;
     }
+
+    auto color_correction = toml::find_or<std::string>(video, "color_correction", "ags");
+    auto color_correction_match = color_corrections.find(color_correction);
+    if(color_correction_match != color_corrections.end()) {
+      this->video.color = color_correction_match->second;  
+    }
+
+    this->video.lcd_ghosting = toml::find_or<bool>(video, "lcd_ghosting", true);
   }
 
   if(data.contains("audio")) {
-    auto audio_result = toml::expect<toml::value>(data.at("audio"));
-
-    if(audio_result.is_ok()) {
-      auto audio = audio_result.unwrap();
-      auto resampler = toml::find_or<std::string>(audio, "resampler", "cosine");
-
-      const std::map<std::string, Config::Audio::Interpolation> resamplers{
-        { "cosine",  Config::Audio::Interpolation::Cosine   },
-        { "cubic",   Config::Audio::Interpolation::Cubic    },
-        { "sinc64",  Config::Audio::Interpolation::Sinc_64  },
-        { "sinc128", Config::Audio::Interpolation::Sinc_128 },
-        { "sinc256", Config::Audio::Interpolation::Sinc_256 }
-      };
-
-      auto match = resamplers.find(resampler);
-
-      if(match == resamplers.end()) {
-        Log<Warn>("Config: unknown resampling algorithm: {} (defaulting to cosine).", resampler);
-        this->audio.interpolation = Config::Audio::Interpolation::Cosine;
-      } else {
-        this->audio.interpolation = match->second;
-      }
-
-      this->audio.volume = toml::find_or<int>(audio, "volume", 100);
-      this->audio.mp2k_hle_enable = toml::find_or<toml::boolean>(audio, "mp2k_hle_enable", false);
-      this->audio.mp2k_hle_cubic = toml::find_or<toml::boolean>(audio, "mp2k_hle_cubic", true);
-      this->audio.mp2k_hle_force_reverb = toml::find_or<toml::boolean>(audio, "mp2k_hle_force_reverb", true);
+    auto audio = data.at("audio");
+    auto resampler = toml::find_or<std::string>(audio, "resampler", "cosine");
+
+    const std::map<std::string, Config::Audio::Interpolation> resamplers{
+      { "cosine",  Config::Audio::Interpolation::Cosine   },
+      { "cubic",   Config::Audio::Interpolation::Cubic    },
+      { "sinc64",  Config::Audio::Interpolation::Sinc_64  },
+      { "sinc128", Config::Audio::Interpolation::Sinc_128 },
+      { "sinc256", Config::Audio::Interpolation::Sinc_256 }
+    };
+
+    auto match = resamplers.find(resampler);
+
+    if(match == resamplers.end()) {
+      Log<Warn>("Config: unknown resampling algorithm: {} (defaulting to cosine).", resampler);
+      this->audio.interpolation = Config::Audio::Interpolation::Cosine;
+    } else {
+      this->audio.interpolation = match->second;
     }
+
+    this->audio.volume = toml::find_or<int>(audio, "volume", 100);
+    this->audio.mp2k_hle_enable = toml::find_or<bool>(audio, "mp2k_hle_enable", false);
+    this->audio.mp2k_hle_cubic = toml::find_or<bool>(audio, "mp2k_hle_cubic", true);
+    this->audio.mp2k_hle_force_reverb = toml::find_or<bool>(audio, "mp2k_hle_force_reverb", true);
   }
 
   LoadCustomData(data);
 }
 
 void PlatformConfig::Save(std::string const& path) {
-  toml::basic_value<toml::preserve_comments> data;
+  toml::value data;
 
   if(std::filesystem::exists(path)) {
     try {
-      data = toml::parse<toml::preserve_comments>(path);
+      data = toml::parse(path);
     } catch (std::exception& ex) {
       Log<Error>("Config: error while parsing TOML configuration: {0}", ex.what());
       return;
diff --git a/src/platform/qt/src/config.cpp b/src/platform/qt/src/config.cpp
index 7fbc712b..7a658fca 100644
--- a/src/platform/qt/src/config.cpp
+++ b/src/platform/qt/src/config.cpp
@@ -9,66 +9,52 @@
 
 void QtConfig::LoadCustomData(toml::value const& data) {
   if(data.contains("input")) {
-    auto input_result = toml::expect<toml::value>(data.at("input"));
-
-    if(input_result.is_ok()) {
-      using Map = Input::Map;
-
-      auto input_ = input_result.unwrap();
-
-      input.controller_guid = toml::find_or<std::string>(input_, "controller_guid", "");
-      input.hold_fast_forward = toml::find_or<bool>(input_, "hold_fast_forward", true);
-
-      const auto get_map = [&](toml::value const& value, std::string key) {
-        return Map::FromArray(toml::find_or<std::array<int, 5>>(value, key, {0, -1, -1, -1, 0}));
-      };
-
-      input.fast_forward = get_map(input_, "fast_forward");
-    
-      if(input_.contains("gba")) {
-        auto gba_result = toml::expect<toml::value>(input_.at("gba"));
-
-        if(gba_result.is_ok()) {
-          auto gba = gba_result.unwrap();
-
-          input.gba[0] = get_map(gba, "a");
-          input.gba[1] = get_map(gba, "b");
-          input.gba[2] = get_map(gba, "select");
-          input.gba[3] = get_map(gba, "start");
-          input.gba[4] = get_map(gba, "right");
-          input.gba[5] = get_map(gba, "left");
-          input.gba[6] = get_map(gba, "up");
-          input.gba[7] = get_map(gba, "down");
-          input.gba[8] = get_map(gba, "r");
-          input.gba[9] = get_map(gba, "l");
-        }
-      }
+    using Map = Input::Map;
+
+    auto input_ = data.at("input");
+
+    input.controller_guid = toml::find_or<std::string>(input_, "controller_guid", "");
+    input.hold_fast_forward = toml::find_or<bool>(input_, "hold_fast_forward", true);
+
+    const auto get_map = [&](toml::value const& value, std::string key) {
+      return Map::FromArray(toml::find_or<std::array<int, 5>>(value, key, {0, -1, -1, -1, 0}));
+    };
+
+    input.fast_forward = get_map(input_, "fast_forward");
+  
+    if(input_.contains("gba")) {
+      auto gba = input_.at("gba");
+
+      input.gba[0] = get_map(gba, "a");
+      input.gba[1] = get_map(gba, "b");
+      input.gba[2] = get_map(gba, "select");
+      input.gba[3] = get_map(gba, "start");
+      input.gba[4] = get_map(gba, "right");
+      input.gba[5] = get_map(gba, "left");
+      input.gba[6] = get_map(gba, "up");
+      input.gba[7] = get_map(gba, "down");
+      input.gba[8] = get_map(gba, "r");
+      input.gba[9] = get_map(gba, "l");
     }
   }
 
   if(data.contains("window")) {
-    auto window_result = toml::expect<toml::value>(data.at("window"));
-
-    if(window_result.is_ok()) {
-      auto window_ = window_result.unwrap();
-
-      window.scale = toml::find_or<int>(window_, "scale", 2);
-      window.maximum_scale = toml::find_or<int>(window_, "maximum_scale", 0);
-      window.fullscreen = toml::find_or<bool>(window_, "fullscreen", false);
-      window.fullscreen_show_menu = toml::find_or<bool>(window_, "fullscreen_show_menu", false);
-      window.lock_aspect_ratio = toml::find_or<bool>(window_, "lock_aspect_ratio", true);
-      window.use_integer_scaling = toml::find_or<bool>(window_, "use_integer_scaling", false);
-      window.show_fps = toml::find_or<bool>(window_, "show_fps", false);
-      window.pause_emulator_when_inactive = toml::find_or<bool>(window_, "pause_emulator_when_inactive", true);
-    }
+    auto window_ = data.at("window");
+
+    window.scale = toml::find_or<int>(window_, "scale", 2);
+    window.maximum_scale = toml::find_or<int>(window_, "maximum_scale", 0);
+    window.fullscreen = toml::find_or<bool>(window_, "fullscreen", false);
+    window.fullscreen_show_menu = toml::find_or<bool>(window_, "fullscreen_show_menu", false);
+    window.lock_aspect_ratio = toml::find_or<bool>(window_, "lock_aspect_ratio", true);
+    window.use_integer_scaling = toml::find_or<bool>(window_, "use_integer_scaling", false);
+    window.show_fps = toml::find_or<bool>(window_, "show_fps", false);
+    window.pause_emulator_when_inactive = toml::find_or<bool>(window_, "pause_emulator_when_inactive", true);
   }
 
   recent_files = toml::find_or<std::vector<std::string>>(data, "recent_files", {});
 }
 
-void QtConfig::SaveCustomData(
-  toml::basic_value<toml::preserve_comments>& data
-) {
+void QtConfig::SaveCustomData(toml::value& data) {
   data["input"]["controller_guid"] = input.controller_guid;
   data["input"]["fast_forward"] = input.fast_forward.Array();
   data["input"]["hold_fast_forward"] = input.hold_fast_forward;
diff --git a/src/platform/qt/src/config.hpp b/src/platform/qt/src/config.hpp
index 91af8291..b305bf79 100644
--- a/src/platform/qt/src/config.hpp
+++ b/src/platform/qt/src/config.hpp
@@ -117,9 +117,7 @@ struct QtConfig final : nba::PlatformConfig {
 protected:
   void LoadCustomData(toml::value const& data) override;
 
-  void SaveCustomData(
-    toml::basic_value<toml::preserve_comments>& data
-  ) override;
+  void SaveCustomData(toml::value& data) override;
 
 private:
   auto GetConfigPath() const -> std::string {
