# This patch file is using `git diff ee4bdac 2efa42d` to generate
# with fix build error on c++11
# and comment some unnecessary files
# diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
# new file mode 100644
# index 0000000..aa8b44a
# --- /dev/null
# +++ b/.github/workflows/ci.yml
# @@ -0,0 +1,53 @@
# +name: CI
# +on: [push, pull_request]
# +
# +jobs:
# +  linux:
# +    runs-on: ubuntu-latest
# +    steps:
# +      - name: Checkout sources
# +        uses: actions/checkout@v3
# +      - name: Build
# +        run: |
# +          ./bootstrap.sh
# +          ./configure
# +          make
# +
# +  mingw-cross:
# +    strategy:
# +      matrix:
# +        arch: [i686, x86_64]
# +        include:
# +          - arch: i686
# +            os: mingw32
# +          - arch: x86_64
# +            os: mingw64
# +    runs-on: ubuntu-latest
# +    steps:
# +      - name: Install cross compiler
# +        run: |
# +          ARCH=${{ matrix.arch }}
# +          sudo apt-get install g++-mingw-w64-${ARCH//_/-}
# +      - name: Checkout
# +        uses: actions/checkout@v3
# +      - name: Build
# +        run: |
# +          ./bootstrap.sh
# +          ./configure --host=${{ matrix.arch }}-w64-mingw32 --prefix=/usr/${{ matrix.arch }}-w64-mingw32
# +          make
# +
# +  windows-msvc:
# +    strategy:
# +      matrix:
# +        platform: [Win32, x64]
# +    runs-on: windows-latest
# +    env:
# +      ACTIONS_ALLOW_UNSECURE_COMMANDS: true
# +    steps:
# +      - name: Checkout
# +        uses: actions/checkout@v3
# +      - name: Add MSBuild to PATH
# +        uses: microsoft/setup-msbuild@v1.3.1
# +      - name: Build
# +        run: |
# +          MSBuild.exe vcproj/mp4fpsmod.sln /m /p:Configuration=Release /p:Platform=${{ matrix.platform }}
diff --git a/Makefile.am b/Makefile.am
index f2fd330..2a3a618 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -21,4 +21,7 @@ AM_CPPFLAGS = \
     -I $(top_srcdir)/mp4v2/include \
     -I $(top_builddir)/mp4v2/include \
     -I $(top_srcdir)/mp4v2/src
+
+AM_CXXFLAGS = -std=c++11
+
 mp4fpsmod_LDADD = -l mp4v2 -L mp4v2/.libs
diff --git a/bootstrap.sh b/bootstrap.sh
index 6387b71..5a3a9e0 100755
--- a/bootstrap.sh
+++ b/bootstrap.sh
@@ -1,9 +1,8 @@
 #! /bin/sh -e
 
-mkdir -p "m4"
-
 echo "Running autoreconf..."
 autoreconf -ivf "$@"
+cd mp4v2; autoreconf -ivf "$@"; cd ..
 
 echo "Now run './configure' and then 'make' to build mp4fpsmod"
 
diff --git a/configure.ac b/configure.ac
index cafc4db..d42a927 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4,7 +4,7 @@ m4_define({{XX_VERSION}},m4_bregexp(VERSION_CPP,{{^return.*"\(.+\)";}},{{\1}}))
 changequote([,])dnl
 
 AC_INIT([mp4fpsmod], [XX_VERSION], [honeycomb77@gmail.com])
-AC_CONFIG_SUBDIRS([mp4v2])
+AX_SUBDIRS_CONFIGURE([mp4v2], [[--disable-shared], [--enable-static], [--disable-util]])
 
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_MACRO_DIR([m4])
diff --git a/m4/ax_subdirs_configure.m4 b/m4/ax_subdirs_configure.m4
new file mode 100644
index 0000000..00a0170
--- /dev/null
+++ b/m4/ax_subdirs_configure.m4
@@ -0,0 +1,337 @@
+# ===========================================================================
+#   https://www.gnu.org/software/autoconf-archive/ax_subdirs_configure.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_SUBDIRS_CONFIGURE( [subdirs], [mandatory arguments], [possibly merged arguments], [replacement arguments], [forbidden arguments])
+#
+# DESCRIPTION
+#
+#   AX_SUBDIRS_CONFIGURE attempts to be the equivalent of AC_CONFIG_SUBDIRS
+#   with customizable options for configure scripts.
+#
+#   Run the configure script for each directory from the comma-separated m4
+#   list 'subdirs'. This macro can be used multiple times. All arguments of
+#   this macro must be comma-separated lists.
+#
+#   All command line arguments from the parent configure script will be
+#   given to the subdirectory configure script after the following
+#   modifications (in that order):
+#
+#   1. The arguments from the 'mandatory arguments' list shall always be
+#   appended to the argument list.
+#
+#   2. The arguments from the 'possibly merged arguments' list shall be
+#   added if not present in the arguments of the parent configure script or
+#   merged with the existing argument otherwise.
+#
+#   3. The arguments from the 'replacement arguments' list shall be added if
+#   not present in the arguments of the parent configure script or replace
+#   the existing argument otherwise.
+#
+#   4. The arguments from the 'forbidden arguments' list shall always be
+#   removed from the argument list.
+#
+#   The lists 'mandatory arguments' and 'forbidden arguments' can hold any
+#   kind of argument. The 'possibly merged arguments' and 'replacement
+#   arguments' expect their arguments to be of the form --option-name=value.
+#
+#   This macro aims to remain as close as possible to the AC_CONFIG_SUBDIRS
+#   macro. It corrects the paths for '--cache-file' and '--srcdir' and adds
+#   '--disable-option-checking' and '--silent' if necessary.
+#
+#   This macro also sets the output variable subdirs_extra to the list of
+#   directories recorded with AX_SUBDIRS_CONFIGURE. This variable can be
+#   used in Makefile rules or substituted in configured files.
+#
+#   This macro shall do nothing more than managing the arguments of the
+#   configure script. Just like when using AC_CONFIG_SUBDIRS, it is up to
+#   the user to check any requirements or define and substitute any required
+#   variable for the remainder of the project.
+#
+#   Configure scripts recorded with AX_SUBDIRS_CONFIGURE may be executed
+#   before configure scripts recorded with AC_CONFIG_SUBDIRS.
+#
+#   Without additional arguments, the behaviour of AX_SUBDIRS_CONFIGURE
+#   should be identical to the behaviour of AC_CONFIG_SUBDIRS, apart from
+#   the contents of the variables subdirs and subdirs_extra (except that
+#   AX_SUBDIRS_CONFIGURE expects a comma-separated m4 list):
+#
+#     AC_CONFIG_SUBDIRS([something])
+#     AX_SUBDIRS_CONFIGURE([something])
+#
+#   This macro may be called multiple times.
+#
+#   Usage example:
+#
+#   Let us assume our project has 4 dependencies, namely A, B, C and D. Here
+#   are some characteristics of our project and its dependencies:
+#
+#   - A does not require any special option.
+#
+#   - we want to build B with an optional feature which can be enabled with
+#   its configure script's option '--enable-special-feature'.
+#
+#   - B's configure script is strange and has an option '--with-B=build'.
+#   After close inspection of its documentation, we don't want B to receive
+#   this option.
+#
+#   - C and D both need B.
+#
+#   - Just like our project, C and D can build B themselves with the option
+#   '--with-B=build'.
+#
+#   - We want C and D to use the B we build instead of building it
+#   themselves.
+#
+#   Our top-level configure script will be called as follows:
+#
+#     $ <path/to/configure> --with-A=build --with-B=build --with-C=build \
+#       --with-D=build --some-option
+#
+#   Thus we have to make sure that:
+#
+#   - neither B, C or D receive the option '--with-B=build'
+#
+#   - C and D know where to find the headers and libraries of B.
+#
+#   Under those conditions, we can use the AC_CONFIG_SUBDIRS macro for A,
+#   but need to use AX_SUBDIRS_CONFIGURE for B, C and D:
+#
+#   - B must receive '--enable-special-feature' but cannot receive
+#   '--with-B=build'
+#
+#   - C and D cannot receive '--with-B=build' (or else it would be built
+#   thrice) and need to be told where to find B (since we are building it,
+#   it would probably not be available in standard paths).
+#
+#   Here is a configure.ac snippet that solves our problem:
+#
+#     AC_CONFIG_SUBDIRS([dependencies/A])
+#     AX_SUBDIRS_CONFIGURE(
+#         [dependencies/B], [--enable-special-feature], [], [],
+#         [--with-B=build])
+#     AX_SUBDIRS_CONFIGURE(
+#         [[dependencies/C],[dependencies/D]],
+#         [],
+#         [[CPPFLAGS=-I${ac_top_srcdir}/dependencies/B -I${ac_top_builddir}/dependencies/B],
+#          [LDFLAGS=-L${ac_abs_top_builddir}/dependencies/B/.libs]],
+#         [--with-B=system],
+#         [])
+#
+#   If using automake, the following can be added to the Makefile.am (we use
+#   both $(subdirs) and $(subdirs_extra) since our example above used both
+#   AC_CONFIG_SUBDIRS and AX_SUBDIRS_CONFIGURE):
+#
+#     SUBDIRS = $(subdirs) $(subdirs_extra)
+#
+# LICENSE
+#
+#   Copyright (c) 2017 Harenome Ranaivoarivony-Razanajato <ranaivoarivony-razanajato@hareno.me>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   Under Section 7 of GPL version 3, you are granted additional permissions
+#   described in the Autoconf Configure Script Exception, version 3.0, as
+#   published by the Free Software Foundation.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+
+#serial 3
+
+AC_DEFUN([AX_SUBDIRS_CONFIGURE],
+[
+  dnl Calls to AC_CONFIG_SUBDIRS perform preliminary steps and build a list
+  dnl '$subdirs' which is used later by _AC_OUTPUT_SUBDIRS (used by AC_OUTPUT)
+  dnl to actually run the configure scripts.
+  dnl This macro performs similiar preliminary steps but uses
+  dnl AC_CONFIG_COMMANDS_PRE to delay the final tasks instead of building an
+  dnl intermediary list and relying on another macro.
+  dnl
+  dnl Since each configure script can get different options, a special variable
+  dnl named 'ax_sub_configure_args_<subdir>' is constructed for each
+  dnl subdirectory.
+
+  # Various preliminary checks.
+  AC_REQUIRE([AC_DISABLE_OPTION_CHECKING])
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])
+  AS_LITERAL_IF([$1], [],
+      [AC_DIAGNOSE([syntax], [$0: you should use literals])])
+
+  m4_foreach(subdir_path, [$1],
+  [
+    ax_dir="subdir_path"
+
+    dnl Build the argument list in a similiar fashion to AC_CONFIG_SUBDIRS.
+    dnl A few arguments found in the final call to the configure script are not
+    dnl added here because they rely on variables that may not yet be available
+    dnl (see below the part that is similiar to _AC_OUTPUT_SUBDIRS).
+    # Do not complain, so a configure script can configure whichever parts of a
+    # large source tree are present.
+    if test -d "$srcdir/$ax_dir"; then
+      _AC_SRCDIRS(["$ax_dir"])
+      # Remove --cache-file, --srcdir, and --disable-option-checking arguments
+      # so they do not pile up.
+      ax_args=
+      ax_prev=
+      eval "set x $ac_configure_args"
+      shift
+      for ax_arg; do
+        if test -n "$ax_prev"; then
+          ax_prev=
+          continue
+        fi
+        case $ax_arg in
+          -cache-file | --cache-file | --cache-fil | --cache-fi | --cache-f \
+          | --cache- | --cache | --cach | --cac | --ca | --c)
+            ax_prev=cache_file ;;
+          -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+          | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* \
+          | --c=*)
+            ;;
+          --config-cache | -C)
+            ;;
+          -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+            ax_prev=srcdir ;;
+          -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+            ;;
+          -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+            ax_prev=prefix ;;
+          -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* \
+          | --p=*)
+            ;;
+          --disable-option-checking)
+            ;;
+          *) case $ax_arg in
+              *\'*) ax_arg=$(AS_ECHO(["$ax_arg"]) | sed "s/'/'\\\\\\\\''/g");;
+            esac
+            AS_VAR_APPEND([ax_args], [" '$ax_arg'"]) ;;
+        esac
+      done
+      # Always prepend --disable-option-checking to silence warnings, since
+      # different subdirs can have different --enable and --with options.
+      ax_args="--disable-option-checking $ax_args"
+      # Options that must be added as they are provided.
+      m4_ifnblank([$2], [m4_foreach(opt, [$2], [AS_VAR_APPEND(ax_args, " 'opt'")
+      ])])
+      # New options that may need to be merged with existing options.
+      m4_ifnblank([$3], [m4_foreach(opt, [$3],
+          [ax_candidate="opt"
+           ax_candidate_flag="${ax_candidate%%=*}"
+           ax_candidate_content="${ax_candidate#*=}"
+           if test "x$ax_candidate" != "x" -a "x$ax_candidate_flag" != "x"; then
+             if echo "$ax_args" | grep -- "${ax_candidate_flag}=" >/dev/null 2>&1; then
+               [ax_args=$(echo $ax_args | sed "s,\(${ax_candidate_flag}=[^']*\),\1 ${ax_candidate_content},")]
+             else
+               AS_VAR_APPEND(ax_args, " 'opt'")
+             fi
+           fi
+      ])])
+      # New options that must replace existing options.
+      m4_ifnblank([$4], [m4_foreach(opt, [$4],
+          [ax_candidate="opt"
+           ax_candidate_flag="${ax_candidate%%=*}"
+           ax_candidate_content="${ax_candidate#*=}"
+           if test "x$ax_candidate" != "x" -a "x$ax_candidate_flag" != "x"; then
+             if echo "$ax_args" | grep -- "${ax_candidate_flag}=" >/dev/null 2>&1; then
+               [ax_args=$(echo $ax_args | sed "s,${ax_candidate_flag}=[^']*,${ax_candidate},")]
+             else
+               AS_VAR_APPEND(ax_args, " 'opt'")
+             fi
+           fi
+      ])])
+      # Options that must be removed.
+      m4_ifnblank([$5], [m4_foreach(opt, [$5], [ax_args=$(echo $ax_args | sed "s,'opt',,")
+      ])])
+      AS_VAR_APPEND([ax_args], [" '--srcdir=$ac_srcdir'"])
+
+      # Add the subdirectory to the list of target subdirectories.
+      ax_subconfigures="$ax_subconfigures $ax_dir"
+      # Save the argument list for this subdirectory.
+      dnl $1 is a path to some subdirectory: m4_bpatsubsts() is used to convert
+      dnl $1 into a valid shell variable name.
+      dnl For instance, "ax_sub_configure_args_path/to/subdir" becomes
+      dnl "ax_sub_configure_args_path_to_subdir".
+      ax_var=$(printf "$ax_dir" | tr -c "0-9a-zA-Z_" "_")
+      eval "ax_sub_configure_args_$ax_var=\"$ax_args\""
+      eval "ax_sub_configure_$ax_var=\"yes\""
+    else
+      AC_MSG_WARN([could not find source tree for $ax_dir])
+    fi
+
+    dnl Add some more arguments to the argument list and then actually run the
+    dnl configure script. This is mostly what happens in _AC_OUTPUT_SUBDIRS
+    dnl except it does not iterate over an intermediary list.
+    AC_CONFIG_COMMANDS_PRE(
+      dnl This very line can not be quoted! m4_foreach has some work here.
+      ax_dir="subdir_path"
+    [
+      # Convert the path to the subdirectory into a shell variable name.
+      ax_var=$(printf "$ax_dir" | tr -c "0-9a-zA-Z_" "_")
+      ax_configure_ax_var=$(eval "echo \"\$ax_sub_configure_$ax_var\"")
+      if test "$no_recursion" != "yes" -a "x$ax_configure_ax_var" = "xyes"; then
+        AC_SUBST([subdirs_extra], ["$subdirs_extra $ax_dir"])
+        ax_msg="=== configuring in $ax_dir ($(pwd)/$ax_dir)"
+        _AS_ECHO_LOG([$ax_msg])
+        _AS_ECHO([$ax_msg])
+        AS_MKDIR_P(["$ax_dir"])
+        _AC_SRCDIRS(["$ax_dir"])
+
+        ax_popdir=$(pwd)
+        cd "$ax_dir"
+
+        # Check for guested configure; otherwise get Cygnus style configure.
+        if test -f "$ac_srcdir/configure.gnu"; then
+          ax_sub_configure=$ac_srcdir/configure.gnu
+        elif test -f "$ac_srcdir/configure"; then
+          ax_sub_configure=$ac_srcdir/configure
+        elif test -f "$ac_srcdir/configure.in"; then
+          # This should be Cygnus configure.
+          ax_sub_configure=$ac_aux_dir/configure
+        else
+          AC_MSG_WARN([no configuration information is in $ax_dir])
+          ax_sub_configure=
+        fi
+
+        if test -n "$ax_sub_configure"; then
+          # Get the configure arguments for the current configure.
+          eval "ax_sub_configure_args=\"\$ax_sub_configure_args_${ax_var}\""
+
+          # Always prepend --prefix to ensure using the same prefix
+          # in subdir configurations.
+          ax_arg="--prefix=$prefix"
+          case $ax_arg in
+            *\'*) ax_arg=$(AS_ECHO(["$ax_arg"]) | sed "s/'/'\\\\\\\\''/g");;
+          esac
+          ax_sub_configure_args="'$ax_arg' $ax_sub_configure_args"
+          if test "$silent" = yes; then
+            ax_sub_configure_args="--silent $ax_sub_configure_args"
+          fi
+          # Make the cache file name correct relative to the subdirectory.
+          case $cache_file in
+            [[\\/]]* | ?:[[\\/]]* )
+              ax_sub_cache_file=$cache_file ;;
+            *) # Relative name.
+              ax_sub_cache_file=$ac_top_build_prefix$cache_file ;;
+          esac
+
+          AC_MSG_NOTICE([running $SHELL $ax_sub_configure $ax_sub_configure_args --cache-file=$ac_sub_cache_file])
+          eval "\$SHELL \"$ax_sub_configure\" $ax_sub_configure_args --cache-file=\"$ax_sub_cache_file\"" \
+              || AC_MSG_ERROR([$ax_sub_configure failed for $ax_dir])
+        fi
+
+        cd "$ax_popdir"
+      fi
+    ])
+  ])
+])
\ No newline at end of file
diff --git a/mp4v2/CMakeLists.txt b/mp4v2/CMakeLists.txt
new file mode 100644
index 0000000..f384df2
--- /dev/null
+++ b/mp4v2/CMakeLists.txt
@@ -0,0 +1,397 @@
+cmake_minimum_required(VERSION 3.0)
+
+project(MP4v2 VERSION 2.1.2)
+
+set(CMAKE_CXX_STANDARD 11)
+
+option(BUILD_SHARED "Build libmp4v2 as a shared library" ON)
+option(BUILD_UTILS "Build MP4v2 auxiliary tools" ON)
+
+#
+# Generate include/mp4v2/project.h and libplatform/config.h
+#
+include(CheckIncludeFiles)
+include(CheckTypeSize)
+
+check_include_files(inttypes.h  HAVE_INTTYPES_H)
+check_include_files(stdint.h    HAVE_STDINT_H)
+check_include_files(stdio.h     HAVE_STDIO_H)
+check_include_files(stdlib.h    HAVE_STDLIB_H)
+check_include_files(string.h    HAVE_STRING_H)
+check_include_files(sys/stat.h  HAVE_SYS_STAT_H)
+check_include_files(sys/types.h HAVE_SYS_TYPES_H)
+check_include_files(unistd.h    HAVE_UNISTD_H)
+
+if(NOT WIN32 AND HAVE_SYS_STAT_H)
+    set(CMAKE_EXTRA_INCLUDE_FILES sys/stat.h)
+    check_type_size("((struct stat*)0)->st_size" ST_SIZE_BYTES)
+    if(${ST_SIZE_BYTES} LESS 8)
+        set(NEED_LFS_ACTIVATION 1)
+    endif()
+endif()
+
+file(READ project/project.m4sugar PROJECT_INFO)
+
+macro(projectinfo variable output)
+    string(REGEX MATCH "\\[PRJ_${variable}\\],[^\n]*\\[([^\n]*)\\]" _ ${PROJECT_INFO})
+    set(${output} ${CMAKE_MATCH_1})
+endmacro()
+
+projectinfo(name           PROJECT_name)
+projectinfo(name_lower     PROJECT_name_lower)
+projectinfo(name_upper     PROJECT_name_upper)
+projectinfo(url_website    PROJECT_url_website)
+projectinfo(url_downloads  PROJECT_url_downloads)
+projectinfo(url_discussion PROJECT_url_discussion)
+projectinfo(url_bugreport  PROJECT_url_bugreport)
+projectinfo(support        PROJECT_email)
+projectinfo(version_major  PROJECT_version_major)
+projectinfo(version_minor  PROJECT_version_minor)
+projectinfo(version_point  PROJECT_version_point)
+projectinfo(repo_url       PROJECT_repo_url)
+
+set(PROJECT_version        "${PROJECT_version_major}.${PROJECT_version_minor}.${PROJECT_version_point}")
+set(PROJECT_name_formal    "${PROJECT_name} ${PROJECT_version}")
+set(PROJECT_support        "<${PROJECT_email}>")
+
+function(number_to_hex number output)
+    set(chars "0123456789abcdef")
+    set(hex "")
+
+    foreach(i RANGE 7)
+        math(EXPR nibble "${number} & 15")
+        string(SUBSTRING "${chars}" "${nibble}" 1 nibble_hex)
+        string(CONCAT hex "${nibble_hex}" "${hex}")
+
+        math(EXPR number "${number} >> 4")
+        if(${number} EQUAL 0)
+            break()
+        endif()
+    endforeach()
+
+    set("${output}" "0x${hex}" PARENT_SCOPE)
+endfunction()
+
+math(EXPR PROJECT_version_dec "${PROJECT_version_major} << 16 | ${PROJECT_version_minor} << 8 | ${PROJECT_version_point}")
+number_to_hex("${PROJECT_version_dec}" PROJECT_version_hex)
+
+string(TIMESTAMP PROJECT_build "%Y-%m-%d %H:%M:%S UTC" UTC)
+
+configure_file(libplatform/config.h.cmake libplatform/config.h)
+configure_file(include/mp4v2/project.h.in include/mp4v2/project.h)
+
+#
+# Configure pkg-config file
+#
+function(configure_pkg_config_file pkg_config_file_in)
+    set(prefix ${CMAKE_INSTALL_PREFIX})
+    set(exec_prefix \${prefix})
+    set(libdir \${prefix}/${CMAKE_INSTALL_LIBDIR})
+    set(includedir \${prefix}/${CMAKE_INSTALL_INCLUDEDIR})
+    set(VERSION ${PROJECT_version})
+    string(REPLACE ".in" "" pkg_config_file ${pkg_config_file_in})
+    configure_file(${pkg_config_file_in} ${pkg_config_file} @ONLY)
+endfunction() 
+
+configure_pkg_config_file(mp4v2.pc.in)
+
+#
+# Set compile flags
+#
+if(MSVC)
+    add_compile_options(/EHsc)
+endif()
+
+#
+# Define MP4v2 source files
+#
+set(MP4V2_PUBLIC_HEADERS
+        ${CMAKE_BINARY_DIR}/include/mp4v2/project.h
+        include/mp4v2/chapter.h
+        include/mp4v2/file.h
+        include/mp4v2/file_prop.h
+        include/mp4v2/general.h
+        include/mp4v2/isma.h
+        include/mp4v2/itmf_generic.h
+        include/mp4v2/itmf_tags.h
+        include/mp4v2/mp4v2.h
+        include/mp4v2/platform.h
+        include/mp4v2/sample.h
+        include/mp4v2/streaming.h
+        include/mp4v2/track.h
+        include/mp4v2/track_prop.h)
+
+set(MP4V2_PRIVATE_HEADERS
+        ${CMAKE_BINARY_DIR}/libplatform/config.h
+        libplatform/io/File.h
+        libplatform/io/FileSystem.h
+        libplatform/number/random.h
+        libplatform/prog/commandline.h
+        libplatform/prog/option.h
+        libplatform/sys/error.h
+        libplatform/time/time.h
+        libplatform/endian.h
+        libplatform/impl.h
+        libplatform/platform.h
+        libplatform/platform_base.h
+        libplatform/platform_posix.h
+        libplatform/platform_win32.h
+        libplatform/warning.h
+        libutil/impl.h
+        libutil/other.h
+        libutil/TrackModifier.h
+        libutil/util.h
+        libutil/Utility.h
+        src/bmff/bmff.h
+        src/bmff/impl.h
+        src/bmff/typebmff.h
+        src/itmf/CoverArtBox.h
+        src/itmf/generic.h
+        src/itmf/impl.h
+        src/itmf/itmf.h
+        src/itmf/Tags.h
+        src/itmf/type.h
+        src/qtff/coding.h
+        src/qtff/ColorParameterBox.h
+        src/qtff/impl.h
+        src/qtff/PictureAspectRatioBox.h
+        src/qtff/qtff.h
+        src/atoms.h
+        src/descriptors.h
+        src/enum.h
+        src/exception.h
+        src/impl.h
+        src/log.h
+        src/mp4array.h
+        src/mp4atom.h
+        src/mp4container.h
+        src/mp4descriptor.h
+        src/mp4file.h
+        src/mp4property.h
+        src/mp4track.h
+        src/mp4util.h
+        src/ocidescriptors.h
+        src/odcommands.h
+        src/qosqualifiers.h
+        src/rtphint.h
+        src/src.h
+        src/text.h
+        src/util.h)
+
+if(WIN32)
+   set(MP4V2_OSSPEC_SRC
+        libplatform/io/File_win32.cpp
+        libplatform/io/FileSystem_win32.cpp
+        libplatform/number/random_win32.cpp
+        libplatform/prog/commandline_win32.cpp
+        libplatform/time/time_win32.cpp
+        libplatform/platform_win32.cpp
+   )
+else()
+   set(MP4V2_OSSPEC_SRC
+        libplatform/io/File_posix.cpp
+        libplatform/io/FileSystem_posix.cpp
+        libplatform/number/random_posix.cpp
+        libplatform/prog/commandline_posix.cpp
+        libplatform/time/time_posix.cpp
+       )
+endif()
+
+set(MP4V2_SOURCE_FILES
+        ${MP4V2_OSSPEC_SRC}
+        libplatform/io/File.cpp
+        libplatform/io/FileSystem.cpp
+        libplatform/prog/option.cpp
+        libplatform/sys/error.cpp
+        libplatform/time/time.cpp
+        libutil/other.cpp
+        libutil/TrackModifier.cpp
+        libutil/Utility.cpp
+        src/bmff/typebmff.cpp
+        src/itmf/CoverArtBox.cpp
+        src/itmf/generic.cpp
+        src/itmf/Tags.cpp
+        src/itmf/type.cpp
+        src/qtff/coding.cpp
+        src/qtff/ColorParameterBox.cpp
+        src/qtff/PictureAspectRatioBox.cpp
+        src/3gp.cpp
+        src/atom_ac3.cpp
+        src/atom_amr.cpp
+        src/atom_avc1.cpp
+        src/atom_avcC.cpp
+        src/atom_chpl.cpp
+        src/atom_colr.cpp
+        src/atom_d263.cpp
+        src/atom_dac3.cpp
+        src/atom_damr.cpp
+        src/atom_dref.cpp
+        src/atom_elst.cpp
+        src/atom_enca.cpp
+        src/atom_encv.cpp
+        src/atom_free.cpp
+        src/atom_ftab.cpp
+        src/atom_ftyp.cpp
+        src/atom_gmin.cpp
+        src/atom_hdlr.cpp
+        src/atom_hinf.cpp
+        src/atom_hnti.cpp
+        src/atom_href.cpp
+        src/atom_mdat.cpp
+        src/atom_mdhd.cpp
+        src/atom_meta.cpp
+        src/atom_mp4s.cpp
+        src/atom_mp4v.cpp
+        src/atom_mvhd.cpp
+        src/atom_nmhd.cpp
+        src/atom_ohdr.cpp
+        src/atom_pasp.cpp
+        src/atom_root.cpp
+        src/atom_rtp.cpp
+        src/atom_s263.cpp
+        src/atom_sdp.cpp
+        src/atom_sdtp.cpp
+        src/atom_smi.cpp
+        src/atom_sound.cpp
+        src/atom_standard.cpp
+        src/atom_stbl.cpp
+        src/atom_stdp.cpp
+        src/atom_stsc.cpp
+        src/atom_stsd.cpp
+        src/atom_stsz.cpp
+        src/atom_stz2.cpp
+        src/atom_text.cpp
+        src/atom_tfhd.cpp
+        src/atom_tkhd.cpp
+        src/atom_treftype.cpp
+        src/atom_trun.cpp
+        src/atom_tx3g.cpp
+        src/atom_udta.cpp
+        src/atom_url.cpp
+        src/atom_urn.cpp
+        src/atom_uuid.cpp
+        src/atom_video.cpp
+        src/atom_vmhd.cpp
+        src/cmeta.cpp
+        src/descriptors.cpp
+        src/enum.tcc
+        src/exception.cpp
+        src/isma.cpp
+        src/log.cpp
+        src/mp4.cpp
+        src/mp4atom.cpp
+        src/mp4container.cpp
+        src/mp4descriptor.cpp
+        src/mp4file.cpp
+        src/mp4file_io.cpp
+        src/mp4info.cpp
+        src/mp4property.cpp
+        src/mp4track.cpp
+        src/mp4util.cpp
+        src/ocidescriptors.cpp
+        src/odcommands.cpp
+        src/qosqualifiers.cpp
+        src/rtphint.cpp
+        src/text.cpp)
+
+#
+# Define libutil source files
+#
+set(LIBUTIL_HEADER_FILES
+        libutil/crc.h
+        libutil/Timecode.h)
+
+set(LIBUTIL_SOURCE_FILES
+        libutil/crc.cpp
+        libutil/Timecode.cpp)
+
+#
+# Define library targets
+#
+if(BUILD_SHARED)
+    add_library(mp4v2 SHARED ${MP4V2_SOURCE_FILES})
+    target_compile_definitions(mp4v2 PRIVATE MP4V2_EXPORTS)
+    set_target_properties(mp4v2 PROPERTIES VERSION ${PROJECT_version} SOVERSION ${PROJECT_version_major})
+else()
+    add_library(mp4v2 STATIC ${MP4V2_SOURCE_FILES})
+    target_compile_definitions(mp4v2 PUBLIC MP4V2_USE_STATIC_LIB)
+endif()
+
+#
+# Set include folders
+#
+target_include_directories(mp4v2 PUBLIC
+   ${CMAKE_CURRENT_BINARY_DIR}/include
+   ${CMAKE_CURRENT_SOURCE_DIR}/include
+   ${CMAKE_CURRENT_BINARY_DIR}
+   ${CMAKE_CURRENT_SOURCE_DIR})
+
+#
+# Define utilities targets
+#
+if(BUILD_UTILS)
+    set(UTILITY_HEADER_FILES
+       util/impl.h)
+
+    add_library(util STATIC ${LIBUTIL_HEADER_FILES} ${LIBUTIL_SOURCE_FILES})
+    target_link_libraries(util mp4v2)
+
+    add_executable(mp4art ${UTILITY_HEADER_FILES} util/mp4art.cpp)
+    target_link_libraries(mp4art mp4v2 util)
+
+    add_executable(mp4chaps ${UTILITY_HEADER_FILES} util/mp4chaps.cpp)
+    target_link_libraries(mp4chaps mp4v2 util)
+
+    add_executable(mp4extract ${UTILITY_HEADER_FILES} util/mp4extract.cpp)
+    target_link_libraries(mp4extract mp4v2)
+
+    add_executable(mp4file ${UTILITY_HEADER_FILES} util/mp4file.cpp)
+    target_link_libraries(mp4file mp4v2)
+
+    add_executable(mp4info ${UTILITY_HEADER_FILES} util/mp4info.cpp)
+    target_link_libraries(mp4info mp4v2)
+
+    add_executable(mp4subtitle ${UTILITY_HEADER_FILES} util/mp4subtitle.cpp)
+    target_link_libraries(mp4subtitle mp4v2)
+
+    add_executable(mp4tags ${UTILITY_HEADER_FILES} util/mp4tags.cpp)
+    target_link_libraries(mp4tags mp4v2)
+
+    add_executable(mp4track ${UTILITY_HEADER_FILES} util/mp4track.cpp)
+    target_link_libraries(mp4track mp4v2)
+
+    add_executable(mp4trackdump ${UTILITY_HEADER_FILES} util/mp4trackdump.cpp)
+    target_link_libraries(mp4trackdump mp4v2)
+endif()
+
+#
+# Define install targets
+#
+include(GNUInstallDirs)
+
+install(FILES ${MP4V2_PUBLIC_HEADERS} DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/mp4v2")
+
+if(BUILD_SHARED)
+    if(WIN32)
+        install(TARGETS mp4v2 RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}")
+    else()
+        install(TARGETS mp4v2 LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}")
+    endif()
+else()
+    install(TARGETS mp4v2 ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}")
+endif()
+
+install(FILES "${CMAKE_CURRENT_BINARY_DIR}/mp4v2.pc" DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig")
+
+if(BUILD_UTILS)
+    install(TARGETS mp4art
+                    mp4chaps
+                    mp4extract
+                    mp4file
+                    mp4info
+                    mp4subtitle
+                    mp4tags
+                    mp4track
+                    mp4trackdump RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}")
+endif()
+
diff --git a/mp4v2/COPYING b/mp4v2/COPYING
index 0c3dd64..e9ed083 100644
--- a/mp4v2/COPYING
+++ b/mp4v2/COPYING
@@ -429,7 +429,7 @@
      Initial Developer may designate portions of the Covered Code as
      "Multiple-Licensed".  "Multiple-Licensed" means that the Initial
      Developer permits you to utilize portions of the Covered Code under
-     Your choice of the NPL or the alternative licenses, if any, specified
+     Your choice of the MPL or the alternative licenses, if any, specified
      by the Initial Developer in the file described in Exhibit A.
 
 EXHIBIT A -Mozilla Public License.
@@ -437,7 +437,7 @@ EXHIBIT A -Mozilla Public License.
      ``The contents of this file are subject to the Mozilla Public License
      Version 1.1 (the "License"); you may not use this file except in
      compliance with the License. You may obtain a copy of the License at
-     http://www.mozilla.org/MPL/
+     https://www.mozilla.org/MPL/
 
      Software distributed under the License is distributed on an "AS IS"
      basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
diff --git a/mp4v2/GNUmakefile.am b/mp4v2/GNUmakefile.am
index 38c4777..09b877b 100644
--- a/mp4v2/GNUmakefile.am
+++ b/mp4v2/GNUmakefile.am
@@ -1,4 +1,5 @@
-noinst_LTLIBRARIES = libmp4v2.la
+lib_LTLIBRARIES = libmp4v2.la
+noinst_LTLIBRARIES = libutil.la
 
 bin_PROGRAMS =
 
@@ -8,6 +9,7 @@ check_PROGRAMS =
 
 libmp4v2_la_LDFLAGS = \
     $(AM_LDFLAGS) \
+    -no-undefined \
     -version-number $(PROJECT_version_major):$(PROJECT_version_minor):$(PROJECT_version_point) $(X_libmp4v2_la_LDFLAGS)
 
 libmp4v2_la_SOURCES = \
@@ -151,7 +153,6 @@ libmp4v2_la_SOURCES += \
     libplatform/platform_base.h          \
     libplatform/platform_posix.h         \
     libplatform/platform_win32.h         \
-    libplatform/process/process.h        \
     libplatform/prog/commandline.h       \
     libplatform/prog/option.cpp          \
     libplatform/prog/option.h            \
@@ -166,21 +167,68 @@ if ADD_PLATFORM_POSIX
         libplatform/io/File_posix.cpp          \
         libplatform/io/FileSystem_posix.cpp    \
         libplatform/number/random_posix.cpp    \
-        libplatform/process/process_posix.cpp  \
         libplatform/prog/commandline_posix.cpp \
         libplatform/time/time_posix.cpp
 endif
 if ADD_PLATFORM_WIN32
     libmp4v2_la_SOURCES += \
-        libplatform/platform_win32.cpp         \
         libplatform/io/File_win32.cpp          \
         libplatform/io/FileSystem_win32.cpp    \
         libplatform/number/random_win32.cpp    \
-        libplatform/process/process_win32.cpp  \
         libplatform/prog/commandline_win32.cpp \
-        libplatform/time/time_win32.cpp
+        libplatform/time/time_win32.cpp        \
+        libplatform/platform_win32.cpp         \
+        libplatform/platform_win32_impl.h
 endif
 
+if ADD_UTIL
+    libmp4v2_la_SOURCES += \
+        libutil/TrackModifier.cpp  \
+        libutil/TrackModifier.h    \
+        libutil/Utility.cpp        \
+        libutil/Utility.h          \
+        libutil/impl.h             \
+        libutil/other.cpp          \
+        libutil/other.h            \
+        libutil/util.h
+
+    libutil_la_SOURCES = \
+        libutil/crc.cpp      \
+        libutil/crc.h        \
+        libutil/Timecode.cpp \
+        libutil/Timecode.h
+
+    bin_PROGRAMS += mp4art
+    bin_PROGRAMS += mp4chaps
+    bin_PROGRAMS += mp4extract
+    bin_PROGRAMS += mp4file
+    bin_PROGRAMS += mp4info
+    bin_PROGRAMS += mp4subtitle
+    bin_PROGRAMS += mp4tags
+    bin_PROGRAMS += mp4track
+    bin_PROGRAMS += mp4trackdump
+endif
+
+mp4art_SOURCES       = util/impl.h util/mp4art.cpp
+mp4chaps_SOURCES     = util/impl.h util/mp4chaps.cpp
+mp4extract_SOURCES   = util/impl.h util/mp4extract.cpp
+mp4file_SOURCES      = util/impl.h util/mp4file.cpp
+mp4info_SOURCES      = util/impl.h util/mp4info.cpp
+mp4subtitle_SOURCES  = util/impl.h util/mp4subtitle.cpp
+mp4tags_SOURCES      = util/impl.h util/mp4tags.cpp
+mp4track_SOURCES     = util/impl.h util/mp4track.cpp
+mp4trackdump_SOURCES = util/impl.h util/mp4trackdump.cpp
+
+mp4art_LDADD       = libmp4v2.la libutil.la $(X_LDFLAGS)
+mp4chaps_LDADD     = libmp4v2.la libutil.la $(X_LDFLAGS)
+mp4extract_LDADD   = libmp4v2.la $(X_LDFLAGS)
+mp4file_LDADD      = libmp4v2.la $(X_LDFLAGS)
+mp4info_LDADD      = libmp4v2.la $(X_LDFLAGS)
+mp4subtitle_LDADD  = libmp4v2.la $(X_LDFLAGS)
+mp4tags_LDADD      = libmp4v2.la $(X_LDFLAGS)
+mp4track_LDADD     = libmp4v2.la $(X_LDFLAGS)
+mp4trackdump_LDADD = libmp4v2.la $(X_LDFLAGS)
+
 ###############################################################################
 
 DEJATOOL = main
@@ -193,9 +241,32 @@ override RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir/testsuite --outdi
 
 mp4v2incdir = $(pkgincludedir)
 
+mp4v2inc_HEADERS = \
+    include/mp4v2/project.h      \
+    include/mp4v2/chapter.h      \
+    include/mp4v2/file.h         \
+    include/mp4v2/file_prop.h    \
+    include/mp4v2/general.h      \
+    include/mp4v2/isma.h         \
+    include/mp4v2/itmf_generic.h \
+    include/mp4v2/itmf_tags.h    \
+    include/mp4v2/mp4v2.h        \
+    include/mp4v2/platform.h     \
+    include/mp4v2/sample.h       \
+    include/mp4v2/streaming.h    \
+    include/mp4v2/track.h        \
+    include/mp4v2/track_prop.h
+
 ###############################################################################
 
-EXTRA_DIST = project/project.m4
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = mp4v2.pc
+
+###############################################################################
+
+EXTRA_DIST = \
+    project/project.m4 \
+    mp4v2.pc.in
 
 ###############################################################################
 
@@ -214,6 +285,8 @@ AM_LDFLAGS = $(strip $(MK_CXX_ARCH) $(X_CXX_ARCH))
 
 AM_CXXFLAGS = $(strip $(MK_CXX_W) $(X_CXX_W))
 
+ACLOCAL_AMFLAGS = -I m4
+
 LIBS := $(LIBS) $(X_MINGW_LIBS)
 
 ###############################################################################
@@ -228,6 +301,17 @@ MK_CXX_I = \
 
 ###############################################################################
 
+if ADD_UTIL
+if ADD_MANS
+    man1_MANS = \
+        doc/man/man1/mp4art.1       \
+        doc/man/man1/mp4chaps.1     \
+        doc/man/man1/mp4file.1      \
+        doc/man/man1/mp4subtitle.1  \
+        doc/man/man1/mp4tags.1      \
+        doc/man/man1/mp4track.1
+endif
+endif
 
 ###############################################################################
 
diff --git a/mp4v2/INSTALL b/mp4v2/INSTALL
new file mode 100644
index 0000000..d3c5b40
--- /dev/null
+++ b/mp4v2/INSTALL
@@ -0,0 +1,237 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
+2006, 2007 Free Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+Briefly, the shell commands `./configure; make; make install' should
+configure, build, and install this package.  The following
+more-detailed instructions are generic; see the `README' file for
+instructions specific to this package.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You need `configure.ac' if
+you want to change it or regenerate `configure' using a newer version
+of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.
+
+     Running `configure' might take a while.  While running, it prints
+     some messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+  6. Often, you can also type `make uninstall' to remove the installed
+     files again.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c99 CFLAGS=-g LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you can use GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   With a non-GNU `make', it is safer to compile the package for one
+architecture at a time in the source code directory.  After you have
+installed the package for one architecture, use `make distclean' before
+reconfiguring for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).
+
+Unfortunately, this technique does not work for `CONFIG_SHELL' due to
+an Autoconf bug.  Until the bug is fixed you can use this workaround:
+
+     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+
diff --git a/mp4v2/README b/mp4v2/README
new file mode 100644
index 0000000..15453d3
--- /dev/null
+++ b/mp4v2/README
@@ -0,0 +1,9 @@
+All docs are located in doc/ subdirectory. Useful starting points:
+
+Release Notes               -- doc/ReleaseNotes.txt
+Guide to Command Line Tools -- doc/ToolGuide.txt
+
+Building the Source         -- doc/BuildSource.txt
+Building the Repository     -- doc/BuildRepository.txt
+
+See the COPYING file for license rights and limitations.
diff --git a/mp4v2/configure.ac b/mp4v2/configure.ac
index facf631..2d0d0dd 100644
--- a/mp4v2/configure.ac
+++ b/mp4v2/configure.ac
@@ -4,30 +4,15 @@
 
 m4_include([project/project.m4sugar])
 
-m4_define([SVNINFO],m4_esyscmd([LANG=en cat svninfo 2>/dev/null]))
-
-changequote(<<,>>)dnl
-    m4_define(<<PRJ_repo_url>>,m4_bregexp(SVNINFO,<<^URL: *\(.+\)>>,<<\1>>))
-    m4_define(<<PRJ_repo_branch>>,m4_bregexp(PRJ_repo_url,<<\([^/]+\)$>>,<<\1>>))
-    m4_define(<<PRJ_repo_root>>,m4_bregexp(SVNINFO,<<^Repository Root: *\(.+\)>>,<<\1>>))
-    m4_define(<<PRJ_repo_uuid>>,m4_bregexp(SVNINFO,<<^Repository UUID: *\(.+\)>>,<<\1>>))
-    m4_define(<<PRJ_repo_rev>>,m4_bregexp(SVNINFO,<<^Last Changed Rev: *\(.+\)>>,<<\1>>))
-    m4_define(<<PRJ_repo_date>>,m4_bregexp(SVNINFO,<<^Last Changed Date: *\(.+\)>>,<<\1>>))
-    m4_define(<<PRJ_repo_type>>,ifelse(m4_bregexp(PRJ_repo_url,<</releases/>>),<<-1>>,<<developer>>,<<stable>>))
-changequote([,])dnl
-
 m4_define([PRJ_version_hex],m4_format([0x%04x%02x%02x],PRJ_version_major,PRJ_version_minor,PRJ_version_point))
-
-m4_define([PRJ_version],ifelse(
-    PRJ_repo_type,[stable],m4_format([%s],PRJ_repo_branch),
-    m4_format([%s-r%s],PRJ_repo_branch,PRJ_repo_rev)))
+m4_define([PRJ_version],m4_format([%s.%s.%s],PRJ_version_major,PRJ_version_minor,PRJ_version_point))
 
 ###############################################################################
 # initialization
 ###############################################################################
 
-AC_PREREQ([2.61])
-AC_INIT(PRJ_name,PRJ_version,PRJ_bugreport)
+AC_PREREQ([2.69])
+AC_INIT([PRJ_name],[PRJ_version],[PRJ_support],[PRJ_name_lower],[PRJ_url_website])
 
 AC_MSG_NOTICE([
   -->
@@ -35,7 +20,8 @@ AC_MSG_NOTICE([
   -->])
 
 AC_CONFIG_AUX_DIR([autoaux])
-AM_INIT_AUTOMAKE([1.9.6 foreign -Wall -Wno-portability -Werror subdir-objects nostdinc no-dist-gzip dist-bzip2 dist-zip dejagnu])
+AC_CONFIG_MACRO_DIR([m4])
+AM_INIT_AUTOMAKE([1.9.6 foreign -Wall -Wno-portability -Werror subdir-objects nostdinc no-dist-gzip dist-bzip2 dejagnu])
 
 AC_CONFIG_SRCDIR([src/mp4.cpp])
 
@@ -60,28 +46,38 @@ AC_ARG_ENABLE([optimize],
     [AS_HELP_STRING([--disable-optimize],[disable optimizing compilation])])
 AC_ARG_ENABLE([fvisibility],
     [AS_HELP_STRING([--disable-fvisibility],[disable use of -fvisibility])])
-AC_ARG_ENABLE([gch],
-    [AS_HELP_STRING([--disable-gch],[disable GCC precompiled-headers])])
 AC_ARG_ENABLE([largefile],
     [AS_HELP_STRING([--disable-largefile],[disable LFS (large file support)])])
 AC_ARG_ENABLE([util],
     [AS_HELP_STRING([--disable-util],[disable build of command-line utilities])])
+AC_ARG_ENABLE([gch],
+    [AS_HELP_STRING([--enable-gch],[enable use of precompiled headers])])
 AC_ARG_ENABLE([bi],
     [AS_HELP_STRING([--enable-bi=ARCH],[enable -mARCH for bi-arch compilation])])
 AC_ARG_ENABLE([ub],
     [AS_HELP_STRING([--enable-ub@<:@=ARCHS@:>@],[enable -arch ARCH for universal-binaries (OSX only)])])
 AC_ARG_ENABLE([cygwin_win32],
     [AS_HELP_STRING([--enable-cygwin-win32],[when building with Cygwin use -mwin32])])
-AC_ARG_ENABLE([mingw_mt],
+AC_ARG_ENABLE([mingw_threads],
     [AS_HELP_STRING([--enable-mingw-threads],[when building with MinGW use -mthreads])])
 
+###############################################################################
+# use libtool
+###############################################################################
+
+LT_INIT([disable-static win32-dll])
+
+###############################################################################
+# use pkg-config
+###############################################################################
+
+PKG_PROG_PKG_CONFIG
+
 ###############################################################################
 # checks for programs
 ###############################################################################
 
 AC_PROG_CXX
-AC_LIBTOOL_WIN32_DLL
-LT_INIT(disable-shared)
 
 AC_CHECK_PROG([FOUND_HELP2MAN],[help2man],[yes],[no])
 
@@ -92,15 +88,14 @@ AC_CHECK_PROG([FOUND_HELP2MAN],[help2man],[yes],[no])
 AC_MSG_CHECKING([$PACKAGE_NAME platform portability])
 X_PLATFORM=posix
 case ${host} in
-*-*-cygwin)
+*-*-cygwin*)
     X_CXX_W="$X_CXX_W -Wno-format"
     if test "$enable_cygwin_win32" = "yes"; then
         X_PLATFORM=win32
         X_CXX_ARCH="$X_CXX_ARCH -mwin32"
     fi
     ;;
-*-*-mingw*)
-    # do not support shared
+*-*-msys*|*-*-mingw*)
     X_PLATFORM=win32
     X_MINGW_LIBS="$X_MINGW_LIBS"
     X_CXX_W="$X_CXX_W -Wno-format"
@@ -122,8 +117,8 @@ PROJECT_name_formal="PRJ_name PRJ_version"
 PROJECT_url_website="PRJ_url_website"
 PROJECT_url_downloads="PRJ_url_downloads"
 PROJECT_url_discussion="PRJ_url_discussion"
-PROJECT_irc="PRJ_irc"
-PROJECT_bugreport="<PRJ_bugreport>"
+PROJECT_url_bugreport="PRJ_url_bugreport"
+PROJECT_support="<PRJ_support>"
 
 PROJECT_version="PRJ_version"
 PROJECT_version_hex="PRJ_version_hex"
@@ -131,25 +126,14 @@ PROJECT_version_major="PRJ_version_major"
 PROJECT_version_minor="PRJ_version_minor"
 PROJECT_version_point="PRJ_version_point"
 PROJECT_repo_url="PRJ_repo_url"
-PROJECT_repo_branch="PRJ_repo_branch"
-PROJECT_repo_root="PRJ_repo_root"
-PROJECT_repo_uuid="PRJ_repo_uuid"
-PROJECT_repo_rev="PRJ_repo_rev"
-PROJECT_repo_date="PRJ_repo_date"
-PROJECT_repo_type="PRJ_repo_type"
-PROJECT_build="`date`"
+SOURCE_DATE_EPOCH="${SOURCE_DATE_EPOCH:-$(date +%s)}"
+PROJECT_build=$(date -u -d "@$SOURCE_DATE_EPOCH" 2>/dev/null || date -u -r "$SOURCE_DATE_EPOCH" 2>/dev/null || date -u)
 
 test -z "$PROJECT_version_hex"   && PROJECT_version_hex="0x0000000000000000LL"
 test -z "$PROJECT_version_major" && PROJECT_version_major="0"
 test -z "$PROJECT_version_minor" && PROJECT_version_minor="0"
 test -z "$PROJECT_version_point" && PROJECT_version_point="0"
-test -z "$PROJECT_repo_url"      && PROJECT_repo_url="svn://nowhere.com/project/unknown"
-test -z "$PROJECT_repo_branch"   && PROJECT_repo_branch="unknown"
-test -z "$PROJECT_repo_root"     && PROJECT_repo_root="svn://nowhere.com/project"
-test -z "$PROJECT_repo_uuid"     && PROJECT_repo_uuid="00000000-0000-0000-0000-000000000000"
-test -z "$PROJECT_repo_rev"      && PROJECT_repo_rev="0"
-test -z "$PROJECT_repo_date"     && PROJECT_repo_date="unknown"
-test -z "$PROJECT_repo_type"     && PROJECT_repo_type="unknown"
+test -z "$PROJECT_repo_url"      && PROJECT_repo_url="git@nowhere.com:project.git"
 test -z "$PROJECT_build"         && PROJECT_build="unknown"
 
 AC_SUBST([PROJECT_name])
@@ -159,20 +143,14 @@ AC_SUBST([PROJECT_name_formal])
 AC_SUBST([PROJECT_url_website])
 AC_SUBST([PROJECT_url_downloads])
 AC_SUBST([PROJECT_url_discussion])
-AC_SUBST([PROJECT_irc])
-AC_SUBST([PROJECT_bugreport])
+AC_SUBST([PROJECT_url_bugreport])
+AC_SUBST([PROJECT_support])
 AC_SUBST([PROJECT_version])
 AC_SUBST([PROJECT_version_hex])
 AC_SUBST([PROJECT_version_major])
 AC_SUBST([PROJECT_version_minor])
 AC_SUBST([PROJECT_version_point])
 AC_SUBST([PROJECT_repo_url])
-AC_SUBST([PROJECT_repo_branch])
-AC_SUBST([PROJECT_repo_root])
-AC_SUBST([PROJECT_repo_uuid])
-AC_SUBST([PROJECT_repo_rev])
-AC_SUBST([PROJECT_repo_date])
-AC_SUBST([PROJECT_repo_type])
 AC_SUBST([PROJECT_build])
 
 ###############################################################################
@@ -204,10 +182,7 @@ case ${host} in
     *-*-darwin*)
         X_libmp4v2_la_LDFLAGS='-Wl,-current_version,$(PROJECT_version_major).$(PROJECT_version_minor).$(PROJECT_version_point) -Wl,-compatibility_version,$(PROJECT_version_major).0.0'
         ;;
-    *-*-cygwin*)
-        X_libmp4v2_la_LDFLAGS='-no-undefined'
-        ;;
-    *-*-mingw*)
+    *-*-cygwin*|*-*-msys*|*-*-mingw*)
         X_libmp4v2_la_LDFLAGS='-no-undefined'
         ;;
     *)
@@ -223,16 +198,14 @@ AC_SUBST([X_libmp4v2_la_LDFLAGS])
 
 if test "$enable_fvisibility" != "no" -a "$GXX" = "yes"; then
     case ${host} in
-        *-*-cygwin)
-            ;;
-        *-*-mingw*)
+        *-*-cygwin*|*-*-msys*|*-*-mingw*)
             ;;
         *)
             AC_LANG(C++)
             AC_CACHE_CHECK([if $CXX supports -fvisibility],[x_cv_fvisibility],[
                 x_save="$CXXFLAGS"
                 CXXFLAGS="$CXXFLAGS -fvisibility=hidden"
-                AC_TRY_COMPILE([],[],[x_cv_fvisibility=yes],[x_cv_fvisibility=no])
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],[x_cv_fvisibility=yes],[x_cv_fvisibility=no])
                 if test "$x_cv_fvisibility" != "yes"; then
                     CXXFLAGS="$x_save"
                 fi
@@ -246,7 +219,7 @@ fi
 # check for --disable-gch
 ###############################################################################
 
-AC_MSG_CHECKING([if GCC precompiled-headers should be created])
+AC_MSG_CHECKING([if precompiled-headers should be created])
 
 X_GCH=0
 X_GCH_FLAGS=
@@ -256,19 +229,8 @@ X_GCH_SHARED=0
 X_GCH_SHARED_FLAGS="$lt_prog_compiler_pic_CXX"
 
 if test "$enable_gch" = "yes"; then
-    X_GCH=1
-elif test "$enable_gch" != "no"; then
-    if test "$GXX" = "yes"; then
-        case ${host_os} in
-            cygwin*|darwin*|freebsd*|linux*|mingw*|solaris*)
-                X_GCH=1
-                ;;
-        esac
-    fi
-fi
-
-if test "$X_GCH" -eq 1; then
     x_gch_result="yes"
+    X_GCH=1
     if test "$enable_static" = "yes"; then
         X_GCH_STATIC=1
     fi
@@ -293,22 +255,18 @@ AC_SUBST([X_GCH_SHARED_FLAGS])
 ###############################################################################
 
 if test "$enable_largefile" != "no" -a "$ac_cv_header_unistd_h" = "yes"; then
-    case ${host_cpu} in
-        i?86|ppc)
-            AC_LANG(C++)
-            AC_CACHE_CHECK([if LFS (large file support) is required],[x_cv_largefile],[
-                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+    AC_LANG(C++)
+    AC_CACHE_CHECK([if LFS (large file support) is required],[x_cv_largefile],[
+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <unistd.h>
 #ifndef _LFS_LARGEFILE
     error: not LFS conformant
 #endif
-                ]])],[x_cv_largefile=yes],[x_cv_largefile=no])
-            ])
-            if test "$x_cv_largefile" = "yes"; then
-                AC_DEFINE([NEED_LFS_ACTIVATION],[1],[Define to 1 if LFS should be activated])
-            fi
-            ;;
-    esac
+        ]])],[x_cv_largefile=yes],[x_cv_largefile=no])
+    ])
+    if test "$x_cv_largefile" = "yes"; then
+        AC_DEFINE([NEED_LFS_ACTIVATION],[1],[Define to 1 if LFS should be activated])
+    fi
 fi
 
 ###############################################################################
@@ -326,7 +284,7 @@ if test "$GXX" = "yes"; then
             yes)
                 case ${host} in
                     *-*-darwin*)
-                        x_flags="$xflags -arch i386 -arch x86_64 -arch ppc -arch ppc64"
+                        x_flags="$xflags -arch x86_64 -arch arm64"
                         ;;
                 esac
                 ;;
@@ -362,10 +320,10 @@ fi
 if test "$enable_debug" = "no"; then
     changequote(<<,>>)dnl
     if test "$GCC" = "yes"; then
-        CFLAGS=`echo "$CFLAGS" | sed -e 's/-g[^ ]*[ ]*//' -e 's/^ //' -e 's/ $//'`
+        CFLAGS=`echo "-DNDEBUG $CFLAGS" | sed -e 's/-g[^ ]*[ ]*//' -e 's/^ //' -e 's/ $//'`
     fi
     if test "$GXX" = "yes"; then
-        CXXFLAGS=`echo "$CXXFLAGS" | sed -e 's/-g[^ ]*[ ]*//' -e 's/^ //' -e 's/ $//'`
+        CXXFLAGS=`echo "-DNDEBUG $CXXFLAGS" | sed -e 's/-g[^ ]*[ ]*//' -e 's/^ //' -e 's/ $//'`
     fi
     changequote([,])dnl
 fi
@@ -409,14 +367,26 @@ AC_SUBST([X_CXX_D])
 AC_SUBST([X_CXX_I])
 AC_SUBST([X_MINGW_LIBS])
 
+AH_VERBATIM([MP4V2_EXPORTS],
+[/* libtool defines DLL_EXPORT for windows dll
+   builds, but we use MP4V2_EXPORTS instead. */
+#ifdef DLL_EXPORT
+# define MP4V2_EXPORTS
+#else
+# define MP4V2_USE_STATIC_LIB
+#endif])
+
 ###############################################################################
 # output files
 ###############################################################################
 
 AC_CONFIG_HEADERS([libplatform/config.h])
 
-AC_CONFIG_FILES([GNUmakefile])
-AC_CONFIG_FILES([include/mp4v2/project.h])
-AC_CONFIG_FILES([project/project.m4])
+AC_CONFIG_FILES([
+    GNUmakefile
+    mp4v2.pc
+    project/project.m4
+    include/mp4v2/project.h
+])
 
 AC_OUTPUT
diff --git a/mp4v2/doc/GNUmakefile.mk b/mp4v2/doc/GNUmakefile.mk
new file mode 100644
index 0000000..7b74a40
--- /dev/null
+++ b/mp4v2/doc/GNUmakefile.mk
@@ -0,0 +1,394 @@
+###############################################################################
+##
+##  makefile for documentation creation
+##
+##  INTPUT FILES (SOURCE/doc)
+##      doc/
+##          dox/            <-- generated API docs support files
+##          doxygen/        <-- generated API docs support files
+##          texi/           <-- hand-written project articles
+##
+##  OUTPUT FILES (BUILD/doc)
+##      doc/
+##      doc/
+##          api/
+##              html/   <-- API in html format
+##              xml/    <-- API in xml format
+##          articles/
+##              html/   <-- articles in html format
+##              txt/    <-- articles in txt format
+##              wiki/   <-- articles in Google Code Wiki format
+##              xml/    <-- articles in xml-texinfo format
+##          man/
+##              man1/   <-- man-pages for utilities
+##
+###############################################################################
+
+# Conventional VPATH directive breaks too many things so we use vpath and its
+# pattern-spec feature. If new files or extensions are introduced they may need
+# to be added here.
+
+VPATH =
+
+vpath COPYING       $(top_srcdir)
+vpath INSTALL       $(top_srcdir)
+vpath README        $(top_srcdir)
+vpath autoaux/%     $(top_srcdir)
+vpath %.1           $(top_srcdir)
+vpath %.cpp         $(top_srcdir)
+vpath %.h           $(top_srcdir)
+vpath %.m4          $(top_srcdir)
+vpath %.tcc         $(top_srcdir)
+
+###############################################################################
+
+SOURCE/ = $(top_srcdir)/
+BUILD/  = $(top_builddir)/
+
+DOC.in/  = $(SOURCE/)doc/
+DOC.out/ = $(BUILD/)doc/
+
+DOC.out.api/      = $(DOC.out/)api/
+DOC.out.articles/ = $(DOC.out/)articles/
+DOC.out.site/     = $(DOC.out/)site/
+
+###############################################################################
+
+M4       = m4
+M4.flags = -I$(BUILD/)project
+M4.cmd   = $(M4) $(M4.flags) $(1) > $(2)
+M4.deps  = $(BUILD/)project/project.m4
+
+ifeq ($(FOUND_HELP2MAN),yes)
+HELP2MAN       = help2man
+HELP2MAN.flags = -m "$(PROJECT_name) Utilities" -N
+HELP2MAN.cmd   = $(HELP2MAN) $(HELP2MAN.flags) ./$(1) -o $(2)
+else
+HELP2MAN.cmd = touch $(2)
+endif
+
+MAKEINFO.flags      = -I$(DOC.in/)texi -I$(DOC.out/)texi
+MAKEINFO.flags.html = --html --no-headers --no-split
+MAKEINFO.flags.txt  = --plaintext --no-headers
+MAKEINFO.flags.xml  = --xml --output-indent=4
+MAKEINFO.cmd        = makeinfo $(MAKEINFO.flags) $(MAKEINFO.flags.$(1)) $(2) -o $(3)
+
+HTMLCOMBINE = $(SOURCE/)project/htmlcombine.py
+HTMLCOMBINE.cmd   = $(HTMLCOMBINE) --header $(1) --footer $(2) --body $(3) > $(4)
+HTMLCOMBINE.deps  = $(HTMLCOMBINE)
+
+XML2WIKI       = $(SOURCE/)project/xml2wiki.py
+XML2WIKI.flags = --date --toc
+XML2WIKI.cmd   = $(XML2WIKI) $(XML2WIKI.flags) $(1) > $(2)
+XML2WIKI.deps  = $(XML2WIKI)
+
+DOXYGEN     = doxygen
+DOXYGEN.cmd = $(DOXYGEN) $(1)
+
+###############################################################################
+
+DOC.m4.out = \
+    doc/texi/base/project.texi \
+    doc/doxygen/Doxyfile       \
+    doc/doxygen/footer.html    \
+    doc/html/header.html       \
+    doc/html/footer.html
+
+DOC.man.utils = mp4art mp4chaps mp4file mp4subtitle mp4tags mp4track
+DOC.man.out   = $(DOC.man.utils:%=$(DOC.out/)man/man1/%.1)
+
+DOC.texi.articles = $(wildcard $(DOC.in/)texi/*.texi)
+
+DOC.texi.includes = \
+    doc/texi/base/project.texi \
+    $(wildcard $(DOC.in/)texi/*/*.texi $(DOC.out/)texi/*/*.texi)
+
+DOC.texi2html.out = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)html/%.html)
+DOC.texi2txt.out  = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)txt/%.txt)
+DOC.texi2xml.out  = $(DOC.texi.articles:$(DOC.in/)texi/%.texi=$(DOC.out.articles/)xml/%.xml)
+
+DOC.xml2wiki.out  = $(DOC.texi2xml.out:$(DOC.out.articles/)xml/%.xml=$(DOC.out.articles/)wiki/%.wiki)
+
+DOC.api.out = $(DOC.out.api/).stamp
+
+DOC.site.out       = $(DOC.out.site/).stamp
+DOC.site.out.copy  = $(patsubst $(DOC.in/)html/%,$(DOC.out.site/)%, \
+    $(filter-out %.in,$(wildcard $(DOC.in/)html/*)))
+DOC.site.out.index = $(DOC.out.site/)index.html
+DOC.site.out.html  = $(patsubst $(DOC.out.articles/)html/%,$(DOC.out.site/)%, \
+    $(filter-out %/Documentation.html,$(DOC.texi2html.out)))
+
+###############################################################################
+
+MKDIRS += $(dir $(DOC.m4.out))
+MKDIRS += $(DOC.out/)man/man1/
+MKDIRS += $(foreach n,html man texi txt wiki xml,$(DOC.out.articles/)$n/)
+MKDIRS += $(DOC.out.api/)
+MKDIRS += $(DOC.out.site/)
+
+###############################################################################
+
+EXTRA_DIST += \
+    $(SOURCE/)CMakeLists.txt \
+    $(SOURCE/)libplatform/config.h.cmake \
+    $(wildcard $(SOURCE/)example/**/*.c) \
+    $(wildcard $(SOURCE/)testsuite/**/*.exp) \
+    $(SOURCE/)vstudio/mp4v2.sln \
+    $(SOURCE/)vstudio/include/mp4v2/project.h \
+    $(wildcard $(SOURCE/)vstudio/*/*.natvis) \
+    $(wildcard $(SOURCE/)vstudio/*/*.rc) \
+    $(wildcard $(SOURCE/)vstudio/*/*.vcxproj) \
+    $(wildcard $(SOURCE/)vstudio/*/*.vcxproj.filters) \
+    $(SOURCE/)xcode/include/libplatform/config.h \
+    $(SOURCE/)xcode/include/mp4v2/project.h \
+    $(SOURCE/)xcode/mp4v2.xcodeproj/project.pbxproj \
+    $(SOURCE/)xcode/mp4v2.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+
+###############################################################################
+
+dist-hook: $(DOC.texi2txt.out) $(DOC.man.out)
+	rm -fr $(distdir)/doc
+	$(mkdir_p) $(distdir)/doc
+	$(INSTALL_DATA) $(DOC.in/)GNUmakefile.mk $(distdir)/doc/.
+ifneq (,$(DOC.texi2txt.out))
+	$(INSTALL_DATA) $(DOC.texi2txt.out) $(distdir)/doc/.
+endif
+ifneq (,$(DOC.man.out))
+	$(mkdir_p) $(distdir)/doc/man/man1
+	$(INSTALL_DATA) $(DOC.man.out) $(distdir)/doc/man/man1
+endif
+
+distclean-local: docclean
+
+###############################################################################
+
+$(DOC.m4.out): %: %.m4 $(M4.deps) | $(dir $(DOC.m4.out))
+	$(call M4.cmd,$<,$@)
+
+###############################################################################
+
+.PHONY: articles doc
+articles: html txt xml wiki
+doc: man articles api site
+
+.PHONY: articlesclean apiclean docclean
+articlesclean: htmlclean txtclean xmlclean wikiclean
+docclean: manclean articlesclean apiclean siteclean
+
+.PHONY: man html txt xml wiki api
+man: $(DOC.man.out)
+html: $(DOC.texi2html.out)
+txt: $(DOC.texi2txt.out)
+xml: $(DOC.texi2xml.out)
+wiki: $(DOC.xml2wiki.out)
+api: $(DOC.api.out)
+site: $(DOC.site.out)
+
+.PHONY: manclean htmlclean txtclean xmlclean wikiclean apiclean
+manclean:
+	rm -f $(DOC.man.out)
+
+htmlclean:
+	rm -f $(DOC.texi2html.out)
+
+txtclean:
+	rm -f $(DOC.texi2txt.out)
+
+xmlclean:
+	rm -f $(DOC.texi2xml.out)
+
+wikiclean:
+	rm -f $(DOC.xml2wiki.out)
+
+apiclean:
+	rm -f $(DOC.api.out)
+	rm -fr $(DOC.out.api/)html/ $(DOC.out.api/)xml/
+
+siteclean:
+	rm -fr $(DOC.out.site/)
+
+###############################################################################
+
+$(DOC.man.out): | $(dir $(DOC.man.out))
+$(DOC.man.out): $(DOC.out/)man/man1/%.1: $(BUILD/)%$(EXEEXT)
+	$(call HELP2MAN.cmd,$<,$@)
+
+$(DOC.texi2html.out): $(DOC.texi.includes) | $(dir $(DOC.texi2html.out))
+$(DOC.texi2html.out): $(DOC.out.articles/)html/%.html: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,html,$<,$@)
+
+$(DOC.texi2txt.out): $(DOC.texi.includes) | $(dir $(DOC.texi2txt.out))
+$(DOC.texi2txt.out): $(DOC.out.articles/)txt/%.txt: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,txt,$<,$@)
+
+$(DOC.texi2xml.out): $(DOC.texi.includes) | $(dir $(DOC.texi2xml.out))
+$(DOC.texi2xml.out): $(DOC.out.articles/)xml/%.xml: $(DOC.in/)texi/%.texi
+	$(call MAKEINFO.cmd,xml,$<,$@)
+
+$(DOC.xml2wiki.out): $(XML2WIKI.deps) | $(dir $(DOC.xml2wiki.out))
+$(DOC.xml2wiki.out): $(DOC.out.articles/)wiki/%.wiki: $(DOC.out.articles/)xml/%.xml
+	$(call XML2WIKI.cmd,$<,$@)
+
+$(DOC.api.out): | $(dir $(DOC.api.out))
+$(DOC.api.out): $(DOC.in/)doxygen/project.css
+$(DOC.api.out): $(DOC.out/)doxygen/footer.html
+$(DOC.api.out): $(DOC.out/)doxygen/Doxyfile
+	$(call DOXYGEN.cmd,$<)
+	touch $@
+
+###############################################################################
+
+$(DOC.site.out): | $(DOC.out.site/)articles
+$(DOC.site.out): | $(DOC.out.site/)api
+$(DOC.site.out): $(DOC.site.out.copy)
+$(DOC.site.out): $(DOC.site.out.index)
+$(DOC.site.out): $(DOC.site.out.html)
+
+$(DOC.out.site/)articles: | html $(DOC.out.site/)
+	rm -f $@
+	ln -s ../articles/html $@
+
+$(DOC.out.site/)api: | api $(DOC.out.site/)
+	rm -f $@
+	ln -s ../api/html $@
+
+$(DOC.site.out.copy): $(DOC.out.site/)%: $(DOC.in/)html/%
+	$(INSTALL_DATA) $^ $(@D)/.
+
+$(DOC.site.out.index): $(DOC.out/)html/header.html $(DOC.out/)html/footer.html
+$(DOC.site.out.index): $(HTMLCOMBINE.deps)
+$(DOC.site.out.index): $(DOC.out.articles/)html/Documentation.html
+	$(call HTMLCOMBINE.cmd,$(word 2,$^),$(word 3,$^),$<,$@)
+
+$(DOC.site.out.html): $(DOC.out/)html/header.html $(DOC.out/)html/footer.html
+$(DOC.site.out.html): $(HTMLCOMBINE.deps)
+$(DOC.site.out.html): $(DOC.out.site/)%: $(DOC.out.articles/)html/%
+	$(call HTMLCOMBINE.cmd,$(word 2,$^),$(word 3,$^),$<,$@)
+
+###############################################################################
+
+GOOGLE.out/      = $(top_builddir)/google/
+GOOGLE.repo.doc  = $(PROJECT_repo_branch)
+
+google.clean:
+	rm -fr $(GOOGLE.out/)
+
+google.post: site wiki
+google.post: | $(GOOGLE.out/)
+google.post: google.rsync google.rm google.add google.propset
+
+$(GOOGLE.out/):
+	svn co --depth immediates $(PROJECT_repo_root) $(GOOGLE.out/)
+	svn update --set-depth immediates google/wiki
+	svn update --set-depth infinity google/doc/$(GOOGLE.repo.doc)
+
+google.rsync:
+	rsync -vrptPL --delete \
+	    --exclude=".svn/*" --exclude=".svn" \
+	    --exclude="*/.svn/*" --exclude="*/.svn" \
+	    --exclude=".stamp" --exclude="*/.stamp" \
+	    --exclude="*.m4" --exclude="*/*.m4" \
+	    $(DOC.out.site/). $(GOOGLE.out/)doc/$(GOOGLE.repo.doc)/.
+	$(INSTALL_DATA) $(DOC.out.articles/)wiki/BuildRepository.wiki $(GOOGLE.out/)wiki/.
+	$(INSTALL_DATA) $(DOC.out.articles/)wiki/BuildSource.wiki $(GOOGLE.out/)wiki/.
+
+google.rm:
+	@files=`svn status $(GOOGLE.out/) | grep '^!' | awk '{ print $$2 }'`; \
+	if [ -n "$$files" ]; then \
+	    svn rm $$files; \
+	fi
+
+google.add:
+	@files=`svn status $(GOOGLE.out/) | grep '^?' | awk '{ print $$2 }'`; \
+	if [ -n "$$files" ]; then \
+	    svn add $$files; \
+	fi
+
+google.propset:
+	find $(GOOGLE.out/)doc/$(GOOGLE.repo.doc) -type f -a \( -name "*.html" -o -name "*.css" \) -print0 \
+	    | xargs -0 svn propset svn:eol-style native
+	find $(GOOGLE.out/)doc/$(GOOGLE.repo.doc) -type f -a -name "*.html" -print0 \
+	    | xargs -0 svn propset svn:mime-type "text/html"
+
+###############################################################################
+
+dist-hb: distdir=lib$(PACKAGE)
+dist-hb: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >lib$(PACKAGE)-$(VERSION).tar.gz
+	$(am__remove_distdir)
+
+###############################################################################
+
+## Precompiled header support is tricky given libtool's complexity and its
+## historical aversion to supporting it.
+##
+## What we do is add rules to precompile. Unfortunately, we cannot
+## automatically determine what flags libtool adds for compilation variants;
+## ie: PIC or non-PIC compilation. So instead we will hardcode the flags
+## to match. The reason for this is the precompiled-header will not be used if
+## (relevent) compilation flags differ.
+
+CXX.gch.static.flags = $(X_GCH_STATIC_FLAGS)
+CXX.gch.static.in    = libplatform/impl.h src/impl.h libutil/impl.h
+CXX.gch.static.out   = $(CXX.gch.static.in:%=$(BUILD/)%.gch/static)
+
+CXX.gch.shared.flags = $(X_GCH_SHARED_FLAGS)
+CXX.gch.shared.in    = libplatform/impl.h src/impl.h libutil/impl.h
+CXX.gch.shared.out   = $(CXX.gch.shared.in:%=$(BUILD/)%.gch/shared)
+
+CXX.gch.exe.flags = $(X_GCH_FLAGS)
+CXX.gch.exe.in    = util/impl.h
+CXX.gch.exe.out   = $(CXX.gch.exe.in:%=$(BUILD/)%.gch/exe)
+
+CXX.gch.static.dependents = $(libmp4v2_la_OBJECTS)
+CXX.gch.shared.dependents = $(libmp4v2_la_OBJECTS)
+
+CXX.gch.exe.dependents = \
+    $(mp4art_OBJECTS)        \
+    $(mp4chaps_OBJECTS)      \
+    $(mp4extract_OBJECTS)    \
+    $(mp4file_OBJECTS)       \
+    $(mp4info_OBJECTS)       \
+    $(mp4subtitle_OBJECTS)   \
+    $(mp4syncfiles_OBJECTS)  \
+    $(mp4tags_OBJECTS)       \
+    $(mp4track_OBJECTS)      \
+    $(mp4trackdump_OBJECTS)
+
+ifeq ($(X_GCH_STATIC),1)
+$(CXX.gch.static.dependents): $(CXX.gch.static.out)
+endif
+
+ifeq ($(X_GCH_SHARED),1)
+$(CXX.gch.shared.dependents): $(CXX.gch.shared.out)
+endif
+
+ifeq ($(X_GCH),1)
+$(CXX.gch.exe.dependents): $(CXX.gch.exe.out)
+endif
+
+$(CXX.gch.static.out): | $(sort $(dir $(CXX.gch.static.out)))
+$(CXX.gch.static.out): $(BUILD/)%.gch/static: %
+	$(CXXCOMPILE) $(CXX.gch.static.flags) -c $< -o $@
+
+$(CXX.gch.shared.out): | $(sort $(dir $(CXX.gch.shared.out)))
+$(CXX.gch.shared.out): $(BUILD/)%.gch/shared: %
+	$(CXXCOMPILE) $(CXX.gch.shared.flags) -c $< -o $@
+
+$(CXX.gch.exe.out): | $(sort $(dir $(CXX.gch.exe.out)))
+$(CXX.gch.exe.out): $(BUILD/)%.gch/exe: %
+	$(CXXCOMPILE) $(CXX.gch.exe.flags) -c $< -o $@
+
+MKDIRS += $(dir $(CXX.gch.static.out))
+MKDIRS += $(dir $(CXX.gch.shared.out))
+MKDIRS += $(dir $(CXX.gch.exe.out))
+
+clean-local:
+	rm -f $(CXX.gch.static.out)
+	rm -f $(CXX.gch.shared.out)
+	rm -f $(CXX.gch.exe.out)
+
+###############################################################################
+
+$(sort $(MKDIRS)):
+	$(mkdir_p) $(sort $(MKDIRS))
diff --git a/mp4v2/doc/doxygen/Doxyfile.m4 b/mp4v2/doc/doxygen/Doxyfile.m4
new file mode 100644
index 0000000..11d3853
--- /dev/null
+++ b/mp4v2/doc/doxygen/Doxyfile.m4
@@ -0,0 +1,2532 @@
+changequote(<<,>>)dnl
+include(<<project.m4>>)dnl
+# Doxyfile 1.8.17
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the configuration
+# file that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = __PROJECT_name
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         =
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          =
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = __MAKE_ABS_TOP_BUILDDIR/doc/api
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all generated output in the proper direction.
+# Possible values are: None, LTR, RTL and Context.
+# The default value is: None.
+
+OUTPUT_TEXT_DIRECTION  = None
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        = __MAKE_ABS_TOP_SRCDIR
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
+# such as
+# /***************
+# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
+# Javadoc-style will behave just like regular comments and it will not be
+# interpreted by doxygen.
+# The default value is: NO.
+
+JAVADOC_BANNER         = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines (in the resulting output). You can put ^^ in the value part of an
+# alias to insert a newline as if a physical newline was in the original file.
+# When you need a literal { or } or , in the value part of an alias you have to
+# escape them by means of a backslash (\), this can lead to conflicts with the
+# commands \{ and \} for these it is advised to use the version @{ and @} or use
+# a double escape (\\{ and \\})
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
+# sources only. Doxygen will then generate output that is more tailored for that
+# language. For instance, namespaces will be presented as modules, types will be
+# separated into more groups, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_SLICE  = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
+# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice,
+# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
+# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
+# tries to guess whether the code is fixed or free formatted code, this is the
+# default for Fortran type files), VHDL, tcl. For instance to make doxygen treat
+# .inc files as Fortran files (default is PHP), and .f files as C (default is
+# Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See https://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 5.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 5
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
+# methods of a class will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIV_VIRTUAL   = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# declarations. If set to NO, these declarations will be included in the
+# documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# (including Cygwin) ands Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = NO
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = NO
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation. If
+# EXTRACT_ALL is set to YES then this flag will automatically be disabled.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = __MAKE_ABS_TOP_SRCDIR/doc/doxygen/mainpage.h \
+                         __MAKE_ABS_TOP_SRCDIR/include                \
+                         __MAKE_ABS_TOP_SRCDIR/libplatform            \
+                         __MAKE_ABS_TOP_SRCDIR/src/itmf               \
+                         __MAKE_ABS_TOP_SRCDIR/src/qtff
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C comment),
+# *.doc (to be provided as doxygen C comment), *.txt (to be provided as doxygen
+# C comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f, *.for, *.tcl, *.vhd,
+# *.vhdl, *.ucf, *.qsf and *.ice.
+
+FILE_PATTERNS          = *.h
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           = __MAKE_ABS_TOP_SRCDIR
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# entity all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see https://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          =
+
+# If clang assisted parsing is enabled you can provide the clang parser with the
+# path to the compilation database (see:
+# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) used when the files
+# were built. This is equivalent to specifying the "-p" option to a clang tool,
+# such as clang-check. These options will then be passed to the parser.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+
+CLANG_DATABASE_PATH    =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            = __MAKE_ABS_TOP_BUILDDIR/doc/doxygen/footer.html
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  = __MAKE_ABS_TOP_SRCDIR/doc/doxygen/project.css
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
+# documentation will contain a main index with vertical navigation menus that
+# are dynamically created via JavaScript. If disabled, the navigation index will
+# consists of multiple levels of tabs that are statically embedded in every HTML
+# page. Disable this option to support browsers that do not have JavaScript,
+# like the Qt help browser.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_MENUS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: https://developer.apple.com/xcode/), introduced with OSX
+# 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
+# genXcode/_index.html for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: https://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NONE
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 3
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
+# to create new LaTeX commands to be used in formulas as building blocks. See
+# the section "Including formulas" for details.
+
+FORMULA_MACROFILE      =
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# https://www.mathjax.org) which uses client side JavaScript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from https://www.mathjax.org before deployment.
+# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using JavaScript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when not enabling USE_PDFLATEX the default is latex when enabling
+# USE_PDFLATEX the default is pdflatex and when in the later case latex is
+# chosen this is overwritten by pdflatex. For specific output languages the
+# default can have been set differently, this depends on the implementation of
+# the output language.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# Note: This tag is used in the Makefile / make.bat.
+# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
+# (.tex).
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
+# generate index for LaTeX. In case there is no backslash (\) as first character
+# it will be automatically added in the LaTeX code.
+# Note: This tag is used in the generated output file (.tex).
+# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
+# The default value is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_MAKEINDEX_CMD    = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
+# path from which the emoji images will be read. If a relative path is entered,
+# it will be relative to the LATEX_OUTPUT directory. If left blank the
+# LATEX_OUTPUT directory will be used.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EMOJI_DIRECTORY  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# configuration file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's configuration file. A template extensions file can be
+# generated using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = YES
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
+# namespace members in file scope as well, matching the HTML output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_NS_MEMB_FILE_SCOPE = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = YES
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             = MP4V2_EXPORT \
+                         MP4V2_DEPRECATED \
+                         "DEFAULT(x)= =x" \
+                         MP4V2_WFORMAT_PRINTF()=
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: YES.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           =
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,
+# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,
+# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff --git a/mp4v2/doc/doxygen/footer.html.m4 b/mp4v2/doc/doxygen/footer.html.m4
new file mode 100644
index 0000000..d033f90
--- /dev/null
+++ b/mp4v2/doc/doxygen/footer.html.m4
@@ -0,0 +1,10 @@
+changequote(<<,>>)dnl
+include(<<project.m4>>)dnl
+<address class="footer">
+    <small>
+        generated on $datetime for <b>__PROJECT_name __PROJECT_version</b>
+        by <a href="https://www.doxygen.org/index.html">Doxygen</a> $doxygenversion
+    </small>
+</address>
+</body>
+</html>
diff --git a/mp4v2/doc/doxygen/mainpage.h b/mp4v2/doc/doxygen/mainpage.h
new file mode 100644
index 0000000..c5c0ad1
--- /dev/null
+++ b/mp4v2/doc/doxygen/mainpage.h
@@ -0,0 +1,63 @@
+/** @mainpage MP4v2 API Reference
+
+@section api Public API
+
+The public API is documented in the <a href="modules.html">modules</a>
+section (as seen at the top of this page).
+Other documentation available for C++ namespaces and classes are for
+internal documentation purposes and not to be used or depended-upon by
+code external to this project.
+
+@section introducation Introduction
+
+The MP4v2 library provides an API to create and modify mp4 files as defined
+by ISO base media file format, document number ISO/IEC 14496-12:2005(E). It
+is a very powerful and extensible format that can accomodate practically
+any type of media.
+
+The conceptual structure of an mp4 file is that it is a container for one
+or more tracks of media. Each track represents exactly one type of media
+such as audio or video. Each track is composed of high-level structural
+data which describes the raw media data stream in a manner that is as
+generic as possible. Tracks have their own timeline, properties and
+samples. An example of a sample is a frame of video. Thus, the file
+file describes how to synchronize the timeline of the tracks.
+
+In a self-contained file, the samples accounts for the majority of file
+size. For playback performance reasons, when an mp4 file contains multiple
+media tracks their samples (raw media data) are usually interleaved to
+provide optimal playback performance.
+
+@section invocation Invocation
+
+The mp4 library is focussed on providing an easy to use API for the mp4
+file format. It has been used with an encoder, a server, a player, and a
+number of mp4 utilities. However, it may not be adequate for multimedia
+editors that wish to work directly with mp4 files. It may be used by these
+type of tools to export an mp4 file.
+
+In providing a easy to use API not all the information in the mp4 file is
+directly exposed via the API. To accomodate applications that need access
+to information not otherwise available via the API there are file and
+track level generic get and set property routines that use arbitary string
+property names. To use these routines you will need to be familar with the
+mp4 file specification or be willing to wade through the output of a
+file-dump which may be produced using MP4Dump() or with some of the
+command-line tools bundled with MP4v2.
+
+@section headers Public Headers
+
+The public libary API is defined in @c <mp4v2/mp4v2.h> which includes all the
+necessary dependent header files. <b>You must never use any other header
+files</b> for public API. Using other header files or symbols which are
+not exported via the public API is expressly not supported and may change
+at any time without notice.
+
+The MP4v2 library can be used by either C or C++ programs. The calling
+convention is C but for convenience, if C++ is used, default function arguments
+have been added where appropriate.
+
+@example example/callbacks/callbacks.c
+@example example/itmf/generic.c
+@example example/itmf/tags.c
+*/
diff --git a/mp4v2/doc/doxygen/project.css b/mp4v2/doc/doxygen/project.css
new file mode 100644
index 0000000..b55f323
--- /dev/null
+++ b/mp4v2/doc/doxygen/project.css
@@ -0,0 +1,51 @@
+body {
+    background-color: #D0D0D0;
+    min-width: 800px;
+    max-width: 1360px;
+    margin: 0 auto;
+    padding-top: 0.5em;
+    padding-bottom: 1em;
+}
+
+div.header {
+    background-image: none;
+    border-bottom: 0;
+}
+
+div#projectname {
+    margin-left: 3px;
+    font-weight: bold;
+}
+
+div#top, div.header, div.contents, address.footer {
+    margin-left: 40px;
+    margin-right: 40px;
+    background-color: #FFFFFF;
+    position: relative;
+    -webkit-box-shadow: 5px 5px 5px black;
+}
+
+div.contents {
+    margin-top: 12px;
+    padding-left: 16px;
+    padding-top: 16px;
+    padding-right: 16px;
+    padding-bottom: 2px;
+}
+
+div.title {
+    margin-top: 5px;
+    margin-bottom: 5px;
+}
+
+table.markdownTable {
+    margin-left: 1em;
+}
+
+td.markdownTableBodyNone {
+    vertical-align: top;
+}
+
+address.footer {
+    margin-top: 12px;
+}
diff --git a/mp4v2/doc/html/banner.png b/mp4v2/doc/html/banner.png
new file mode 100644
index 0000000..52dd326
Binary files /dev/null and b/mp4v2/doc/html/banner.png differ
diff --git a/mp4v2/doc/html/footer.html.m4 b/mp4v2/doc/html/footer.html.m4
new file mode 100644
index 0000000..54504a8
--- /dev/null
+++ b/mp4v2/doc/html/footer.html.m4
@@ -0,0 +1,10 @@
+changequote(<<,>>)dnl
+include(<<project.m4>>)dnl
+</div>
+<div id="footer">
+    <div>
+        generated on __PROJECT_build for <b>__PROJECT_name (__PROJECT_version)</b>
+    </div>
+</div>
+</body>
+</html>
diff --git a/mp4v2/doc/html/header.html.m4 b/mp4v2/doc/html/header.html.m4
new file mode 100644
index 0000000..bf11af1
--- /dev/null
+++ b/mp4v2/doc/html/header.html.m4
@@ -0,0 +1,26 @@
+changequote(<<,>>)dnl
+include(<<project.m4>>)dnl
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
+    <title>__TITLE__</title>
+    <link href="project.css" rel="stylesheet" type="text/css">
+</head>
+<body>
+<div id="page">
+<div id="sitebanner">
+    <div id="home">
+        <a href="__PROJECT_url_website"></a>
+    </div>
+    <div id="title">
+        __SHORT_TITLE__
+    </div>
+    <div id="menu">
+        <ul>
+            <li><a href="__PROJECT_url_website">__PROJECT_name Home</a></li>
+__MENU__
+            <!-- <li class="active">Documentation</li> -->
+        </ul>
+    </div>
+</div>
+<div id="content">
diff --git a/mp4v2/doc/html/project.css b/mp4v2/doc/html/project.css
new file mode 100644
index 0000000..2745b92
--- /dev/null
+++ b/mp4v2/doc/html/project.css
@@ -0,0 +1,198 @@
+* {
+    margin: 0px;
+    padding: 0px;
+}
+
+body,table {
+    font-family: Arial, Helvetica, sans-serif;
+    font-size: 13px;
+}
+
+body {
+    background-color: #3C464D;
+    min-width: 800px;
+    max-width:  1360px;
+    padding-top: 0.5em;
+    padding-bottom: 1em;
+}
+
+a {
+    color: #5382A1;
+    text-decoration: none;
+    font-weight: bold;
+}
+
+a:hover {
+    color: #9E005D;
+}
+
+h1 {
+    text-align: center;
+    font-size: 140%;
+}
+
+h2 {
+    font-size: 120%;
+}
+
+h3 {
+    font-size: 100%;
+}
+
+img {
+    border: none;
+    vertical-align: middle;
+}
+
+/* ----------------------------------*/
+
+dd,ul {
+    padding-left: 40px;
+}
+
+h1,h2,h3 {
+    margin-top: 1.5em;
+    margin-bottom: 1.0em;
+}
+
+h2 {
+    border-bottom: 2px solid;
+}
+
+p,ul {
+    margin-top: 1em;
+}
+
+dd,ol {
+    padding-left: 40px;
+}
+
+ul ul {
+    margin-top: 0;
+    margin-bottom: 0;
+}
+
+/* ----------------------------------*/
+
+blockquote, dl, pre {
+    margin: 1em 4em;
+}
+
+pre {
+    background-color: #CCCCCC;
+    padding: 0.5em;
+    border: 1px solid #888888;
+}
+
+dl span.samp, dl span.command {
+    font-weight: bold;
+}
+
+/* ----------------------------------*/
+
+div#page {
+    margin-left: 40px;
+    margin-right: 40px;
+    position: relative;
+    background-color: #EDEFF2;
+    -webkit-border-radius: 1em;
+    -webkit-box-shadow: 5px 5px 5px black;
+    -moz-border-radius: 1em;
+}
+
+div#sitebanner, div#content, div#footer div {
+    padding-left: 16px;
+    padding-right: 16px;
+}
+
+div#sitebanner {
+    position: relative;
+    background-color: gray;
+    background-image: url(banner.png);
+    background-repeat: no-repeat;
+    background-position: top left;
+    min-height: 128px;
+    max-height: 128px;
+    text-shadow: black 1px 1px 0px;
+    -webkit-border-top-left-radius: 1em;
+    -webkit-border-top-right-radius: 1em;
+    -moz-border-radius-topleft: 1em;
+    -moz-border-radius-topright: 1em;
+}
+
+/* enable to make banner logo clickable */
+/*
+div#sitebanner div#home a {
+    display: block;
+    background: none;
+    position: absolute;
+    top: 8px;
+    left: 8px;
+    height: 80px;
+    width: 220px;
+}
+*/
+
+div#sitebanner div#title {
+    display: none;
+    position: absolute;
+    top: 40%;
+    left: 50%;
+    text-align: lef;
+    color: white;
+    color: #C9F08D;
+    font-weight: bold;
+    font-size: 150%;
+}
+
+div#sitebanner div#menu {
+    position: absolute;
+    top: 16px;
+    right: 16px;
+    color: white;
+    text-align: right;
+}
+
+div#sitebanner div#menu li {
+    list-style-type: none;
+}
+
+div#sitebanner div#menu li a {
+    color: white;
+    font-weight: normal;
+}
+
+div#sitebanner div#menu li.active,
+div#sitebanner div#menu li a:hover {
+    color: #C9F08D;
+}
+
+div#contents {
+    padding-top: 8px;
+    padding-bottom: 8px;
+}
+
+div#footer {
+    padding-top: 2em;
+    padding-bottom: 1em;
+    -webkit-border-bottom-left-radius: 1em;
+    -webkit-border-bottom-right-radius: 1em;
+    -moz-border-radius-bottomleft: 1em;
+    -moz-border-radius-bottomright: 1em;
+}
+
+div#footer div {
+    text-align: right;
+    font-size: x-small;
+    border-top: 2px solid #5382A1;
+}
+
+/* ----------------------------------*/
+
+div.contents ul {
+    list-style-type: none;
+    padding-left: 2em;
+}
+
+div.contents ul {
+}
diff --git a/mp4v2/doc/texi/Authors.texi b/mp4v2/doc/texi/Authors.texi
new file mode 100644
index 0000000..74f2cb8
--- /dev/null
+++ b/mp4v2/doc/texi/Authors.texi
@@ -0,0 +1,27 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename Authors.info
+@include base/article.texi
+@paragraphindent none
+@c %**end of header
+
+@majorheading @value{PROJECT.name.formal} Authors
+
+This document lists significant contributors to @value{PROJECT.name}. If any contributors are missing please contact one of the project members. More extensive contributor information may be found in sources, docs, and other files where appropriate.
+
+@example
+Edward Groenendaal          egroenen@@cisco.com
+Jonathon Rubin              jb.rubin@@gmail.com
+Kona Blend                  kona8lend@@gmail.com
+Rouven Wessling             mp4v2@@rouvenwessling.de
+@end example
+
+@heading Authors from original MPEG4IP/libmp4v2
+
+@example
+Dave Mackie                 dmackie@@cisco.com
+Alix Marchandise-Franquet   alix@@cisco.com
+Bill May                    wmay@@cisco.com
+Ximpo Group Ltd.            mp4v2@@ximpo.com
+Danijel Kopcinovic          danijel.kopcinovic@@adnecto.net
+@end example
diff --git a/mp4v2/doc/texi/BuildRepository.texi b/mp4v2/doc/texi/BuildRepository.texi
new file mode 100644
index 0000000..f784d69
--- /dev/null
+++ b/mp4v2/doc/texi/BuildRepository.texi
@@ -0,0 +1,42 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename BuildRepository.info
+@include base/article.texi
+@include build/commands.texi
+@paragraphindent none
+@c %**end of header
+
+@majorheading @value{PROJECT.name.formal} Building the Repository
+@contents
+
+@chapter Overview
+@include build/overview.texi
+
+@chapter Introduction
+This document describes the recommended process to build @value{PROJECT.name} from the repository. This process is a @b{superset} of the process to build from a @value{TERM.srcdist} bundle.  If you are interested in building from a @value{TERM.srcdist} bundle then this document is not for you.
+
+@chapter Quickstart
+This chapter is for the impatient or those just looking for a quick summary of all the commands used in a typical build. You may skip this summary and jump to @ref{Build Process}.
+
+@example
+@COMMANDcheckout{}
+@COMMANDbootstrap{}
+@COMMANDconfigure{}
+@COMMANDbuild{}
+@COMMANDinstall{}
+@COMMANDdist{}
+@end example
+
+@anchor{Build Process}
+@chapter Build Process
+
+@include build/process.checkout.texi
+@include build/process.bootstrap.texi
+@include build/process.configure.texi
+@include build/process.build.texi
+@include build/process.install.texi
+@include build/process.dist.texi
+@include build/process.doc.texi
+@include build/process.google.texi
+
+@include build/platforms.texi
diff --git a/mp4v2/doc/texi/BuildSource.texi b/mp4v2/doc/texi/BuildSource.texi
new file mode 100644
index 0000000..853dd30
--- /dev/null
+++ b/mp4v2/doc/texi/BuildSource.texi
@@ -0,0 +1,36 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename BuildSource.info
+@include base/article.texi
+@include build/commands.texi
+@paragraphindent none
+@c %**end of header
+
+@majorheading @value{PROJECT.name.formal} Building the Source
+@contents
+
+@chapter Overview
+@include build/overview.texi
+
+@chapter Introduction
+This document describes the recommended process to build @value{PROJECT.name} from a @value{TERM.srcdist} bundle. This process is a @b{subset} of the process to build directly from the project's repository. If you are interested in building from the repository then this document is not for you.
+
+@chapter Quickstart
+This chapter is for the impatient or those just looking for a quick summary of all the commands used in a typical build. You may skip this summary and jump to @ref{Build Process}.
+
+@example
+@COMMANDextract{}
+@COMMANDconfigure{}
+@COMMANDbuild{}
+@COMMANDinstall{}
+@end example
+
+@anchor{Build Process}
+@chapter Build Process
+
+@include build/process.extract.texi
+@include build/process.configure.texi
+@include build/process.build.texi
+@include build/process.install.texi
+
+@include build/platforms.texi
diff --git a/mp4v2/doc/texi/Documentation.texi b/mp4v2/doc/texi/Documentation.texi
new file mode 100644
index 0000000..ba4be09
--- /dev/null
+++ b/mp4v2/doc/texi/Documentation.texi
@@ -0,0 +1,50 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename Documentation.info
+@include base/article.texi
+@paragraphindent none
+@c %**end of header
+
+@titlepage
+@end titlepage
+
+@majorheading @value{PROJECT.name.formal} Documentation
+@include releasenotes/intro.stable.texi
+
+@heading Introduction
+Project @value{PROJECT.name} consists of a C-library and various command-line utilities which permit creation and modification of MP4 files as defined by as defined by @cite{ISO base media file format}, document number @cite{ISO/IEC 14496-12:2005(E)}.
+
+@heading Official website
+The official @url{@value{PROJECT.url.website},website} makes various @url{@value{PROJECT.url.downloads},downloads} available and archives online browesable documentation for releases, including API Reference.
+
+@heading Issues and discussions
+Bug reports and feature requests can be submitted to the @url{@value{PROJECT.url.bugreport},issue tracker}. Questions and general feedback may be posted to the @url{@value{PROJECT.url.discussion},discussion} board.
+
+@ifnothtml
+@unnumbered Articles
+   See Release Notes (@file{doc/ReleaseNotes.txt})
+@* See Building the Source (@file{doc/BuildSource.txt})
+@* See Building the Repository (@file{doc/BuildRepository.txt})
+@* See Authors (@file{doc/Authors.txt})
+
+@unnumbered Guides
+   See Command-line Tools Guide (@file{doc/ToolGuide.txt})
+@end ifnothtml
+
+@ifhtml
+@unnumbered Articles
+@enumerate
+@item @url{ReleaseNotes.html,Release Notes}.
+@item @url{BuildSource.html,Building the Source}.
+@item @url{BuildRepository.html,Building the Repository}.
+@item @url{Authors.html,Authors}.
+@end enumerate
+@unnumbered Guides
+@enumerate
+@item @url{ToolGuide.html,Command-line Tools Guide}.
+@end enumerate
+@unnumbered Reference
+@enumerate
+@item @url{api/index.html,API Reference}.
+@end enumerate
+@end ifhtml
diff --git a/mp4v2/doc/texi/ReleaseNotes.texi b/mp4v2/doc/texi/ReleaseNotes.texi
new file mode 100644
index 0000000..0b6284d
--- /dev/null
+++ b/mp4v2/doc/texi/ReleaseNotes.texi
@@ -0,0 +1,41 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename ReleaseNotes.info
+@include base/article.texi
+@paragraphindent none
+@c %**end of header
+
+@titlepage
+@end titlepage
+
+@majorheading @value{PROJECT.name.formal} Release Notes
+@include releasenotes/intro.stable.texi
+@contents
+
+@chapter What's New?
+Version 2.1.2 fixes build system issues, mainly in the CMake build system support. This release also fixes a file seeking
+issue observed on Windows when compiled with _WIN32_WINNT < 0x600 and linked against modern CRT DLLs. In addition, two minor
+issues related to data handling are fixed.
+
+Version 2.1.1 fixes a type mismatch preventing MP4v2 from compiling on 32 bit systems.
+
+Version 2.1 updates the existing build systems and adds support for building with CMake and Xcode. It also fixes compilation
+with newer compilers and integrates smaller improvements and bug fixes from various MP4v2 forks.
+
+@appendix Changelog
+@appendixsection Version 2.1
+@include changelog/version-2.1.texi
+
+@appendixsection Version 2.0
+@include changelog/version-2.0.texi
+
+@appendixsection Version 1.9
+@include changelog/version-1.9.texi
+
+@appendixsection Version 1.6
+@include changelog/version-1.6.texi
+
+@appendix SCM repository details
+@example
+url:  @value{PROJECT.repo.url}
+@end example
diff --git a/mp4v2/doc/texi/ToolGuide.texi b/mp4v2/doc/texi/ToolGuide.texi
new file mode 100644
index 0000000..ac63787
--- /dev/null
+++ b/mp4v2/doc/texi/ToolGuide.texi
@@ -0,0 +1,101 @@
+\input texinfo @c -*- Texinfo -*-
+@c %**start of header
+@setfilename ToolGuide.info
+@include base/guide.texi
+@paragraphindent none
+@c %**end of header
+
+@majorheading @value{PROJECT.name.formal} Command-line Tools Guide
+@contents
+
+@chapter Overview
+@value{PROJECT.name} bundles several command-line tools which, in general, allow some basic manipulation of mp4 files which have been created by other means. They are not meant to be a complete solution to management of mp4 file structure.
+
+The following is a brief summary of the tools available and the functionality offered. Other tools may be packaged with the distribution but are not yet stable enough to even document. User beware.
+
+@table @samp
+@item mp4file
+Operates on the entire file with actions such as list (summary information), optimization and ASCII dumps.
+
+@item mp4track
+Operates on individual tracks with actions such as colr-box and pasp-box manipulation.
+
+@item mp4art
+Operates on iTunes Metadata Cover-art Boxes with actions such as list, add, replace, remove and extraction of Cover-art images.
+
+@item mp4chaps
+Operates on chapter data (QuickTime and Nero) with actions such as list, convert, import, export and removal of chapter information.
+@end table
+
+@chapter Introduction
+The tools are invoked by their command-name, followed by one or more options, actions, parameters for actions, and finally one or more files on which the tool will operate. Options are specified in one of two ways; in @b{short} or @b{long} syntax. A short-syntax option is prefixed with exactly one @i{dash} while a long-syntax option is prefixed with exactly two @i{dashes}. Depending on the option, it may or may not expect an argument. Specifying an option which expects an argument usually follows either of the following patterns:
+
+@example
+toolname --something value ...
+toolname --something=value ...
+@end example
+
+The rest of this guide will use the @i{equals} sign method.
+
+@chapter Common Options
+Many of the tools share a common set of options which. These common options usually have identically behaving short or long syntax. In some cases short-syntax differs from long-syntax in that it may not require an argument. This style is used sparingly and only when truly convenient. Even though it is common practice in many unix-style tools to permit @i{optional} arguments, the tools used in this project will tend to avoid that because it can create a great deal of confusion.
+
+The following is a list of common options available:
+
+@table @samp
+@item -y, --dryrun
+do not actually create or modify any files.
+In situations where the command will create new or modify existing files, specifying this option will cause the tool to do as much as possible stopping short of performing any actual writes. This is useful to guard against user mistakes or unexpected behavior.
+
+@item -k, --keepgoing
+continue batch processing even after errors.
+When actions involve multiple files or operations, the default behavior is to stop and exit on the first error encountered. Specify this option if it is desirable to record the error but continue processing.
+
+@item -o, --overwrite
+overwrite existing files when creating.
+In situations where a new file will be created, the default behavior is to not overwrite a file if it already exists. Use this option to allow overwriting.
+
+@item -f, --force
+force overwrite even if file is read-only.
+If overwriting is enabled, file permissions may prevent writes. Specify this option to try and overwrite the file anyways. This usually involves deleting the file, then creating a new one.
+
+@item -q, --quiet
+equivalent to --verbose 0.
+Default behavior is to print a low amount of informative information, usually one line of text per action/file. Specify this option to omit normal messages. Errors will still be reported.
+
+@item -d, --debug NUM
+increase debug or long-option to set NUM.
+File I/O with mp4 file structures have special debug options available to users interested in all the fine details. Default is level 1 . The short-syntax is accumulative and takes no argument, while long-syntax takes an argument. For exmaple, the following are equivalent and would set level 3: @samp{-dd} or @samp{-d -d} or @samp{--debug=3}. The following levels are available:
+@enumerate 0
+@item  supressed
+@item  add warnings and errors (default)
+@item  add table details
+@item  add implicits
+@item  everything
+@end enumerate
+
+@item -v, --verbose NUM
+increase verbosity or long-option to set NUM.
+Tool activity by default will generally print one informative message per action/file. Specify this option to change the default behavior. The short-syntax is accumulative and takes no argument, while long-syntax takes an argument.
+@enumerate 0
+@item  warnings and errors
+@item  normal informative messages (default)
+@item  more informative messages
+@item  everything
+@end enumerate
+
+@item -h, --help
+print brief help or long-option for extended help.
+The short-syntax will produce brief help. Specify the long-option for more extensive help.
+
+@item --version
+print version information and exit.
+Extended version information used for SCM purposes is not listed in help, but is available by specifying @samp{--verionx}.
+@end table
+
+@include tool/mp4file.texi
+@include tool/mp4track.texi
+@include tool/mp4art.texi
+@include tool/mp4chaps.texi
+
+@include tool/mp4chaps.format.texi
diff --git a/mp4v2/doc/texi/base/article.texi b/mp4v2/doc/texi/base/article.texi
new file mode 100644
index 0000000..a5fdf76
--- /dev/null
+++ b/mp4v2/doc/texi/base/article.texi
@@ -0,0 +1,6 @@
+@ifhtml
+@exampleindent 0
+@end ifhtml
+
+@include base/project.texi
+@include base/glossary.texi
diff --git a/mp4v2/doc/texi/base/glossary.texi b/mp4v2/doc/texi/base/glossary.texi
new file mode 100644
index 0000000..c46a4f3
--- /dev/null
+++ b/mp4v2/doc/texi/base/glossary.texi
@@ -0,0 +1,9 @@
+@set OS.cygwin   Cygwin
+@set OS.freebsd  FreeBSD
+@set OS.linux    Linux
+@set OS.osx      Mac OS X
+@set OS.solaris  Solaris
+@set OS.unix     unix
+@set OS.windows  Windows
+
+@set TERM.srcdist  source-distribution
diff --git a/mp4v2/doc/texi/base/guide.texi b/mp4v2/doc/texi/base/guide.texi
new file mode 100644
index 0000000..a5fdf76
--- /dev/null
+++ b/mp4v2/doc/texi/base/guide.texi
@@ -0,0 +1,6 @@
+@ifhtml
+@exampleindent 0
+@end ifhtml
+
+@include base/project.texi
+@include base/glossary.texi
diff --git a/mp4v2/doc/texi/base/project.texi.m4 b/mp4v2/doc/texi/base/project.texi.m4
new file mode 100644
index 0000000..02cd684
--- /dev/null
+++ b/mp4v2/doc/texi/base/project.texi.m4
@@ -0,0 +1,18 @@
+changequote(<<,>>)dnl
+include(<<project.m4>>)dnl
+@set PROJECT.name            __PROJECT_name
+@set PROJECT.name.lower      __PROJECT_name_lower
+@set PROJECT.name.upper      __PROJECT_name_upper
+@set PROJECT.name.formal     __PROJECT_name_formal
+@set PROJECT.url.website     __PROJECT_url_website
+@set PROJECT.url.downloads   __PROJECT_url_downloads
+@set PROJECT.url.discussion  __PROJECT_url_discussion
+@set PROJECT.url.bugreport   __PROJECT_url_bugreport
+@set PROJECT.support         patsubst(__PROJECT_support,@,@@)
+@set PROJECT.version         __PROJECT_version
+@set PROJECT.version.hex     __PROJECT_version_hex
+@set PROJECT.version.major   __PROJECT_version_major
+@set PROJECT.version.minor   __PROJECT_version_minor
+@set PROJECT.version.point   __PROJECT_version_point
+@set PROJECT.repo.url        patsubst(__PROJECT_repo_url,@,@@)
+@set PROJECT.build           __PROJECT_build
diff --git a/mp4v2/doc/texi/build/commands.texi b/mp4v2/doc/texi/build/commands.texi
new file mode 100644
index 0000000..b267dc5
--- /dev/null
+++ b/mp4v2/doc/texi/build/commands.texi
@@ -0,0 +1,33 @@
+@macro COMMANDcheckout{}
+git clone @value{PROJECT.repo.url} @value{PROJECT.name.lower}
+cd @value{PROJECT.name.lower}
+@end macro
+
+@macro COMMANDbootstrap{}
+autoreconf -fiv
+@end macro
+
+@macro COMMANDextract{}
+tar xf @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.bz2
+cd @value{PROJECT.name.lower}-@value{PROJECT.version}/
+@end macro
+
+@macro COMMANDconfigure{}
+rm -fr build/
+mkdir build/
+cd build/
+../configure 
+@end macro
+
+@macro COMMANDbuild{}
+make
+@end macro
+
+@macro COMMANDinstall{}
+make install
+make install-man
+@end macro
+
+@macro COMMANDdist{}
+make dist
+@end macro
diff --git a/mp4v2/doc/texi/build/overview.texi b/mp4v2/doc/texi/build/overview.texi
new file mode 100644
index 0000000..3eed030
--- /dev/null
+++ b/mp4v2/doc/texi/build/overview.texi
@@ -0,0 +1,3 @@
+The documented and supported method to build @value{PROJECT.name} uses the GNU build system (also known as the Autotools). You must first obtain the sources by either downloading and extracting the @value{TERM.srcdist} bundle or working directly @value{PROJECT.name}'s Git repository. We have build documents for both methods, but unless you are a member of the @value{PROJECT.name} project, you are @b{strongly encouraged} to use the @value{TERM.srcdist} method.
+
+On other supported platforms which lack Autotools we provide an alternative method for building the software. Please see the appropriate platform section.
diff --git a/mp4v2/doc/texi/build/platform.common.bundled.texi b/mp4v2/doc/texi/build/platform.common.bundled.texi
new file mode 100644
index 0000000..d5c00ee
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.common.bundled.texi
@@ -0,0 +1,3 @@
+@quotation Note
+It is recommended to use the platform distribution's bundled compiler for maximum C++ compatibility. If you build with a custom compiler it will likely introduce non-standard runtime requirements for your users. There are of course many valid reasons to build with unbundled compilers, but be aware that is generally unsupported and left as an exercise to the reader.
+@end quotation
diff --git a/mp4v2/doc/texi/build/platform.common.conf.bi.texi b/mp4v2/doc/texi/build/platform.common.conf.bi.texi
new file mode 100644
index 0000000..bb5e0eb
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.common.conf.bi.texi
@@ -0,0 +1,10 @@
+@subsection Bi-arch compilation
+The preferred method to produce a bi-arch binary is to specify the target (eg. 32-bit) with the following option to configure. This example will produce a 32-bit binary if compiling on a platform which defaults to producing 64-bit binaries. The inverse is also possible.
+
+@example
+../configure --enable-bi=32
+@end example
+
+@quotation Warning
+Currently bi-arch cross-compilation is not supported due to a bug with libtool which fails miserably during linking.
+@end quotation
diff --git a/mp4v2/doc/texi/build/platform.common.conf.default.texi b/mp4v2/doc/texi/build/platform.common.conf.default.texi
new file mode 100644
index 0000000..e127c60
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.common.conf.default.texi
@@ -0,0 +1,20 @@
+@subsection Default Binaries
+The preferred method to produce default binaries is to run configure without any options which will compile with debug+optimize and produce static+shared libraries and dynamic executables. 
+
+@example
+../configure
+@end example
+
+@subsection Release Binaries
+The preferred method to produce binaries suitable for releases, (ie. which does not contain debug information) is to pass the following to configure:
+
+@example
+../configure --disable-debug
+@end example
+
+@subsection Developer Binaries
+The preferred method to produce binaries suitable for development is to pass the following to configure.  Default Binaries will work, however for the best debugging experience we recommend no optimize and no static libraries.
+
+@example
+../configure --disable-optimize --disable-static
+@end example
diff --git a/mp4v2/doc/texi/build/platform.cygwin.texi b/mp4v2/doc/texi/build/platform.cygwin.texi
new file mode 100644
index 0000000..90574c7
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.cygwin.texi
@@ -0,0 +1,20 @@
+@section @value{OS.cygwin}
+Building on @value{OS.cygwin} is supported. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Intel 32-bit or 64-bit hardware
+@item @value{OS.cygwin}, gcc 4.3.2
+@item gcc 3.4.0 or higher is reported to work
+@end itemize
+
+@quotation Note
+As of this writing, @value{OS.cygwin} has available to it several versions of gcc; only one of which may be found and used in the path as @code{gcc} and @code{g++}. Configure will thus find what is probably the older more stable version of gcc in a typical @value{OS.cygwin} environment. If you desire to build with the newer gcc, it is found in the path as @code{gcc-4} and @code{g++-4} respectively and you must indicate to configure the desired versions. Defining the following variables beforing running configure should do the trick:
+@end quotation
+
+@example
+setenv CC gcc-4
+setenv CXX gcc-4
+../configure
+@end example
+
+@include build/platform.common.conf.default.texi
diff --git a/mp4v2/doc/texi/build/platform.freebsd.texi b/mp4v2/doc/texi/build/platform.freebsd.texi
new file mode 100644
index 0000000..a707ff6
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.freebsd.texi
@@ -0,0 +1,12 @@
+@section @value{OS.freebsd}
+Building on @value{OS.freebsd} is supported. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Intel 32-bit or 64-bit hardware
+@item @value{OS.freebsd} 7.0 Release, gcc 4.2.1
+@item gcc 3.4.0 or higher is reported to work
+@end itemize
+
+@include build/platform.common.bundled.texi
+@include build/platform.common.conf.default.texi
+@include build/platform.common.conf.bi.texi
diff --git a/mp4v2/doc/texi/build/platform.linux.texi b/mp4v2/doc/texi/build/platform.linux.texi
new file mode 100644
index 0000000..ddc04df
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.linux.texi
@@ -0,0 +1,12 @@
+@section @value{OS.linux}
+Building on @value{OS.linux} is well supported as it is used by maintainers of this project. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Intel 32-bit or 64-bit hardware
+@item Fedora 10, gcc 4.3.2
+@item gcc 3.4.0 or higher is reported to work
+@end itemize
+
+@include build/platform.common.bundled.texi
+@include build/platform.common.conf.default.texi
+@include build/platform.common.conf.bi.texi
diff --git a/mp4v2/doc/texi/build/platform.osx.texi b/mp4v2/doc/texi/build/platform.osx.texi
new file mode 100644
index 0000000..ac2bc05
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.osx.texi
@@ -0,0 +1,28 @@
+@section @value{OS.osx}
+Building on @value{OS.osx} is well supported as it is used by maintainers of this project. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Mac Intel hardware
+@item Mac OS X 10.5.7
+@item Xcode-3.1.2
+@item gcc 4.0.1 (Apple Inc. build 5493)
+@item gcc 4.2.1 (Apple Inc. build 5570)
+@end itemize
+
+@include build/platform.common.bundled.texi
+
+@include build/platform.common.conf.default.texi
+
+@subsection Universal Binaries - all architectures
+The preferred method to produce universal binaries for all supported architectures is to pass the following option to configure. As of this writing, architectures @{ i386, x86_64, ppc, ppc64 @} are built.
+
+@example
+../configure --enable-ub
+@end example
+
+@subsection Universal Binaries - selected architectures
+The preferred method to produce universal binaries for selected architectures is to specify a comma-delimited list specifying the desired architecture identifiers. Passing the following option will produce universal binaries for architectures @{ i386, x86_64 @}.
+
+@example
+../configure --enable-ub=i386,x86_64
+@end example
diff --git a/mp4v2/doc/texi/build/platform.solaris.texi b/mp4v2/doc/texi/build/platform.solaris.texi
new file mode 100644
index 0000000..87e9959
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.solaris.texi
@@ -0,0 +1,16 @@
+@section @value{OS.solaris}
+Building on @value{OS.solaris} is supported. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Intel 32-bit or 64-bit hardware
+@item @value{OS.solaris} 10u6, gcc 3.4.3
+@item gcc 3.4.0 or higher is reported to work
+@end itemize
+
+@include build/platform.common.bundled.texi
+@quotation Note
+@value{OS.solaris} does not (yet) really bundle a compiler. The recommendation is to use the companion-disk compiler for maximum C++ runtime compatibility. It is usually found in @file{/usr/sfw/bin}.
+@end quotation
+
+@include build/platform.common.conf.default.texi
+@include build/platform.common.conf.bi.texi
diff --git a/mp4v2/doc/texi/build/platform.windows.texi b/mp4v2/doc/texi/build/platform.windows.texi
new file mode 100644
index 0000000..0e71346
--- /dev/null
+++ b/mp4v2/doc/texi/build/platform.windows.texi
@@ -0,0 +1,17 @@
+@section @value{OS.windows}
+Native builds on @value{OS.windows} is supported via Microsoft's Visual Studio package. Both the commercial version and free version (express) are known to work. The following are the recommended specifications for this platform; but is not necessarily the only configuration that is possible:
+
+@itemize @bullet
+@item Intel 32-bit or 64-bit hardware
+@item @value{OS.windows} 2000 or higher, Visual Studio 17.0 (aka. Visual Studio 2022)
+@end itemize
+
+Win32-API is set to @value{OS.windows} 2000 or higher. Older versions of @value{OS.windows}, or win32-API are not supported.
+
+@value{PROJECT.name} has directory @file{vstudio/} which contains the necessary solution+project files to produce a basic build of libmp4v2's DLL and several command-line executables. Enabling things such as debugging, optimization, etc, are all left as an exercise to the user.
+
+@quotation Warning
+Project meta-data is stored in header @file{project.h}. A proper source distribution is built using autotools and generates @file{TOP/include/mp4v2/project.h} correctly, which is then bundled with our source distribution. This is adequate for building on the @value{OS.windows} platform.
+
+However, if you are building from the repository, be warned that there is no method to automatically generate @file{project.h} on Windows. Instead, we periodically checkin a copy of this file (generated using autotools) as @file{vstudio/include/mp4v2/project.h} which may from time to time get out of date. If it is significantly out of date, you should find the latest source distribution and copy the @file{project.h} from there.
+@end quotation
diff --git a/mp4v2/doc/texi/build/platforms.texi b/mp4v2/doc/texi/build/platforms.texi
new file mode 100644
index 0000000..ae6f8f2
--- /dev/null
+++ b/mp4v2/doc/texi/build/platforms.texi
@@ -0,0 +1,11 @@
+@chapter Platform Notes
+@value{PROJECT.name} builds on many unix-style platforms, also commonly referred to as posix-style systems. Building on @value{OS.osx}, @value{OS.linux}, @value{OS.freebsd}, @value{OS.solaris}, @value{OS.cygwin}, @value{OS.windows} are known to work.
+
+Similar platforms should also work. Please see the following platform specific notes for instructions on commonly used options for various platforms.
+
+@include build/platform.osx.texi
+@include build/platform.linux.texi
+@include build/platform.freebsd.texi
+@include build/platform.solaris.texi
+@include build/platform.cygwin.texi
+@include build/platform.windows.texi
diff --git a/mp4v2/doc/texi/build/process.bootstrap.texi b/mp4v2/doc/texi/build/process.bootstrap.texi
new file mode 100644
index 0000000..cb538ac
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.bootstrap.texi
@@ -0,0 +1,15 @@
+@section Boostrap (Autotools)
+
+The following command causes forces Autotools to regenerate all files and install helper scripts needed at configure-time and to regenerate all files.
+
+@example
+@COMMANDbootstrap{}
+@end example
+
+If you are a project member and preparing for a release, it is important to note that the versions of Autotools available in your path will directly effect files added to the bundle. At the time of writing, the following versions of Autotools are recommended; in some cases a minimum is hard-coded and warnings will be issued if in violation:
+
+@itemize
+@item GNU autoconf 2.61 or higher (lower versions might work)
+@item GNU automake 1.10 or higher (lower versions might work)
+@item GNU libtool 1.5.26 or higher (lower versions might work)
+@end itemize
diff --git a/mp4v2/doc/texi/build/process.build.texi b/mp4v2/doc/texi/build/process.build.texi
new file mode 100644
index 0000000..cb178df
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.build.texi
@@ -0,0 +1,9 @@
+@section Build
+
+The following command will build @value{PROJECT.name}.
+
+@example
+@COMMANDbuild{}
+@end example
+
+On some platforms @code{make} refers to a BSD-flavor of make which is not compatible with this project. Check if @code{gmake} is installed, and if it is, substitute @code{gmake} wherever you may see @code{make} in this document. Otherwise you will need to install GNU make package version 3.81 or higher. Lower versions might work.
diff --git a/mp4v2/doc/texi/build/process.checkout.texi b/mp4v2/doc/texi/build/process.checkout.texi
new file mode 100644
index 0000000..7e61fe3
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.checkout.texi
@@ -0,0 +1,14 @@
+@section Checkout Sources
+
+Checkout sources from the project's Git repository.
+
+Sources are checked out from either the trunk, release or a branch. This document was generated from one of those, and for example purposes, we will use exactly the same URL which used to create the distribution which contains this document.
+
+If you are a project member, then you may add the appropriate login/password information as needed.
+
+@example
+@COMMANDcheckout{}
+@end example
+
+It is recommended to use Git 2.17.0 or higher.
+Lower versions might work.
diff --git a/mp4v2/doc/texi/build/process.configure.texi b/mp4v2/doc/texi/build/process.configure.texi
new file mode 100644
index 0000000..6750681
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.configure.texi
@@ -0,0 +1,40 @@
+@anchor{Configure}
+@section Configure
+The following command configures the project for a build.  It is highly recommended that you invoke configure from an empty directory.
+
+@example
+@COMMANDconfigure{}
+@end example
+
+Please see @file{INSTALL} for details on configure usage, and standard options. Additionally, the following custom options have been added to @file{configure}:
+
+@table @samp
+
+@item --disable-debug
+Do not generate debug information.  Do not direct compiler to generate debugging information. By default the compiler will generate debug information if the platform supports it.
+
+@item --disable-optimize
+Do not optimize. Do not direct compiler to optimize code. By default compiler optimization is enabled if the platform supports it.
+
+@item --disable-fvisibility
+Do not set default ELF symbol visibility. By default configure attempts to detect if the compiler supports this feature. However on some platforms detecting incompatibilty of this feature might not be accurate in which case this option should be given.
+
+@item --disable-gch
+By default certain platforms are marked to use GCC precompiled headers. Generally this greatly decrease build times but may require more diligence for iterative development; that is to say dependencies may not properly be tracked and more frequent @command{make clean} may be required when headers are changed. Use this option to disable GCC precompiled headers.
+
+@item --disable-largefile
+On some 32-bit platforms or configurations it might be desirable to build without largefile (LFS) support. By default configure attempts to detect formal LFS support and enables it if found.
+
+@item --disable-util
+Do not build/install utilities. This is convenience option for users who desire to skip building the utilities (eg. command-line executables) which are enabled by default.
+
+@item --enable-bi=ARCH
+On bi-arch capable platforms it is possible to generate 32 or 64 bit code. This is supported by adding arguments @samp{-m32} or @samp{-m64}, respectively, when compiling or linking. Use this option to override the platform-specific default.
+
+@item --enable-ub[=ARCHS]
+On OSX systems it is possible to generate universal binaries. This is supported by adding one or more argument patterns @samp{-arch ARCH} when compiling or linking. Use this option to either target an architecture different from the platform default, or to produce universal binaries.
+
+@item --enable-dependency-tracking
+Enable automatic dependency tracking for include-files. By default this feature is disabled.
+
+@end table
diff --git a/mp4v2/doc/texi/build/process.dist.texi b/mp4v2/doc/texi/build/process.dist.texi
new file mode 100644
index 0000000..a9d835b
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.dist.texi
@@ -0,0 +1,17 @@
+@section Create Distribution
+
+The following command will create a @value{PROJECT.name} source distribution. It is during this step that shipped documentation is generated.
+
+@example
+@COMMANDdist{}
+@end example
+
+This step in the build process introduces additional requirements to the host system. While most of the following utilities are generally available, @command{help2man} is used to generate man-pages; however if this command is not available the man-pages will be empty. This is acceptable for non-release builds but for full quality builds this command is required.
+
+@itemize
+@item GNU help2man 1.36 or higher (lower versions should work)
+@item GNU tar 1.15.1 or higher (lower versions should work)
+@item GNU gzip 1.3.10 or higher (lower versions should work)
+@item bzip2 1.0.4 or higher (lower versions should work)
+@item Info-ZIP zip 2.32 or higher (lower versions should work)
+@end itemize
diff --git a/mp4v2/doc/texi/build/process.doc.texi b/mp4v2/doc/texi/build/process.doc.texi
new file mode 100644
index 0000000..be17bc3
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.doc.texi
@@ -0,0 +1,64 @@
+@section Build Documentation
+
+This step in the build process introduces some significant requirements to the host system:
+
+@itemize
+@item GNU texinfo 4.8 or higher (lower versions should work)
+@item Doxygen 1.5.7 or higher (lower versions should work)
+@end itemize
+
+Documentation that is shipped with @value{TERM.srcdist} is generated as part of the @ref{Build Process} step. This section documents builds all of the supported methods to build documentation. There are three kinds of documentation in this project; man-pages, articles and API. @b{Documentation must be build from the repository}.
+
+Man-pages are automatically generated for command-line utilities by using @command{html2man} which invokes standard options @command{--help} and @command{--version} and gleans the information, generating a man-page in @b{nroff} script. Note that the utilities will first be built as they are depdendencies of man-page generation.
+
+Artcles are usually hand-written and authored in Texinfo format which permits macro-expansions, simple formatting and conversion to several popular formats using the GNU @command{makeinfo}. A Texinfo @url{http://www.gnu.org/software/texinfo,manual} is available.
+
+API is documented inline to C and C++ source files, usually headers using Doxygen comment-formatting. Doxygen is then used to post-process these files and generate documentation in various formats. A Doxygen manual is available at it's main @url{http://www.doxygen.org,site} .
+
+The project's goal is to document as thoroughly as possible the public API in @value{PROJECT.name}. Since we never have enough time to document everything, we try to set some priorities in this regard. Generally the public API is the highest priority to document. Next most important is probably underlying utility code which is shared by many developers; for example @b{libplatform}.
+
+If you need examples of how to document C-compatible source see @file{include/mp4v2/mp4v2.h} and for C++-only source
+see @file{libplatform/io/File.h} .
+
+The following table describes the various make targets available for building docs. Note you must first have completed the @ref{Configure} step.
+
+@table @samp
+
+@item make man
+Generate man-pages for command-line utilities.
+
+@item make html
+Generate articles in HTML format from @file{texi} files.
+
+@item make txt
+Generate articles in plaintext format from @file{texi} files.
+
+@item make wiki
+Generate articles in Google Code Wiki format from @file{texi} files.
+
+@item make xml
+Generate articles in (Texinfo) XML format from @file{texi} files.
+
+@item make api
+Generate API in HTML format from header files.
+
+@item make articles
+Convenience; the equivalent of @command{make html txt wiki xml} .
+
+@item make doc
+Convenience; the equivalent of @command{make man articles api} .
+
+@end table
+
+And finally all of the document targets have a corresponding @b{clean} target which cleans up generated files. Simply prefix as follows:
+
+@example
+make manclean
+make htmlclean
+make txtclean
+make wikiclean
+make xmlclean
+make apiclean
+make articlesclean
+make docclean
+@end example
diff --git a/mp4v2/doc/texi/build/process.extract.texi b/mp4v2/doc/texi/build/process.extract.texi
new file mode 100644
index 0000000..efad39e
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.extract.texi
@@ -0,0 +1,22 @@
+@section Extract
+Extract sources from a @value{TERM.srcdist} bundle. Releases are available from @url{@value{PROJECT.url.website}} in the @url{@value{PROJECT.url.downloads},downloads} section.
+
+@example
+@COMMANDextract{}
+@end example
+
+Older versions of @code{tar} may not automatically uncompress the bundle, so you might have to either enter additional flags manually, or first decompress the bundle before extracting. Some possible command variations for uncompressing a @file{bz2} file:
+
+@example
+tar xjf @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.bz2
+bunzip2 -c @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.bz2 | tar xf -
+bzcat @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.bz2 | tar xf -
+@end example
+
+And for a @file{gz} file:
+
+@example
+tar xzf @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.gz
+gunzip -c @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.gz | tar xf -
+gzcat @value{PROJECT.name.lower}-@value{PROJECT.version}.tar.gz | tar xf -
+@end example
diff --git a/mp4v2/doc/texi/build/process.google.texi b/mp4v2/doc/texi/build/process.google.texi
new file mode 100644
index 0000000..52b4135
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.google.texi
@@ -0,0 +1,24 @@
+@section Post Site and API Documentation to project website.
+
+This step is for project maintainers and can be used to update Site and API documentation. The following components are updated:
+
+@itemize
+@item Featured Wiki article: BuildRepository
+@item Featured Wiki article: BuildSource
+@item MP4v2 (trunk) docs (includes Release Notes and other articles, and API docs).
+@end itemize
+
+This procedure may only be run from a *nix platform and has only been tested on @value{OS.osx}.
+
+@table @samp
+
+@item make google.clean
+Clean any local working copy of google changeset.
+
+@item make google.post
+Generate required docs, sparse-checkout google tree, remove files which are no longer generated, add new files which are generated, and update existing files.
+
+@item svn ci -m "-refreshed GoogleCode site+api docs." google/.
+Check-in changes. This might take several minutes, especially if your upstream bandwidth is limited.
+
+@end table
diff --git a/mp4v2/doc/texi/build/process.install.texi b/mp4v2/doc/texi/build/process.install.texi
new file mode 100644
index 0000000..e3b27dd
--- /dev/null
+++ b/mp4v2/doc/texi/build/process.install.texi
@@ -0,0 +1,8 @@
+@anchor{Install}
+@section Install
+
+The following command will install @value{PROJECT.name}.
+
+@example
+@COMMANDinstall{}
+@end example
diff --git a/mp4v2/doc/texi/changelog/version-1.6.texi b/mp4v2/doc/texi/changelog/version-1.6.texi
new file mode 100644
index 0000000..4268820
--- /dev/null
+++ b/mp4v2/doc/texi/changelog/version-1.6.texi
@@ -0,0 +1,4 @@
+@enumerate
+@item
+Branched libmp4v2 module from mpeg4ip project version 1.6.1.
+@end enumerate
diff --git a/mp4v2/doc/texi/changelog/version-1.9.texi b/mp4v2/doc/texi/changelog/version-1.9.texi
new file mode 100644
index 0000000..8a6f8e4
--- /dev/null
+++ b/mp4v2/doc/texi/changelog/version-1.9.texi
@@ -0,0 +1,62 @@
+@enumerate
+@item
+Renamed public API top-level header to @code{<mp4v2/mp4v2.h>} and added namespaces for implementation (private) symbols. Only public API symbols are exported for dynamic (shared) or DLL libraries. All other symbols are now private, notwithstanding static-library usage.
+
+@item
+Added initial AC3 support.
+
+@item
+Added native Windows port. The port targets @code{WINVER 0x0500} which is Windows 2000 or higher.
+
+@item
+Added QuickTime and Nero chapter support. See @command{mp4chaps} command-line utility.
+@* Contributed by Ullrich Pollähne <u.pollaehne@@gmail.com>.
+
+@item
+Enhanced @command{mp4art} to support multiple cover-art atoms.
+
+@item
+Dropped @command{mp4dump} and replaced with @command{mp4file} which supports general file operations.
+
+@item
+Added @command{mp4track} with colr-box and pasp-box support.
+
+@item
+Fixed corruption of @b{udta.name} atom during read-in.
+
+@item
+Enhanced @command{mp4file --dump} to show hexdump-style canonical hex+ASCII data.
+
+@item
+Enhanced @command{mp4file --dump} to show human-readble value for tag @b{typeCode} values.
+
+@item
+Enhanced @command{mp4file --dump} to show human-readble value for ISO-639-2/T language codes.
+
+@item
+Added new public-API: MP4GetTrackLanguage().
+
+@item
+Added new public-API: MP4SetTrackLanguage().
+
+@item
+Added support for GCC precompiled-headers on various *nix platforms to speed up builds as we are using quite a few C++ headers.
+
+@item
+Enhanced @command{mp4track} to facilitate modification of @{ enabled, inmovie, inpreview, altgroup, volume, width, height, language, hdlrname, udtaname @} properties.
+
+@item
+Added new public-API: MP4GetTrackDurationPerChunk().
+
+@item
+Added new public-API: MP4SetTrackDurationPerChunk() to override default per-track chunk duration.
+
+@item
+Added new public-API: MP4WriteSampleDependency().
+
+@item
+Replaced (undocumented) public-API: MP4CreateEx() with MP4CreateProvider().
+
+@item
+Added new public-API for iTMF Generic functionality.
+@end enumerate
diff --git a/mp4v2/doc/texi/changelog/version-2.0.texi b/mp4v2/doc/texi/changelog/version-2.0.texi
new file mode 100644
index 0000000..ad57fac
--- /dev/null
+++ b/mp4v2/doc/texi/changelog/version-2.0.texi
@@ -0,0 +1,8 @@
+@enumerate
+@item
+Removed deprecated metadata/free-form API and replaced with iTMF Generic and Tags API.
+
+@item
+Added new public-API: MP4SetLogCallback().
+
+@end enumerate
diff --git a/mp4v2/doc/texi/changelog/version-2.1.texi b/mp4v2/doc/texi/changelog/version-2.1.texi
new file mode 100644
index 0000000..67095cd
--- /dev/null
+++ b/mp4v2/doc/texi/changelog/version-2.1.texi
@@ -0,0 +1,120 @@
+@enumerate
+@item
+  API changes:
+
+  @itemize @minus
+  @item
+    Added public API functions MP4ReadCallbacks, MP4CreateCallbacks[Ex] and MP4ModifyCallbacks[Ex] to allow working with custom I/O routines and memory buffers.
+
+  @item
+    Added public API function MP4FreeH264SeqPictHeaders to free memory allocated by MP4GetTrackH264SeqPictHeaders.
+  @end itemize
+
+@item
+  General improvements:
+
+  @itemize @minus
+  @item
+    I/O system:
+
+    @itemize @minus
+    @item
+      Switched to ANSI C file I/O on Windows for improved performance with large files.
+
+    @item
+      Handle extended paths (prefixed with \\?\ or \\?\UNC\) on Windows.
+    @end itemize
+
+  @item
+    MP4Modify behavior:
+
+    @itemize @minus
+    @item
+      Attempt to truncate files if when modify reduces their size instead of filling space with a free atom.
+
+    @item
+      Attempt to keep moov atom at the start of the file if it does not increase in size.
+
+    @item
+      Do not leave empty mdat atoms behind after modify.
+    @end itemize
+  @end itemize
+
+@item
+  Tools improvements:
+
+  @itemize @minus
+  @item
+    Write total length and additonal metadata to .chapters.txt files when exporting chapters with mp4chaps.
+
+  @item
+    Added options for modifying sort tags (sortartist, sortname etc.) to mp4tags.
+  @end itemize
+
+@item
+  Documentation improvements:
+
+  @itemize @minus
+  @item
+    Converted old API documentation man pages to Doxygen comments in the public header files.
+  @end itemize
+
+@item
+  Build system improvements:
+
+  @itemize @minus
+  @item
+    Updated the Autotools build system:
+
+    @itemize @minus
+    @item
+      Fixed building as a shared library on Windows.
+
+    @item
+      Added support for pkg-config.
+    @end itemize
+
+  @item
+    Added support for building with CMake.
+
+  @item
+    Upgraded Visual Studio solution and projects for Visual Studio 2022.
+
+  @item
+    Added Xcode project files.
+  @end itemize
+
+@item
+  Bug fixes:
+
+  @itemize @minus
+  @item
+    Fixed issues handling files with sample times exceeding 2^32.
+
+  @item
+    Fixed compile errors and warnings with newer versions of GCC/Clang.
+  @end itemize
+
+@item
+  Vulnerability fixes:
+
+  @itemize @minus
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14054
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14325
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14326
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14379
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14403
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-14446
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-17235
+  @item
+    https://nvd.nist.gov/vuln/detail/CVE-2018-17236
+  @end itemize
+
+@end enumerate
diff --git a/mp4v2/doc/texi/releasenotes/intro.developer.texi b/mp4v2/doc/texi/releasenotes/intro.developer.texi
new file mode 100644
index 0000000..8260e9d
--- /dev/null
+++ b/mp4v2/doc/texi/releasenotes/intro.developer.texi
@@ -0,0 +1,5 @@
+@quotation Warning
+This is a @b{developer} release which includes all the normal pieces of a stable release but is considered @b{unstable}.
+The purpose of a developer release is to make available to @value{PROJECT.name} developers features which require collaborative testing.
+@end quotation
+
diff --git a/mp4v2/doc/texi/releasenotes/intro.stable.texi b/mp4v2/doc/texi/releasenotes/intro.stable.texi
new file mode 100644
index 0000000..e69de29
diff --git a/mp4v2/doc/texi/tool/mp4art.texi b/mp4v2/doc/texi/tool/mp4art.texi
new file mode 100644
index 0000000..ac914eb
--- /dev/null
+++ b/mp4v2/doc/texi/tool/mp4art.texi
@@ -0,0 +1,57 @@
+@chapter mp4art
+This tool is used to manage iTunes Metadata Cover-art which is typically used to embed an image to a song file. For example, the songs in an album collection might all contain an image of the album cover art. This data is usually found in @samp{.m4a}, @samp{.m4v} and @samp{.mov} files.
+
+@table @samp
+@item --art-any
+act on all covr-boxes (default).
+Specifies the scope of the action to operate on all, if applicable, covr-boxes.
+
+@item --art-index IDX
+act on covr-box index IDX.
+Specifies the scope of the action to operate on single covr-box INDEX.
+@end table
+
+@table @samp
+@item --list
+list all covr-boxes.
+Example output:
+
+@example
+IDX     BYTES  CRC32     TYPE       FILE
+----------------------------------------------------------------------
+  0    173613  710a3ec9  JPEG       01 Life In Technicolor.m4a
+  0    173613  710a3ec9  JPEG       02 Cemeteries Of London.m4a
+  0    173613  710a3ec9  JPEG       03 Lost!.m4a
+  0    173613  710a3ec9  JPEG       04 42.m4a
+  0    173613  710a3ec9  JPEG       05 Lovers In Japan _ Reign Of Love.m4a
+  0    173613  710a3ec9  JPEG       06 Yes.m4a
+  0    173613  710a3ec9  JPEG       07 Viva La Vida.m4a
+  0    173613  710a3ec9  JPEG       08 Violet Hill.m4a
+  0    173613  710a3ec9  JPEG       09 Strawberry Swing.m4a
+  0    173613  710a3ec9  JPEG       10 Death And All His Friends.m4a
+@end example
+
+@item --add IMG
+add covr-box from IMG file.
+
+@item --replace IMG
+replace covr-box with IMG file.
+
+@item --remove
+remove covr-box.
+
+@item --extract
+extract covr-box.
+This will extract all covr-box data to image files in the format of @samp{BASENAME.art[INDEX].TYPE} .
+
+Example, add PNG image file:
+@example
+mp4art --add ACDC.png mysong.m4a
+@end example
+
+Example, extract image files from file:
+@example
+mp4art --extract mysong.m4a
+@end example
+
+@end table
diff --git a/mp4v2/doc/texi/tool/mp4chaps.format.texi b/mp4v2/doc/texi/tool/mp4chaps.format.texi
new file mode 100644
index 0000000..fb39362
--- /dev/null
+++ b/mp4v2/doc/texi/tool/mp4chaps.format.texi
@@ -0,0 +1,92 @@
+@appendix mp4chaps chapter file formats
+@section @emph{Native} @samp{CHPT_FMT_NATIVE} format
+A file in the @samp{CHPT_FMT_NATIVE} format contains chapter information and
+
+@itemize @minus
+@item
+  SHOULD be stored in the form of @samp{<audio-filename>.chapters.txt}, e.g. @samp{an-example.chapters.txt} for @samp{an-example.m4a}
+@item
+  MUST use the @emph{default time format} @samp{HH:MM:SS.fff} for time declarations (e.g. @samp{00:13:14.657}; to handle very long running media, the hours field can have more than two digits)
+@item
+  MUST contain at least one @emph{chapter item} (see below)
+@end itemize
+
+Lines in @samp{CHPT_FMT_NATIVE} can have three different purposes:
+
+@enumerate
+@item
+  chapter items (with start time and title)
+@item
+  metadata items (starting with @samp{## } - a special form of comments containing metadata)
+@item
+  comments (starting with @samp{#})
+@end enumerate
+
+@subsection Chapter items
+
+Chapter items MUST be specified in the following format:
+
+@example
+<start time> <title>
+@end example
+
+where
+
+@itemize @minus
+@item
+  @samp{<start time>} is the start time of a chapter specified in the @emph{default time format}
+@item
+  followed by ONE @samp{ } (space)
+@item
+  @samp{<title>} contains printable UTF-8 encoded characters without line breaks
+@end itemize
+
+@subsection Metadata items
+
+Metadata items are OPTIONAL, can be used to embed additional information and are specified in the following format:
+
+@example
+## <key>: <value>
+@end example
+
+Metadata items:
+
+@itemize @minus
+@item
+  MUST start with @samp{## }
+@item
+  @samp{<key>} SHOULD be one of the following values and MUST use the dasherized syntax (all lowercase, uses hyphens as word separators): 
+  @itemize @minus
+  @item
+    @samp{album-artist} - the album artist as string
+  @item
+    @samp{album} - the album name as string
+  @item
+    @samp{artist} - the artist as string
+  @item
+    @samp{title} - the work title as string
+  @item
+    @samp{total-duration} - the total duration of the file in the @emph{default time format}
+  @end itemize
+@item
+  followed by ONE @samp{:} (colon)
+@item
+  @samp{<value>} contains printable UTF-8 encoded characters without line breaks
+@end itemize
+
+@subsection Comments
+
+Comments are OPTIONAL, may contain any additional textual information to enrich the content and are specified in the following format:
+
+@example
+# <additional information>
+@end example
+
+Comments:
+
+@itemize @minus
+@item
+  MUST start with @samp{#}
+@item
+  SHOULD NOT start with @samp{## } to prevent being mixed up with @emph{metadata items}
+@end itemize
diff --git a/mp4v2/doc/texi/tool/mp4chaps.texi b/mp4v2/doc/texi/tool/mp4chaps.texi
new file mode 100644
index 0000000..56b6dc9
--- /dev/null
+++ b/mp4v2/doc/texi/tool/mp4chaps.texi
@@ -0,0 +1,60 @@
+@chapter mp4chaps
+This tool is used to manage mp4 chapter information, which is used to embed named seekpoints into a file, for example to identify the start of individual songs in an album or chapters in an audiobook.
+
+@table @samp
+@item --chapter-any
+act on any chapter type (default).
+Specifies the scope of the action to operate on all, if applicable, chapter types.
+
+@item --chapter-qt
+act on QuickTime chapters.
+Specifies the scope of the action to operate on QuickTime chapters.
+
+@item --chapter-nero
+act on Nero chapters.
+Specifies the scope of the action to operate on Nero chapters.
+@end table
+
+@table @samp
+@item --list
+list available chapters.
+Example output:
+
+@example
+QuickTime Chapters of "Daft Punk - Human After All.m4a"
+	Chapter #001 - 00:00:00.000 - "Human After All"
+	Chapter #002 - 00:05:19.006 - "The Prime Time of Your Life"
+	Chapter #003 - 00:09:42.379 - "Robot Rock"
+	Chapter #004 - 00:14:30.139 - "Steam Machine"
+	Chapter #005 - 00:19:50.939 - "Make Love"
+	Chapter #006 - 00:24:40.939 - "The Brainwasher"
+	Chapter #007 - 00:28:49.179 - "On/Off"
+	Chapter #008 - 00:29:08.512 - "Television Rules The Nation"
+	Chapter #009 - 00:33:56.245 - "Technologic"
+	Chapter #010 - 00:38:40.605 - "Emotion"
+@end example
+
+@item --convert
+convert available chapters.
+
+@item --every NUM
+create chapters every NUM seconds.
+
+@item --export
+export chapters to mp4file.chapters.txt.
+
+@item --format-common
+export chapters in native format (default).
+See Appendix A for a description of the different chapter file formats.
+
+@item --format-common
+export chapters in common format.
+See Appendix A for a description of the different chapter file formats.
+
+@item --import
+import chapters from mp4file.chapters.txt.
+
+@item --remove
+remove all chapters.
+
+@end table
diff --git a/mp4v2/doc/texi/tool/mp4file.texi b/mp4v2/doc/texi/tool/mp4file.texi
new file mode 100644
index 0000000..123f0e1
--- /dev/null
+++ b/mp4v2/doc/texi/tool/mp4file.texi
@@ -0,0 +1,40 @@
+@chapter mp4file
+
+@table @samp
+@item --list
+list (summary information).
+This will produce brief report when summarizing each mp4 file.
+@b{BRAND} shows the file's main brand identifier.
+@b{COMPAT} shows additional brands for which the file purports to be comaptible with.
+@b{SIZING} displays if the file has 64-bit extensions of any kind, otherwise 32-bit.
+Example output:
+@example
+BRAND  COMPAT              SIZING  FILE
+----------------------------------------------------------------------
+M4A    M4A,isom,mp42       32-bit  Song.m4a
+mp42   isom,mp42           32-bit  Movie1.m4v
+mp42   isom,mp42           32-bit  Movie2.m4v
+@end example
+
+@item --optimize
+optimize mp4 structure.
+This will rewrite the entire mp4 file which, if needed, will clean up
+any unused (free) sections, and re-order the atoms in a manner somewhat
+consistent with the best-practices described in the ISO base media file
+specification.
+
+@item --dump
+dump mp4 structure in human-readable format.
+An ASCII dump of mp4 atoms is printed to stdout. This action is heavily
+influenced by @samp{--debug} option.
+
+Example, list some files:
+@example
+mp4file --list *.mp4 *.m4a *.m4v
+@end example
+
+Example, dump a file with more than usual debugging information:
+@example
+mp4file -dd --dump movie.m4v
+@end example
+@end table
diff --git a/mp4v2/doc/texi/tool/mp4track.texi b/mp4v2/doc/texi/tool/mp4track.texi
new file mode 100644
index 0000000..8c5706e
--- /dev/null
+++ b/mp4v2/doc/texi/tool/mp4track.texi
@@ -0,0 +1,182 @@
+@chapter mp4track
+This tool is used to manage various aspects of individual tracks in an mp4 file. Some of the actions are mp4 (generic) while others may support standards based on mp4 files such as @samp{.m4a} or @samp{.m4v} files. Each action has an appropriate scope upon which it acts. See individual actions for details. The following parameters are used to set scopes for actions:
+
+@table @samp
+@item --track-any
+act on any/all tracks.
+
+@item --track-index IDX
+act on a single track specified by @b{index} value.
+A track index is 0-based and counts upwards for each track available.
+
+@item --track-id ID
+act on a single track specified by @b{id} value.
+A track id is a unique value assigned to each track and never changes.
+@end table
+
+The @b{list} action will produce a brief report of each track for each mp4 file.
+Many (but not all) of the values shown may be modified by actions documented later in this article.
+This will produce a brief report of each track for each mp4 file.
+
+@table @samp
+@item --list
+list all tracks in mp4.
+Example output:
+@example
+track[0] id=1
+  type           = video
+  enabled        = true
+  inMovie        = false
+  inPreview      = false
+  layer          = 0
+  alternateGroup = 0
+  volume         = 0.0000
+  width          = 850.96295166
+  height         = 360.00000000
+  language       = UNDEFINED(0)
+  handlerName    = 
+  userDataName   = <absent>
+@end example
+@end table
+
+The following group of actions are used to modify the values shown by @b{--list} action. The modification of these values should be done with great care on any files, and as always you are cautioned to @b{backup} your media files before modification.
+
+@table @samp
+@item --enabled BOOL
+set trak.tkhd.flags (enabled bit).
+When @b{true} indicates the track is enabled.
+
+@item --inmovie BOOL
+set trak.tkhd.flags (inMovie bit).
+When @b{true} indicates the track is used in the movie.
+
+@item --inpreview BOOL
+set trak.tkhd.flags (inPreview bit).
+When @b{true} indicates the track is used in the movie's preview.
+
+@item --layer NUM
+set trak.tkhd.layer.
+Specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer.
+@b{0} is the normal value, and @b{-1} would be in front of track 0, and so on.
+
+@item --altgroup NUM
+set trak.tkhd.alternate_group.
+An integer that specifies a group or collection of tracks. If this field is 0 there is no information on possible relations to other tracks. If this field is not 0, it should be the same for tracks that contain alternate data for one another and different for tracks belonging to different such groups. Only one track within an alternate group should be played or streamed at any one time, and must be distinguishable from other tracks in the group via attributes such as bitrate, codec, language, packet size etc. A group may have only one member.
+
+@item --volume FLOAT
+set trak.tkhd.volume.
+Specifies the track's relative audio volume. Full volume is @b{1.0} and is the normal value.
+
+@item --width FLOAT
+set trak.tkhd.width.
+Specifies the track's visual presentation width. By default this is the same as the pixel width of the images. All images in the sequence are scaled to this size @b{before} any overall transformation by the matrix.
+
+@item --height FLOAT
+set trak.tkhd.height.
+Specifies the track's visual presentation height. By default this is the same as the pixel width of the images. All images in the sequence are scaled to this size @b{before} any overall transformation by the matrix.
+
+@item --language CODE
+set trak.mdia.mdhd.language.
+Specifies the ISO-639-2/T langauge code of the track. For example, @samp{eng} for English, @samp{fra} for French.
+
+@item --hdlrname STR
+set trak.mdia.hdlr.name.
+Specifies a human-readable track type (for debugging and inspection purposes).
+
+@item --udtaname STR
+set trak.udta.name.value.
+Specifies an arbitrary track-name. This value is optional (may be absent).
+
+@item --udtaname-remove
+remove trak.udta.name atom.
+This action will remove the @b{optional} atom.
+
+@end table
+
+The @b{colr} related actions manage @b{Color Parameter} boxes which are used by QuickTime to map numerical values of pixels in a file to a common representation of color for video tracks. They may or may not be suitable for other Apple media players. Community feedback on compatibility is welcome.
+
+@table @samp
+@item --colr-list
+list all colr-boxes in mp4.
+
+@item --colr-add
+add colr-box to a video track.
+An individual track must be specified.
+
+@item --colr-set
+set colr-box parms.
+An individual track must be specified.
+
+@item --colr-remove
+remove colr-box from track.
+By default all colr-boxes will be removed unless an individual track is specified.
+
+@item --colr-parms CSV
+where CSV is IDX1,IDX2,IDX3 .
+Specify the exact parameters of an NCLC Color Parameter box as specified in the QuickTime specification.
+IDX1 correlates to the 16-bit primaries index.
+IDX2 correlates to the 16-bit transferFunction index.
+IDX3 correlates to the 16-bit matrixIndex index.
+Effects actions --colr-add, --colr-set.
+
+@item --colr-parm-hd
+equivalent to --colr-parms=1,1,1 .
+This is a convenience setting generally suitable for HD content.
+Effects actions --colr-add, --colr-set.
+
+@item --colr-parm-sd
+equivalent to --colr-parms=6,1,6 .
+This is a convenience setting generally suitable for SD content.
+Effects actions --colr-add, --colr-set.
+
+Example, add a colr-box tuned for HD content:
+@example
+mp4track --track-id=1 --colr-add --colr-parm-hd mymovie.m4v
+@end example
+
+Example, add a colr-box with arbitrary index parameters:
+@example
+mp4track --track-id=1 --colr-add --colr-parms=2,3,4 mymovie.m4v
+@end example
+
+@end table
+
+The @b{pasp} related actions manage @b{Picture Aspect Ratio} boxes which are used by QuickTime to specify height-to-width ratio of pixels for video tracks. They may or may not be suitable for other Apple media players. Community feedback on compatibility is welcome.
+
+@table @samp
+@item --pasp-list
+list all pasp-boxes in mp4.
+
+@item --pasp-add
+add pasp-box to a video track.
+An individual track must be specified.
+
+@item --pasp-set
+set pasp-box parms.
+An individual track must be specified.
+
+@item --pasp-remove
+remove pasp-box from track
+By default all pasp-boxes will be removed unless an individual track is specified.
+
+@item --pasp-parms CSV
+where CSV is hSPACING,vSPACING.
+Specify the exact parameters of Picture Aspect Ratio box as specified in the QuickTime specification.
+Effects actions --pasp-add, --pasp-set.
+
+Example, add a pasp-box with default (1,1) parameters for square pixels:
+@example
+mp4track --track-id=1 --pasp-add --pasp-parms=1,1 mymovie.m4v
+@end example
+
+Example, add a pasp-box for 16:9 digital 525 (NTSC):
+@example
+mp4track --track-id=1 --pasp-add --pasp-parms=40,33 mymovie.m4v
+@end example
+
+Example, add a pasp-box for 16:9 digital 625 (PAL):
+@example
+mp4track --track-id=1 --pasp-add --pasp-parms=118,81 mymovie.m4v
+@end example
+
+@end table
diff --git a/mp4v2/include/mp4v2/chapter.h b/mp4v2/include/mp4v2/chapter.h
index 5b493a5..1b13b3e 100644
--- a/mp4v2/include/mp4v2/chapter.h
+++ b/mp4v2/include/mp4v2/chapter.h
@@ -1,3 +1,25 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ */
 #ifndef MP4V2_CHAPTER_H
 #define MP4V2_CHAPTER_H
 
@@ -166,8 +188,8 @@ MP4ChapterType MP4GetChapters(
  */
 MP4V2_EXPORT
 MP4ChapterType MP4SetChapters(
-    MP4FileHandle hFile,
-    MP4Chapter_t* chapterList,
+    MP4FileHandle  hFile,
+    MP4Chapter_t*  chapterList,
     uint32_t       chapterCount,
     MP4ChapterType chapterType DEFAULT(MP4ChapterTypeQt));
 
diff --git a/mp4v2/include/mp4v2/file.h b/mp4v2/include/mp4v2/file.h
index b2124d2..efa430e 100644
--- a/mp4v2/include/mp4v2/file.h
+++ b/mp4v2/include/mp4v2/file.h
@@ -1,3 +1,27 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ *      Robert Kausch,             robert.kausch@freac.org
+ */
 #ifndef MP4V2_FILE_H
 #define MP4V2_FILE_H
 
@@ -12,7 +36,7 @@
 #define MP4_CREATE_64BIT_DATA 0x01
 /** Bit: enable 64-bit time-atoms. @note Incompatible with QuickTime. */
 #define MP4_CREATE_64BIT_TIME 0x02
-/** Bit: do not recompute avg/max bitrates on file close.  @note See http://code.google.com/p/mp4v2/issues/detail?id=66 */
+/** Bit: do not recompute avg/max bitrates on file close. @note See http://code.google.com/p/mp4v2/issues/detail?id=66 */
 #define MP4_CLOSE_DO_NOT_COMPUTE_BITRATE 0x01
 
 /** Enumeration of file modes for custom file provider. */
@@ -21,28 +45,50 @@ typedef enum MP4FileMode_e
     FILEMODE_UNDEFINED, /**< undefined */
     FILEMODE_READ,      /**< file may be read */
     FILEMODE_MODIFY,    /**< file may be read/written */
-    FILEMODE_CREATE    /**< file will be created/truncated for read/write */
+    FILEMODE_CREATE     /**< file will be created/truncated for read/write */
 } MP4FileMode;
 
 /** Structure of functions implementing custom file provider.
  *
- *  Except for <b>open</b>, all the functions must return a true value
- *  to indicate failure or false on success. The open function must return
+ *  @deprecated The file provider API is deprecated since MP4v2 2.1.0. Please
+ *      use MP4IOCallbacks instead.
+ *
+ *  Except for <b>open</b>, all the functions must return 0 upon success
+ *  or a non-zero value to indicate failure. The open function must return
  *  a pointer or handle which represents the open file, otherwise NULL.
  *
- *  maxChunkSize is a hint suggesting what the max size of data should be read
- *  as in underlying read/write operations. A value of 0 indicates there is no hint.
+ *  The reserved argument is currently always 0 and should be ignored.
+ *
+ *  @see MP4IOCallbacks
  */
 typedef struct MP4FileProvider_s
 {
-    void* ( *open    )( const char* name, MP4FileMode mode );
-    int   ( *seek    )( void* handle, int64_t pos );
-    int   ( *read    )( void* handle, void* buffer, int64_t size, int64_t* nin, int64_t maxChunkSize );
-    int   ( *write   )( void* handle, const void* buffer, int64_t size, int64_t* nout, int64_t maxChunkSize );
-    int   ( *close   )( void* handle );
-    int   ( *getSize )( void* handle, int64_t* nout );
+    void* ( *open  )( const char* name, MP4FileMode mode );
+    int   ( *seek  )( void* handle, int64_t pos );
+    int   ( *read  )( void* handle, void* buffer, int64_t size, int64_t* nin, int64_t reserved );
+    int   ( *write )( void* handle, const void* buffer, int64_t size, int64_t* nout, int64_t reserved );
+    int   ( *close )( void* handle );
 } MP4FileProvider;
 
+/** Structure of functions implementing custom I/O callbacks.
+ *
+ *  Except for <b>size</b>, all the functions must return 0 upon success
+ *  or a non-zero value to indicate failure. The size function must return
+ *  the size of the file/buffer or -1 in case of failure.
+ *
+ *  @see MP4CreateCallbacks()
+ *  @see MP4ModifyCallbacks()
+ *  @see MP4ReadCallbacks()
+ */
+typedef struct MP4IOCallbacks_s
+{
+    int64_t ( *size     )( void* handle );
+    int     ( *seek     )( void* handle, int64_t pos );
+    int     ( *read     )( void* handle, void* buffer, int64_t size, int64_t* nin );
+    int     ( *write    )( void* handle, const void* buffer, int64_t size, int64_t* nout );
+    int     ( *truncate )( void* handle, int64_t size );
+} MP4IOCallbacks;
+
 /** Close an mp4 file.
  *  MP4Close closes a previously opened mp4 file. If the file was opened
  *  writable with MP4Create() or MP4Modify(), then MP4Close() will write
@@ -50,21 +96,21 @@ typedef struct MP4FileProvider_s
  *
  *  @param hFile handle of file to close.
  *  @param flags bitmask that allows the user to set extra options for the
- *       close commands.  Valid options include:
+ *       close commands. Valid options include:
  *          @li #MP4_CLOSE_DO_NOT_COMPUTE_BITRATE
  */
 MP4V2_EXPORT
 void MP4Close(
     MP4FileHandle hFile,
-    uint32_t    flags DEFAULT(0) );
+    uint32_t      flags DEFAULT(0) );
 
 /** Create a new mp4 file.
  *
- *  MP4Create is the first call that should be used when you want to create
- *  a new, empty mp4 file. It is equivalent to opening a file for writing,
- *  but also involved with creation of necessary mp4 framework structures.
- *  ie. invoking MP4Create() followed by MP4Close() will result in a file
- *  with a non-zero size.
+ *  MP4Create is the first call that should be used when you want to create a
+ *  new, empty mp4 file. It is equivalent to opening a file for writing, but is
+ *  also involved with the creation of necessary mp4 framework structures. I.e.
+ *  invoking MP4Create() followed by MP4Close() will result in a file with a
+ *  non-zero size.
  *
  *  @param fileName pathname of the file to be created.
  *      On Windows, this should be a UTF-8 encoded string.
@@ -76,9 +122,10 @@ void MP4Close(
  *          @li #MP4_CREATE_64BIT_DATA
  *          @li #MP4_CREATE_64BIT_TIME
  *
- *  @return On success a handle of the newly created file for use in
- *      subsequent calls to the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *  @return On success a handle of the newly created file for use in subsequent
+ *      calls to the library. On error, #MP4_INVALID_FILE_HANDLE.
+ *
+ *  @see MP4CreateEx()
  */
 MP4V2_EXPORT
 MP4FileHandle MP4Create(
@@ -107,9 +154,10 @@ MP4FileHandle MP4Create(
  *  @param compatibleBrandsCount is the count of items specified in
  *      compatibleBrands.
  *
- *  @return On success a handle of the newly created file for use in
- *      subsequent calls to the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *  @return On success a handle of the newly created file for use in subsequent
+ *      calls to the library. On error, #MP4_INVALID_FILE_HANDLE.
+ *
+ *  @see MP4Create()
  */
 MP4V2_EXPORT
 MP4FileHandle MP4CreateEx(
@@ -122,53 +170,56 @@ MP4FileHandle MP4CreateEx(
     char**      compatibleBrands DEFAULT(0),
     uint32_t    compatibleBrandsCount DEFAULT(0) );
 
-/** Create a new mp4 file.
- *
- *  MP4CreateProvider is the first call that should be used when you want to
- *  create a new, empty mp4 file. It is equivalent to opening a file for
- *  writing, but also involved with creation of necessary mp4 framework
- *  structures. ie. invoking MP4CreateProvider() followed by MP4Close() will
- *  result in a file with a non-zero size.
- *
- *  @param fileName pathname of the file to be created.
- *      On Windows, this should be a UTF-8 encoded string.
- *      On other platforms, it should be an 8-bit encoding that is
- *      appropriate for the platform, locale, file system, etc.
- *      (prefer to use UTF-8 when possible).
+/** Create a new mp4 file using an I/O callbacks structure.
+ *
+ *  MP4CreateCallbacks is the first call that should be used when you want to
+ *  create a new, empty mp4 file using custom I/O functions provided in an
+ *  MP4IOCallbacks structure.
+ *
+ *  Using MP4CreateCallbacks is equivalent to opening a file for writing, but
+ *  is also involved with the creation of necessary mp4 framework structures.
+ *  I.e. invoking MP4CreateCallbacks() followed by MP4Close() will result in a
+ *  file with a non-zero size.
+ *
+ *  @param callbacks custom implementation of I/O operations.
+ *      The size, seek and write callbacks must be implemented.
+ *      The callbacks structure is immediately copied internally.
+ *  @param handle a custom handle that will be passed as the first argument to
+ *      any callback function call. This can be used to pass a handle to an
+ *      application specific I/O object or an application defined struct
+ *      containing a pointer to a buffer.
  *  @param flags bitmask that allows the user to set 64-bit values for
  *      data or time atoms. Valid bits may be any combination of:
  *          @li #MP4_CREATE_64BIT_DATA
  *          @li #MP4_CREATE_64BIT_TIME
- *  @param fileProvider custom implementation of file I/O operations.
- *      All functions in structure must be implemented.
- *      The structure is immediately copied internally.
  *
- *  @return On success a handle of the newly created file for use in
- *      subsequent calls to the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *  @return On success a handle of the newly created file for use in subsequent
+ *      calls to the library. On error, #MP4_INVALID_FILE_HANDLE.
+ *
+ *  @see MP4CreateCallbacksEx()
  */
 MP4V2_EXPORT
-MP4FileHandle MP4CreateProvider(
-    const char*            fileName,
-    uint32_t               flags DEFAULT(0),
-    const MP4FileProvider* fileProvider DEFAULT(NULL) );
+MP4FileHandle MP4CreateCallbacks(
+    const MP4IOCallbacks* callbacks,
+    void*                 handle DEFAULT(NULL),
+    uint32_t              flags DEFAULT(0));
 
-/** Create a new mp4 file with extended options.
- *
- *  MP4CreateProviderEx is an extended version of MP4CreateProvider().
- *
- *  @param fileName pathname of the file to be created.
- *      On Windows, this should be a UTF-8 encoded string.
- *      On other platforms, it should be an 8-bit encoding that is
- *      appropriate for the platform, locale, file system, etc.
- *      (prefer to use UTF-8 when possible).
+/** Create a new mp4 file with extended options using an I/O callbacks
+ *  structure.
+ *
+ *  MP4CreateCallbacksEx is an extended version of MP4CreateCallbacks().
+ *
+ *  @param callbacks custom implementation of I/O operations.
+ *      The size, seek and write callbacks must be implemented.
+ *      The callbacks structure is immediately copied internally.
+ *  @param handle a custom handle that will be passed as the first argument to
+ *      any callback function call. This can be used to pass a handle to an
+ *      application specific I/O object or an application defined struct
+ *      containing a pointer to a buffer.
  *  @param flags bitmask that allows the user to set 64-bit values for
  *      data or time atoms. Valid bits may be any combination of:
  *          @li #MP4_CREATE_64BIT_DATA
  *          @li #MP4_CREATE_64BIT_TIME
- *  @param fileProvider custom implementation of file I/O operations.
- *      All functions in structure must be implemented.
- *      The structure is immediately copied internally.
  *  @param add_ftyp if true an <b>ftyp</b> atom is automatically created.
  *  @param add_iods if true an <b>iods</b> atom is automatically created.
  *  @param majorBrand <b>ftyp</b> brand identifier.
@@ -178,40 +229,39 @@ MP4FileHandle MP4CreateProvider(
  *  @param compatibleBrandsCount is the count of items specified in
  *      compatibleBrands.
  *
- *  @return On success a handle of the newly created file for use in
- *      subsequent calls to the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *  @return On success a handle of the newly created file for use in subsequent
+ *      calls to the library. On error, #MP4_INVALID_FILE_HANDLE.
+ *
+ *  @see MP4CreateCallbacks()
  */
 MP4V2_EXPORT
-MP4FileHandle MP4CreateProviderEx(
-    const char*            fileName,
-    uint32_t               flags DEFAULT(0),
-    const MP4FileProvider* fileProvider DEFAULT(NULL),
-    int                    add_ftyp DEFAULT(1),
-    int                    add_iods DEFAULT(1),
-    char*                  majorBrand DEFAULT(0),
-    uint32_t               minorVersion DEFAULT(0),
-    char**                 compatibleBrands DEFAULT(0),
-    uint32_t               compatibleBrandsCount DEFAULT(0) );
+MP4FileHandle MP4CreateCallbacksEx(
+    const MP4IOCallbacks* callbacks,
+    void*                 handle DEFAULT(NULL),
+    uint32_t              flags DEFAULT(0),
+    int                   add_ftyp DEFAULT(1),
+    int                   add_iods DEFAULT(1),
+    char*                 majorBrand DEFAULT(0),
+    uint32_t              minorVersion DEFAULT(0),
+    char**                compatibleBrands DEFAULT(0),
+    uint32_t              compatibleBrandsCount DEFAULT(0) );
 
 /** Dump mp4 file contents as ASCII either to stdout or the
- *  log callback (@p see MP4SetLogCallback)
+ *  log callback (see MP4SetLogCallback())
  *
  *  Dump is an invaluable debugging tool in that in can reveal all the details
  *  of the mp4 control structures. However, the output will not make much sense
  *  until you familiarize yourself with the mp4 specification (or the Quicktime
  *  File Format specification).
  *
-
  *  Note that MP4Dump() will not print the individual values of control tables,
  *  such as the size of each sample, unless the current log level is at least
- *  #MP4_LOG_VERBOSE2.  @p see MP4LogSetLevel() for how to set this.
+ *  @b MP4_LOG_VERBOSE2. See MP4LogSetLevel() for how to set this.
  *
  *  @param hFile handle of file to dump.
- *  @param dumpImplicits prints properties which would not actually be
- *      written to the mp4 file, but still exist in mp4 control structures.
- *      ie. they are implicit given the current values of other controlling
- *      properties.
+ *  @param dumpImplicits prints properties which would not actually be written
+ *      to the mp4 file, but still exist in mp4 control structures. I.e. they
+ *      are implicit given the current values of other controlling properties.
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
@@ -223,24 +273,25 @@ bool MP4Dump(
 /** Return a textual summary of an mp4 file.
  *
  *  MP4FileInfo provides a string that contains a textual summary of the
- *  contents of an mp4 file. This includes the track id's, the track type,
- *  and track specific information. For example, for a video track, media
- *  encoding, image size, frame rate, and bitrate are summarized.
+ *  contents of an mp4 file. This includes the track id's, the track type, and
+ *  track specific information. For example, for a video track, media encoding,
+ *  image size, frame rate, and bitrate are summarized.
  *
- *  Note that the returned string is malloc'ed, so it is the caller's
- *  responsibility to free() the string. Also note that the returned string
- *  contains newlines and tabs which may or may not be desirable. 
+ *  Note that the returned string is allocated by the library, so it is the
+ *  caller's responsibility to release the string with MP4Free(). Also note
+ *  that the returned string contains newlines and tabs which may or may not be
+ *  desirable. 
  *
  *  The following is an example of the output of MP4Info():
-@verbatim
-Track  Type   Info
-1      video  MPEG-4 Simple @ L3, 119.625 secs, 1008 kbps, 352x288 @ 24.00 fps
-2      audio  MPEG-4, 119.327 secs, 128 kbps, 44100 Hz
-3      hint   Payload MP4V-ES for track 1
-4      hint   Payload mpeg4-generic for track 2
-5      od     Object Descriptors
-6      scene  BIFS
-@endverbatim
+ *  @verbatim
+    Track  Type   Info
+    1      video  MPEG-4 Simple @ L3, 119.625 secs, 1008 kbps, 352x288 @ 24.00 fps
+    2      audio  MPEG-4, 119.327 secs, 128 kbps, 44100 Hz
+    3      hint   Payload MP4V-ES for track 1
+    4      hint   Payload mpeg4-generic for track 2
+    5      od     Object Descriptors
+    6      scene  BIFS
+    @endverbatim
  *
  *  @param fileName pathname to mp4 file to summarize.
  *      On Windows, this should be a UTF-8 encoded string.
@@ -251,10 +302,10 @@ Track  Type   Info
  *      #MP4_INVALID_TRACK_ID, the summary info is created for all
  *      tracks in the file.
  *
- *  @return On success a malloc'd string containing summary information.
+ *  @return On success a newly allocated string containing summary information.
  *      On failure, <b>NULL</b>.
  *
- *  @see MP4Info().
+ *  @see MP4Info()
  */
 MP4V2_EXPORT
 char* MP4FileInfo(
@@ -263,10 +314,10 @@ char* MP4FileInfo(
 
 /** Accessor for the filename associated with a file handle
  *
- * @param hFile a file handle
+ *  @param hFile a file handle
  *
- * @return the NUL-terminated, UTF-8 encoded filename
- * associated with @p hFile
+ *  @return the NUL-terminated, UTF-8 encoded filename associated with @p
+ *      hFile.
  */
 MP4V2_EXPORT
 const char* MP4GetFilename(
@@ -275,34 +326,35 @@ const char* MP4GetFilename(
 /** Return a textual summary of an mp4 file.
  *
  *  MP4FileInfo provides a string that contains a textual summary of the
- *  contents of an mp4 file. This includes the track id's, the track type,
- *  and track specific information. For example, for a video track, media
- *  encoding, image size, frame rate, and bitrate are summarized.
+ *  contents of an mp4 file. This includes the track id's, the track type, and
+ *  track specific information. For example, for a video track, media encoding,
+ *  image size, frame rate, and bitrate are summarized.
  *
- *  Note that the returned string is malloc'ed, so it is the caller's
- *  responsibility to free() the string. Also note that the returned string
- *  contains newlines and tabs which may or may not be desirable. 
+ *  Note that the returned string is allocated by the library, so it is the
+ *  caller's responsibility to release the string with MP4Free(). Also note
+ *  that the returned string contains newlines and tabs which may or may not be
+ *  desirable. 
  *
  *  The following is an example of the output of MP4Info():
-@verbatim
-Track  Type   Info
-1      video  MPEG-4 Simple @ L3, 119.625 secs, 1008 kbps, 352x288 @ 24.00 fps
-2      audio  MPEG-4, 119.327 secs, 128 kbps, 44100 Hz
-3      hint   Payload MP4V-ES for track 1
-4      hint   Payload mpeg4-generic for track 2
-5      od     Object Descriptors
-6      scene  BIFS
-@endverbatim
+ *  @verbatim
+    Track  Type   Info
+    1      video  MPEG-4 Simple @ L3, 119.625 secs, 1008 kbps, 352x288 @ 24.00 fps
+    2      audio  MPEG-4, 119.327 secs, 128 kbps, 44100 Hz
+    3      hint   Payload MP4V-ES for track 1
+    4      hint   Payload mpeg4-generic for track 2
+    5      od     Object Descriptors
+    6      scene  BIFS
+    @endverbatim
  *
  *  @param hFile handle of file to summarize.
  *  @param trackId specifies track to summarize. If the value is
- *      #MP4_INVALID_TRACK_ID, the summary info is created for all
- *      tracks in the file.
+ *      #MP4_INVALID_TRACK_ID, the summary info is created for all tracks in
+ *      the file.
  *
- *  @return On success a malloc'd string containing summary information.
+ *  @return On success a newly allocated string containing summary information.
  *      On failure, <b>NULL</b>.
  *
- *  @see MP4FileInfo().
+ *  @see MP4FileInfo()
  */
 MP4V2_EXPORT
 char* MP4Info(
@@ -316,7 +368,7 @@ char* MP4Info(
  *  read/write mode.
  *
  *  Since modifications to an existing mp4 file can result in a sub-optimal
- *  file layout, you may want to use MP4Optimize() after you have  modified
+ *  file layout, you may want to use MP4Optimize() after you have modified
  *  and closed the mp4 file.
  *
  *  @param fileName pathname of the file to be modified.
@@ -327,14 +379,46 @@ char* MP4Info(
  *  @param flags currently ignored.
  *
  *  @return On success a handle of the target file for use in subsequent calls
- *      to the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *      to the library. On error, #MP4_INVALID_FILE_HANDLE.
  */
 MP4V2_EXPORT
 MP4FileHandle MP4Modify(
     const char* fileName,
     uint32_t    flags DEFAULT(0) );
 
+/** Modify an existing mp4 file using an I/O callbacks structure.
+ *
+ *  MP4ModifyCallbacks is the first call that should be used when you want to
+ *  modify an existing mp4 file using custom I/O functions provided in an
+ *  MP4IOCallbacks structure.
+
+ *  Using MP4ModifyCallbacks is roughly equivalent to opening a file in
+ *  read/write mode.
+ *
+ *  Since modifications to an existing mp4 file can result in a sub-optimal
+ *  file layout, you may want to use MP4Optimize() after you have modified and
+ *  closed the mp4 file.
+ *
+ *  @param callbacks custom implementation of I/O operations. The size, seek,
+ *      read and write callbacks must be implemented. Implementing the truncate
+ *      callback is optional, but strongly recommended. If the truncate
+ *      callback is not implemented, it must be set to NULL. The callbacks
+ *      structure is immediately copied internally.
+ *  @param handle a custom handle that will be passed as the first argument to
+ *      any callback function call. This can be used to pass a handle to an
+ *      application specific I/O object or an application defined struct
+ *      containing a pointer to a buffer.
+ *  @param flags currently ignored.
+ *
+ *  @return On success a handle of the target file for use in subsequent calls
+ *      to the library. On error, #MP4_INVALID_FILE_HANDLE.
+ */
+MP4V2_EXPORT
+MP4FileHandle MP4ModifyCallbacks(
+    const MP4IOCallbacks* callbacks,
+    void*                 handle DEFAULT(NULL),
+    uint32_t              flags DEFAULT(0) );
+
 /** Optimize the layout of an mp4 file.
  *
  *  MP4Optimize reads an existing mp4 file and writes a new version of the
@@ -381,7 +465,6 @@ bool MP4Optimize(
     const char* fileName,
     const char* newFileName DEFAULT(NULL) );
 
-
 /** Read an existing mp4 file.
  *
  *  MP4Read is the first call that should be used when you want to just
@@ -395,22 +478,24 @@ bool MP4Optimize(
  *      On other platforms, it should be an 8-bit encoding that is
  *      appropriate for the platform, locale, file system, etc.
  *      (prefer to use UTF-8 when possible).
-(
+ *
  *  @return On success a handle of the file for use in subsequent calls to
- *      the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *      the library. On error, #MP4_INVALID_FILE_HANDLE.
  */
 MP4V2_EXPORT
 MP4FileHandle MP4Read(
     const char* fileName );
 
 /** Read an existing mp4 file.
+ *
+ *  @deprecated The file provider API is deprecated since MP4v2 2.1.0. Please
+ *      use MP4ReadCallbacks() instead.
  *
  *  MP4ReadProvider is the first call that should be used when you want to just
- *  read an existing mp4 file. It is equivalent to opening a file for
- *  reading, but in addition the mp4 file is parsed and the control
- *  information is loaded into memory. Note that actual track samples are not
- *  read into memory until MP4ReadSample() is called.
+ *  read an existing mp4 file. It is equivalent to opening a file for reading,
+ *  but in addition the mp4 file is parsed and the control information is
+ *  loaded into memory. Note that actual track samples are not read into memory
+ *  until MP4ReadSample() is called.
  *
  *  @param fileName pathname of the file to be read.
  *      On Windows, this should be a UTF-8 encoded string.
@@ -422,14 +507,42 @@ MP4FileHandle MP4Read(
  *      The structure is immediately copied internally.
  *
  *  @return On success a handle of the file for use in subsequent calls to
- *      the library.
- *      On error, #MP4_INVALID_FILE_HANDLE.
+ *      the library. On error, #MP4_INVALID_FILE_HANDLE.
+ *
+ * @see MP4ReadCallbacks()
  */
 MP4V2_EXPORT
 MP4FileHandle MP4ReadProvider(
     const char*            fileName,
     const MP4FileProvider* fileProvider DEFAULT(NULL) );
 
+/** Read an existing mp4 file using an I/O callbacks structure.
+ *
+ *  MP4ReadCallbacks is the first call that should be used when you want to
+ *  read an existing mp4 file using custom I/O functions provided in an
+ *  MP4IOCallbacks structure.
+ *
+ *  Using MP4ReadCallbacks is equivalent to opening a file for reading, but in
+ *  addition the mp4 file is parsed and the control information is loaded into
+ *  memory. Note that actual track samples are not read into memory until
+ *  MP4ReadSample() is called.
+ *
+ *  @param callbacks custom implementation of I/O operations.
+ *      The size, seek and read callbacks must be implemented.
+ *      The callbacks structure is immediately copied internally.
+ *  @param handle a custom handle that will be passed as the first argument to
+ *      any callback function call. This can be used to pass a handle to an
+ *      application specific I/O object or an application defined struct
+ *      containing a pointer to a buffer.
+ *
+ *  @return On success a handle of the file for use in subsequent calls to
+ *      the library. On error, #MP4_INVALID_FILE_HANDLE.
+ */
+MP4V2_EXPORT
+MP4FileHandle MP4ReadCallbacks(
+    const MP4IOCallbacks* callbacks,
+    void*                 handle DEFAULT(NULL) );
+
 /** @} ***********************************************************************/
 
 #endif /* MP4V2_FILE_H */
diff --git a/mp4v2/include/mp4v2/file_prop.h b/mp4v2/include/mp4v2/file_prop.h
index 15435e8..170d54a 100644
--- a/mp4v2/include/mp4v2/file_prop.h
+++ b/mp4v2/include/mp4v2/file_prop.h
@@ -1,38 +1,126 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ *      Robert Kausch,             robert.kausch@freac.org
+ */
 #ifndef MP4V2_FILE_PROP_H
 #define MP4V2_FILE_PROP_H
 
 /**************************************************************************//**
  *
- *  @defgroup mp4_file_prop MP4v2 File Property
+ *  @defgroup mp4_file_prop MP4v2 File Properties
  *  @{
  *
  *****************************************************************************/
 
 /* generic props */
 
+/** Check for presence of an atom.
+ *
+ *  MP4HaveAtom checks for the presence of the atom passed in @p atomName. @p
+ *  atomName can specify an atom path to check for atoms that are not top level
+ *  atoms, e.g. "moov.udta.meta.ilst".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param atomName name of the atom to check for.
+ *
+ *  @return true (1) if the atom is present, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4HaveAtom(
     MP4FileHandle hFile,
     const char*   atomName );
 
+/** Get the value of an integer property.
+ *
+ *  MP4GetIntegerProperty determines the value of the integer property
+ *  identified by @p propName, e.g. "moov.iods.audioProfileLevelId". The value
+ *  is stored in the variable pointed to by @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetIntegerProperty(
     MP4FileHandle hFile,
     const char*   propName,
-    uint64_t*     retval );
+    uint64_t*     retVal );
 
+/** Get the value of a float property.
+ *
+ *  MP4GetFloatProperty determines the value of the float property identified
+ *  by @p propName, e.g. "moov.mvhd.rate". The value is stored in the variable
+ *  pointed to by @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetFloatProperty(
     MP4FileHandle hFile,
     const char*   propName,
-    float*        retvalue );
+    float*        retVal );
 
+/** Get the value of a string property.
+ *
+ *  MP4GetStringProperty determines the value of the string property identified
+ *  by @p propName, e.g. "ftyp.majorBrand". The value is stored in the variable
+ *  pointed to by @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetStringProperty(
     MP4FileHandle hFile,
     const char*   propName,
-    const char**  retvalue );
+    const char**  retVal );
 
+/** Get the value of a bytes property.
+ *
+ *  MP4GetBytesProperty determines the value of the bytes property identified
+ *  by @p propName, e.g. "moov.udta.meta.metadata". The value is stored in a
+ *  newly allocated buffer the location of which is assigned to the variable
+ *  pointed to by ppValue. The caller is responsible for freeing the memory
+ *  with MP4Free().
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to get.
+ *  @param ppValue pointer to a variable to receive the memory location
+ *      containing the property bytes.
+ *  @param pValueSize pointer to a variable to receive the length of the
+ *      property bytes value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetBytesProperty(
     MP4FileHandle hFile,
@@ -40,24 +128,69 @@ bool MP4GetBytesProperty(
     uint8_t**     ppValue,
     uint32_t*     pValueSize );
 
+/** Set the value of an integer property.
+ *
+ *  MP4SetIntegerProperty sets the value of the integer property identified by
+ *  @p propName, e.g. "moov.iods.audioProfileLevelId".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetIntegerProperty(
     MP4FileHandle hFile,
     const char*   propName,
     int64_t       value );
 
+/** Set the value of a float property.
+ *
+ *  MP4SetFloatProperty sets the value of the float property identified by @p
+ *  propName, e.g. "moov.mvhd.rate".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetFloatProperty(
     MP4FileHandle hFile,
     const char*   propName,
     float         value );
 
+/** Set the value of a string property.
+ *
+ *  MP4SetStringProperty sets the value of the string property identified by @p
+ *  propName, e.g. "ftyp.majorBrand".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetStringProperty(
     MP4FileHandle hFile,
     const char*   propName,
     const char*   value );
 
+/** Set the value of a bytes property.
+ *
+ *  MP4SetBytesProperty sets the value of the bytes property identified by @p
+ *  propName, e.g. "moov.udta.meta.metadata".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param propName path to the property to set.
+ *  @param pValue pointer the bytes representing the new value of the property.
+ *  @param valueSize the size of the bytes value pointed to by <b>pValue</b>.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetBytesProperty(
     MP4FileHandle  hFile,
@@ -67,8 +200,23 @@ bool MP4SetBytesProperty(
 
 /* specific props */
 
+/** Get the duration of the movie (file).
+ *
+ *  MP4GetDuration returns the maximum duration of all the tracks in the
+ *  specified mp4 file. 
+ *
+ *  Caveat: the duration is the movie (file) time scale units.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The duration of the movie (file) in movie (file) time scale units.
+ *
+ *  @see MP4GetTimeScale()
+ *  @see MP4ConvertFromMovieDuration()
+ */
 MP4V2_EXPORT
-MP4Duration MP4GetDuration( MP4FileHandle hFile );
+MP4Duration MP4GetDuration(
+    MP4FileHandle hFile );
 
 /** Get the time scale of the movie (file).
  *
@@ -81,7 +229,8 @@ MP4Duration MP4GetDuration( MP4FileHandle hFile );
  *  @return timescale (ticks per second) of the mp4 file.
  */
 MP4V2_EXPORT
-uint32_t MP4GetTimeScale( MP4FileHandle hFile );
+uint32_t MP4GetTimeScale(
+    MP4FileHandle hFile );
 
 /** Set the time scale of the movie (file).
  *
@@ -95,7 +244,9 @@ uint32_t MP4GetTimeScale( MP4FileHandle hFile );
  *  @return On success, true. On failure, false.
  */
 MP4V2_EXPORT
-bool MP4SetTimeScale( MP4FileHandle hFile, uint32_t value );
+bool MP4SetTimeScale(
+    MP4FileHandle hFile,
+    uint32_t      value );
 
 /** Change the general timescale of file hFile.
  *
@@ -109,39 +260,272 @@ bool MP4SetTimeScale( MP4FileHandle hFile, uint32_t value );
  *  @param value the new timescale.
  */
 MP4V2_EXPORT
-void MP4ChangeMovieTimeScale( MP4FileHandle hFile, uint32_t value );
+void MP4ChangeMovieTimeScale(
+    MP4FileHandle hFile,
+    uint32_t      value );
 
+/** Gets the minimum MPEG-4 object descriptor profile and level required to
+ *  render the contents of the file.
+ *
+ *  MP4GetODProfileLevel returns the minimum profile/level of MPEG-4 object
+ *  descriptor support necessary to render the contents of the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The current object descriptor profile/level for the file. See
+ *      MP4SetODProfileLevel() for known values.
+ *
+ *  @see MP4SetODProfileLevel()
+ */
 MP4V2_EXPORT
-uint8_t MP4GetODProfileLevel( MP4FileHandle hFile );
+uint8_t MP4GetODProfileLevel(
+    MP4FileHandle hFile );
 
+/** Sets the minimum MPEG-4 object descriptor profile and level required to
+ *  render the contents of the file.
+ *
+ *  MP4SetODProfileLevel sets the minimum profile/level of MPEG-4 object
+ *  descriptor support necessary to render the contents of the file.
+ * 
+ *  ISO/IEC 14496-1:2001 MPEG-4 Systems defines the following values:
+ *
+ *  Value     | Meaning
+ *  ----------|-----------------------------
+ *  0x00      | Reserved
+ *  0x01-0x7F | Reserved
+ *  0x80-0xFD | User private
+ *  0xFE      | No object descriptor profile specified
+ *  0xFF      | No object descriptor required
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param value specifies the profile/level to set.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetODProfileLevel()
+ */
 MP4V2_EXPORT
-bool MP4SetODProfileLevel( MP4FileHandle hFile, uint8_t value );
+bool MP4SetODProfileLevel(
+    MP4FileHandle hFile,
+    uint8_t       value );
 
+/** Gets the minimum MPEG-4 scene graph profile and level required to render
+ *  the contents of the file.
+ *
+ *  MP4GetSceneProfileLevel returns the minimum profile/level of MPEG-4 scene
+ *  graph support necessary to render the contents of the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The current scene graph profile/level for the file. See
+ *      MP4SetSceneProfileLevel() for known values.
+ *
+ *  @see MP4SetSceneProfileLevel()
+ */
 MP4V2_EXPORT
-uint8_t MP4GetSceneProfileLevel( MP4FileHandle hFile );
+uint8_t MP4GetSceneProfileLevel(
+    MP4FileHandle hFile );
 
+/** Sets the minimum MPEG-4 scene graph profile and level required to render
+ *  the contents of the file.
+ *
+ *  MP4SetSceneProfileLevel sets the minimum profile/level of MPEG-4 scene
+ *  graph support necessary to render the contents of the file.
+ * 
+ *  ISO/IEC 14496-1:2001 MPEG-4 Systems defines the following values:
+ *
+ *  Value     | Meaning
+ *  ----------|-----------------------------
+ *  0x00      | Reserved
+ *  0x01      | Simple 2D Profile @@ Level 1
+ *  0x02-0x7F | Reserved
+ *  0x80-0xFD | User private
+ *  0xFE      | No scene graph profile specified
+ *  0xFF      | No scene graph required
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param value specifies the profile/level to set.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetSceneProfileLevel()
+ */
 MP4V2_EXPORT
-bool MP4SetSceneProfileLevel( MP4FileHandle hFile, uint8_t value );
+bool MP4SetSceneProfileLevel(
+    MP4FileHandle hFile,
+    uint8_t       value );
 
+/** Gets the minimum MPEG-4 video profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4GetVideoProfileLevel returns the minimum profile/level of MPEG-4 video
+ *  support necessary to render the contents of the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the profile/level is
+ *      requested.
+ *
+ *  @return The current video profile/level for the file/track. See
+ *      MP4SetVideoProfileLevel() for known values.
+ *
+ *  @see MP4SetVideoProfileLevel()
+ */
 MP4V2_EXPORT
 uint8_t MP4GetVideoProfileLevel(
     MP4FileHandle hFile,
     MP4TrackId    trackId DEFAULT(MP4_INVALID_TRACK_ID) );
 
+/** Sets the minimum MPEG-4 video profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4SetVideoProfileLevel sets the minimum profile/level of MPEG-4 video
+ *  support necessary to render the contents of the file.
+ * 
+ *  ISO/IEC 14496-1:2001 MPEG-4 Systems defines the following values:
+ *
+ *  Value     | Meaning
+ *  ----------|-----------------------------------
+ *  0x00      | Reserved
+ *  0x01      | Simple Profile @@ Level 3
+ *  0x02      | Simple Profile @@ Level 2
+ *  0x03      | Simple Profile @@ Level 1
+ *  0x04      | Simple Scalable Profile @@ Level 2
+ *  0x05      | Simple Scalable Profile @@ Level 1
+ *  0x06      | Core Profile @@ Level 2
+ *  0x07      | Core Profile @@ Level 1
+ *  0x08      | Main Profile @@ Level 4
+ *  0x09      | Main Profile @@ Level 3
+ *  0x0A      | Main Profile @@ Level 2
+ *  0x0B      | N-Bit Profile @@ Level 2
+ *  0x0C      | Hybrid Profile @@ Level 2
+ *  0x0D      | Hybrid Profile @@ Level 1
+ *  0x0E      | Basic Animated Texture @@ Level 2
+ *  0x0F      | Basic Animated Texture @@ Level 1
+ *  0x10      | Scalable Texture @@ Level 3
+ *  0x11      | Scalable Texture @@ Level 2
+ *  0x12      | Scalable Texture @@ Level 1
+ *  0x13      | Simple Face Animation @@ Level 2
+ *  0x14      | Simple Face Animation @@ Level 1
+ *  0x15-0x7F | Reserved
+ *  0x80-0xFD | User private
+ *  0xFE      | No video profile specified
+ *  0xFF      | No video required
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param value specifies the profile/level to set.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetVideoProfileLevel()
+ */
 MP4V2_EXPORT
-void MP4SetVideoProfileLevel( MP4FileHandle hFile, uint8_t value );
+void MP4SetVideoProfileLevel(
+    MP4FileHandle hFile,
+    uint8_t       value );
 
+/** Gets the minimum MPEG-4 audio profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4GetAudioProfileLevel returns the minimum profile/level of MPEG-4 audio
+ *  support necessary to render the contents of the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The current audio profile/level for the file. See
+ *      MP4SetAudioProfileLevel() for known values.
+ *
+ *  @see MP4SetAudioProfileLevel()
+ */
 MP4V2_EXPORT
-uint8_t MP4GetAudioProfileLevel( MP4FileHandle hFile );
+uint8_t MP4GetAudioProfileLevel(
+    MP4FileHandle hFile );
 
+/** Sets the minimum MPEG-4 audio profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4SetAudioProfileLevel sets the minimum profile/level of MPEG-4 audio
+ *  support necessary to render the contents of the file.
+ * 
+ *  ISO/IEC 14496-1:2001 MPEG-4 Systems defines the following values:
+ *
+ *  Value     | Meaning
+ *  ----------|-----------------------------
+ *  0x00      | Reserved
+ *  0x01      | Main Profile @@ Level 1
+ *  0x02      | Main Profile @@ Level 2
+ *  0x03      | Main Profile @@ Level 3
+ *  0x04      | Main Profile @@ Level 4
+ *  0x05      | Scalable Profile @@ Level 1
+ *  0x06      | Scalable Profile @@ Level 2
+ *  0x07      | Scalable Profile @@ Level 3
+ *  0x08      | Scalable Profile @@ Level 4
+ *  0x09      | Speech Profile @@ Level 1
+ *  0x0A      | Speech Profile @@ Level 2
+ *  0x0B      | Synthesis Profile @@ Level 1
+ *  0x0C      | Synthesis Profile @@ Level 2
+ *  0x0D      | Synthesis Profile @@ Level 3
+ *  0x0E-0x7F | Reserved
+ *  0x80-0xFD | User private
+ *  0xFE      | No audio profile specified
+ *  0xFF      | No audio required
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param value specifies the profile/level to set.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetAudioProfileLevel()
+ */
 MP4V2_EXPORT
-void MP4SetAudioProfileLevel( MP4FileHandle hFile, uint8_t value );
+void MP4SetAudioProfileLevel(
+    MP4FileHandle hFile,
+    uint8_t       value );
 
+/** Gets the minimum MPEG-4 graphics profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4GetGraphicsProfileLevel returns the minimum profile/level of MPEG-4
+ *  graphics support necessary to render the contents of the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The current graphics profile/level for the file. See
+ *      MP4SetGraphicsProfileLevel() for known values.
+ *
+ *  @see MP4SetGraphicsProfileLevel()
+ */
 MP4V2_EXPORT
-uint8_t MP4GetGraphicsProfileLevel( MP4FileHandle hFile );
+uint8_t MP4GetGraphicsProfileLevel(
+    MP4FileHandle hFile );
 
+/** Sets the minimum MPEG-4 graphics profile and level required to render the
+ *  contents of the file.
+ *
+ *  MP4SetGraphicsProfileLevel sets the minimum profile/level of MPEG-4
+ *  graphics support necessary to render the contents of the file.
+ * 
+ *  ISO/IEC 14496-1:2001 MPEG-4 Systems defines the following values:
+ *
+ *  Value     | Meaning
+ *  ----------|-----------------------------
+ *  0x00      | Reserved
+ *  0x01      | Simple 2D Profile @@ Level 1
+ *  0x02-0x7F | Reserved
+ *  0x80-0xFD | User private
+ *  0xFE      | No graphics profile specified
+ *  0xFF      | No graphics required
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param value specifies the profile/level to set.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetGraphicsProfileLevel()
+ */
 MP4V2_EXPORT
-bool MP4SetGraphicsProfileLevel( MP4FileHandle hFile, uint8_t value );
+bool MP4SetGraphicsProfileLevel(
+    MP4FileHandle hFile,
+    uint8_t       value );
 
 /** @} ***********************************************************************/
 
diff --git a/mp4v2/include/mp4v2/general.h b/mp4v2/include/mp4v2/general.h
index f9713bf..4745b1b 100644
--- a/mp4v2/include/mp4v2/general.h
+++ b/mp4v2/include/mp4v2/general.h
@@ -1,3 +1,33 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * 3GPP features implementation is based on 3GPP's TS26.234-v5.60,
+ * and was contributed by Ximpo Group Ltd.
+ *
+ * Portions created by Ximpo Group Ltd. are
+ * Copyright (C) Ximpo Group Ltd. 2003, 2004.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Ximpo Group Ltd.,          mp4v2@ximpo.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ */
 #ifndef MP4V2_GENERAL_H
 #define MP4V2_GENERAL_H
 
@@ -38,8 +68,8 @@ typedef void (*MP4LogCallback)(
 
 /** Encryption function pointer.
  *
- * @see MP4EncAndCopySample().
- * @see MP4EncAndCopyTrack().
+ * @see MP4EncAndCopySample()
+ * @see MP4EncAndCopyTrack()
  */
 typedef uint32_t (*encryptFunc_t)( uint32_t, uint32_t, uint8_t*, uint32_t*, uint8_t** );
 
@@ -92,7 +122,7 @@ typedef uint32_t (*encryptFunc_t)( uint32_t, uint32_t, uint8_t*, uint32_t*, uint
     (!strcasecmp(type, MP4_AUDIO_TRACK_TYPE))
 
 #define MP4_IS_CNTL_TRACK_TYPE(type) \
-        (!strcasecmp(type, MP4_CNTL_TRACK_TYPE))
+    (!strcasecmp(type, MP4_CNTL_TRACK_TYPE))
 
 #define MP4_IS_OD_TRACK_TYPE(type) \
     (!strcasecmp(type, MP4_OD_TRACK_TYPE))
@@ -104,69 +134,100 @@ typedef uint32_t (*encryptFunc_t)( uint32_t, uint32_t, uint8_t*, uint32_t*, uint
     (!strcasecmp(type, MP4_HINT_TRACK_TYPE))
 
 #define MP4_IS_SYSTEMS_TRACK_TYPE(type) \
-    (!strcasecmp(type, MP4_CLOCK_TRACK_TYPE) \
-    || !strcasecmp(type, MP4_MPEG7_TRACK_TYPE) \
-    || !strcasecmp(type, MP4_OCI_TRACK_TYPE) \
-    || !strcasecmp(type, MP4_IPMP_TRACK_TYPE) \
-    || !strcasecmp(type, MP4_MPEGJ_TRACK_TYPE))
+    (!strcasecmp(type, MP4_CLOCK_TRACK_TYPE) || \
+     !strcasecmp(type, MP4_MPEG7_TRACK_TYPE) || \
+     !strcasecmp(type, MP4_OCI_TRACK_TYPE)   || \
+     !strcasecmp(type, MP4_IPMP_TRACK_TYPE)  || \
+     !strcasecmp(type, MP4_MPEGJ_TRACK_TYPE))
 
 /* MP4 Audio track types - see MP4AddAudioTrack()*/
-#define MP4_INVALID_AUDIO_TYPE          0x00
-#define MP4_MPEG1_AUDIO_TYPE            0x6B
-#define MP4_MPEG2_AUDIO_TYPE            0x69
-#define MP4_MP3_AUDIO_TYPE              MP4_MPEG2_AUDIO_TYPE
-#define MP4_MPEG2_AAC_MAIN_AUDIO_TYPE   0x66
-#define MP4_MPEG2_AAC_LC_AUDIO_TYPE     0x67
-#define MP4_MPEG2_AAC_SSR_AUDIO_TYPE    0x68
-#define MP4_MPEG2_AAC_AUDIO_TYPE        MP4_MPEG2_AAC_MAIN_AUDIO_TYPE
-#define MP4_MPEG4_AUDIO_TYPE            0x40
-#define MP4_PRIVATE_AUDIO_TYPE          0xC0
-#define MP4_PCM16_LITTLE_ENDIAN_AUDIO_TYPE  0xE0 /* a private definition */
-#define MP4_VORBIS_AUDIO_TYPE           0xE1 /* a private definition */
-#define MP4_AC3_AUDIO_TYPE              0xE2 /* a private definition */
-#define MP4_ALAW_AUDIO_TYPE             0xE3 /* a private definition */
-#define MP4_ULAW_AUDIO_TYPE             0xE4 /* a private definition */
-#define MP4_G723_AUDIO_TYPE             0xE5 /* a private definition */
-#define MP4_PCM16_BIG_ENDIAN_AUDIO_TYPE 0xE6 /* a private definition */
+#define MP4_INVALID_AUDIO_TYPE             0x00
+#define MP4_MPEG1_AUDIO_TYPE               0x6B
+#define MP4_MPEG2_AUDIO_TYPE               0x69
+#define MP4_MP3_AUDIO_TYPE                 MP4_MPEG2_AUDIO_TYPE
+#define MP4_MPEG2_AAC_MAIN_AUDIO_TYPE      0x66
+#define MP4_MPEG2_AAC_LC_AUDIO_TYPE        0x67
+#define MP4_MPEG2_AAC_SSR_AUDIO_TYPE       0x68
+#define MP4_MPEG2_AAC_AUDIO_TYPE           MP4_MPEG2_AAC_MAIN_AUDIO_TYPE
+#define MP4_MPEG4_AUDIO_TYPE               0x40
+#define MP4_PRIVATE_AUDIO_TYPE             0xC0
+#define MP4_PCM16_LITTLE_ENDIAN_AUDIO_TYPE 0xE0 /* a private definition */
+#define MP4_VORBIS_AUDIO_TYPE              0xE1 /* a private definition */
+#define MP4_AC3_AUDIO_TYPE                 0xE2 /* a private definition */
+#define MP4_ALAW_AUDIO_TYPE                0xE3 /* a private definition */
+#define MP4_ULAW_AUDIO_TYPE                0xE4 /* a private definition */
+#define MP4_G723_AUDIO_TYPE                0xE5 /* a private definition */
+#define MP4_PCM16_BIG_ENDIAN_AUDIO_TYPE    0xE6 /* a private definition */
 
 /* MP4 MPEG-4 Audio types from 14496-3 Table 1.5.1 */
-#define MP4_MPEG4_INVALID_AUDIO_TYPE        0
-#define MP4_MPEG4_AAC_MAIN_AUDIO_TYPE       1
-#define MP4_MPEG4_AAC_LC_AUDIO_TYPE         2
-#define MP4_MPEG4_AAC_SSR_AUDIO_TYPE        3
-#define MP4_MPEG4_AAC_LTP_AUDIO_TYPE        4
-#define MP4_MPEG4_AAC_HE_AUDIO_TYPE         5
-#define MP4_MPEG4_AAC_SCALABLE_AUDIO_TYPE   6
-#define MP4_MPEG4_CELP_AUDIO_TYPE           8
-#define MP4_MPEG4_HVXC_AUDIO_TYPE           9
-#define MP4_MPEG4_TTSI_AUDIO_TYPE           12
-#define MP4_MPEG4_MAIN_SYNTHETIC_AUDIO_TYPE 13
-#define MP4_MPEG4_WAVETABLE_AUDIO_TYPE      14
-#define MP4_MPEG4_MIDI_AUDIO_TYPE           15
-#define MP4_MPEG4_ALGORITHMIC_FX_AUDIO_TYPE 16
-#define MP4_MPEG4_ALS_AUDIO_TYPE            31
-#define MP4_MPEG4_LAYER1_AUDIO_TYPE         32
-#define MP4_MPEG4_LAYER2_AUDIO_TYPE         33
-#define MP4_MPEG4_LAYER3_AUDIO_TYPE         34
-#define MP4_MPEG4_SLS_AUDIO_TYPE            35
+#define MP4_MPEG4_INVALID_AUDIO_TYPE         0
+#define MP4_MPEG4_AAC_MAIN_AUDIO_TYPE        1
+#define MP4_MPEG4_AAC_LC_AUDIO_TYPE          2
+#define MP4_MPEG4_AAC_SSR_AUDIO_TYPE         3
+#define MP4_MPEG4_AAC_LTP_AUDIO_TYPE         4
+#define MP4_MPEG4_SBR_AUDIO_TYPE             5
+#define MP4_MPEG4_AAC_SCALABLE_AUDIO_TYPE    6
+#define MP4_MPEG4_TWINVQ_AUDIO_TYPE          7
+#define MP4_MPEG4_CELP_AUDIO_TYPE            8
+#define MP4_MPEG4_HVXC_AUDIO_TYPE            9
+#define MP4_MPEG4_TTSI_AUDIO_TYPE            12
+#define MP4_MPEG4_MAIN_SYNTHETIC_AUDIO_TYPE  13
+#define MP4_MPEG4_WAVETABLE_AUDIO_TYPE       14
+#define MP4_MPEG4_MIDI_AUDIO_TYPE            15
+#define MP4_MPEG4_ALGORITHMIC_FX_AUDIO_TYPE  16
+#define MP4_MPEG4_ER_AAC_LC_AUDIO_TYPE       17
+#define MP4_MPEG4_ER_AAC_LTP_AUDIO_TYPE      19
+#define MP4_MPEG4_ER_AAC_SCALABLE_AUDIO_TYPE 20
+#define MP4_MPEG4_ER_TWINVQ_AUDIO_TYPE       21
+#define MP4_MPEG4_ER_BSAC_AUDIO_TYPE         22
+#define MP4_MPEG4_ER_AAC_LD_AUDIO_TYPE       23
+#define MP4_MPEG4_ER_CELP_AUDIO_TYPE         24
+#define MP4_MPEG4_ER_HXVC_AUDIO_TYPE         25
+#define MP4_MPEG4_ER_HILN_AUDIO_TYPE         26
+#define MP4_MPEG4_ER_PARAMETRIC_AUDIO_TYPE   27
+#define MP4_MPEG4_SSC_AUDIO_TYPE             28
+#define MP4_MPEG4_PS_AUDIO_TYPE              29
+#define MP4_MPEG4_MPEG_S_AUDIO_TYPE          30
+#define MP4_MPEG4_LAYER1_AUDIO_TYPE          32
+#define MP4_MPEG4_LAYER2_AUDIO_TYPE          33
+#define MP4_MPEG4_LAYER3_AUDIO_TYPE          34
+#define MP4_MPEG4_DST_AUDIO_TYPE             35
+#define MP4_MPEG4_ALS_AUDIO_TYPE             36
+#define MP4_MPEG4_SLS_AUDIO_TYPE             37
+#define MP4_MPEG4_SLS_NON_CORE_AUDIO_TYPE    38
+#define MP4_MPEG4_ER_AAC_ELD_AUDIO_TYPE      39
+#define MP4_MPEG4_SMR_SIMPLE_AUDIO_TYPE      40
+#define MP4_MPEG4_SMR_MAIN_AUDIO_TYPE        41
+#define MP4_MPEG4_USAC_AUDIO_TYPE            42
+#define MP4_MPEG4_SAOC_AUDIO_TYPE            43
+#define MP4_MPEG4_MPEG_S_LD_AUDIO_TYPE       44
+
+#define MP4_MPEG4_AAC_HE_AUDIO_TYPE          MP4_MPEG4_SBR_AUDIO_TYPE
+#define MP4_MPEG4_AAC_HEV2_AUDIO_TYPE        MP4_MPEG4_PS_AUDIO_TYPE
+#define MP4_MPEG4_AAC_XHE_AUDIO_TYPE         MP4_MPEG4_USAC_AUDIO_TYPE
 
 /* MP4 Audio type utilities following common usage */
 #define MP4_IS_MP3_AUDIO_TYPE(type) \
-    ((type) == MP4_MPEG1_AUDIO_TYPE || (type) == MP4_MPEG2_AUDIO_TYPE)
+    ((type) == MP4_MPEG1_AUDIO_TYPE || \
+     (type) == MP4_MPEG2_AUDIO_TYPE)
 
 #define MP4_IS_MPEG2_AAC_AUDIO_TYPE(type) \
-    (((type) >= MP4_MPEG2_AAC_MAIN_AUDIO_TYPE \
-        && (type) <= MP4_MPEG2_AAC_SSR_AUDIO_TYPE))
+    ((type) >= MP4_MPEG2_AAC_MAIN_AUDIO_TYPE && \
+     (type) <= MP4_MPEG2_AAC_SSR_AUDIO_TYPE)
 
 #define MP4_IS_MPEG4_AAC_AUDIO_TYPE(mpeg4Type) \
-    (((mpeg4Type) >= MP4_MPEG4_AAC_MAIN_AUDIO_TYPE \
-        && (mpeg4Type) <= MP4_MPEG4_AAC_HE_AUDIO_TYPE) \
-      || (mpeg4Type) == MP4_MPEG4_AAC_SCALABLE_AUDIO_TYPE \
-          || (mpeg4Type) == 17)
+    (((mpeg4Type) >= MP4_MPEG4_AAC_MAIN_AUDIO_TYPE  && \
+      (mpeg4Type) <= MP4_MPEG4_AAC_SCALABLE_AUDIO_TYPE)    || \
+      (mpeg4Type) == MP4_MPEG4_AAC_HEV2_AUDIO_TYPE         || \
+      (mpeg4Type) == MP4_MPEG4_AAC_XHE_AUDIO_TYPE          || \
+     ((mpeg4Type) >= MP4_MPEG4_ER_AAC_LC_AUDIO_TYPE && \
+      (mpeg4Type) <= MP4_MPEG4_ER_AAC_SCALABLE_AUDIO_TYPE) || \
+      (mpeg4Type) == MP4_MPEG4_ER_AAC_LD_AUDIO_TYPE        || \
+      (mpeg4Type) == MP4_MPEG4_ER_AAC_ELD_AUDIO_TYPE)
 
 #define MP4_IS_AAC_AUDIO_TYPE(type) \
-    (MP4_IS_MPEG2_AAC_AUDIO_TYPE(type) \
-    || (type) == MP4_MPEG4_AUDIO_TYPE)
+    (MP4_IS_MPEG2_AAC_AUDIO_TYPE(type) || \
+     (type) == MP4_MPEG4_AUDIO_TYPE)
 
 /* MP4 Video track types - see MP4AddVideoTrack() */
 #define MP4_INVALID_VIDEO_TYPE          0x00
@@ -190,9 +251,9 @@ typedef uint32_t (*encryptFunc_t)( uint32_t, uint32_t, uint8_t*, uint32_t*, uint
     ((type) == MP4_MPEG1_VIDEO_TYPE)
 
 #define MP4_IS_MPEG2_VIDEO_TYPE(type) \
-    (((type) >= MP4_MPEG2_SIMPLE_VIDEO_TYPE \
-        && (type) <= MP4_MPEG2_442_VIDEO_TYPE) \
-      || MP4_IS_MPEG1_VIDEO_TYPE(type))
+    (MP4_IS_MPEG1_VIDEO_TYPE(type) || \
+     ((type) >= MP4_MPEG2_SIMPLE_VIDEO_TYPE && \
+      (type) <= MP4_MPEG2_442_VIDEO_TYPE))
 
 #define MP4_IS_MPEG4_VIDEO_TYPE(type) \
     ((type) == MP4_MPEG4_VIDEO_TYPE)
@@ -272,6 +333,50 @@ bool MP4Make3GPCompliant(
 
 /* NOTE this section of functionality has not yet been fully tested */
 
+/** Add an edit segment to a track.
+ *
+ *  MP4AddTrackEdit adds an edit segment to the track edit list.
+ *
+ *  The track edit list is a feature that allows creation of an alternate
+ *  timeline for the track, typically cutting out segments of the full track to
+ *  form a shortened, cleaned up version. The edit segments that form the edit
+ *  list are a sequence of track start times and durations, they do not alter
+ *  the track media in any way, i.e. no data can be lost via edit list
+ *  operations.
+ *
+ *  To read out the editted version of the track, use
+ *  MP4ReadSampleFromEditTime() instead of MP4ReadSample().
+ *
+ *  To export the editted version of the track to a new track, potentially in a
+ *  new mp4 file, see MP4CopyTrack().
+ *
+ *  Note with many media encodings such as MPEG-4, AAC and MP3, care must be
+ *  taken when choosing the edit segment start times. E.g. for video tracks a
+ *  reference or key frame should be selected as the starting sample of any
+ *  edit segment. For audio tracks, an audio sample start time should be used.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the desired position in the edit list sequence for
+ *      the new edit segment. If the value is MP4_INVALID_EDIT_ID, then the
+ *      edit segment is added at the end of the existing edit list. Note
+ *      editId's start with the value of 1, not 0.
+ *  @param startTime specifies the starting time of the edit segment in the
+ *      track time scale.
+ *  @param duration specifies the duration of the edit segment in the track
+ *      time scale.
+ *  @param dwell If false, the track media should be played at its normal rate.
+ *      If true, the media should be paused for the duration of this edit
+ *      segment. This is a mechanism by which one can delay the start of a
+ *      media track.
+ *
+ *  @return Upon success, the edit id of the new edit segment. Upon an error,
+ *      MP4_INVALID_EDIT_ID.
+ *
+ *  @see MP4DeleteTrackEdit()
+ *  @see MP4ReadSampleFromEditTime()
+ *  @see MP4CopyTrack()
+ */
 MP4V2_EXPORT
 MP4EditId MP4AddTrackEdit(
     MP4FileHandle hFile,
@@ -281,35 +386,168 @@ MP4EditId MP4AddTrackEdit(
     MP4Duration   duration DEFAULT(0),
     bool          dwell DEFAULT(false) );
 
+/** Delete a track edit segment.
+ *
+ *  MP4DeleteTrackEdit deletes the specified track edit segment. Note that
+ *  since editId's form a sequence, deleting an editId will cause all edit
+ *  segments with editId's greater than the deleted one to be reassigned to
+ *  their editId minus one.
+ *
+ *  Deleting an edit segment does not delete any media samples.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment to be deleted.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddTrackEdit()
+ */
 MP4V2_EXPORT
 bool MP4DeleteTrackEdit(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId );
 
+/** Get the number of edit segments for a track.
+ *
+ *  MP4GetTrackNumberOfEdits returns the number of edit segments in the
+ *  specified track in the mp4 file. Edit id's are the consecutive sequence of
+ *  numbers from 1 to the total number of edit segments, i.e. 1-based indexing,
+ *  not 0-based indexing.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the number of edit segments is
+ *      desired.
+ *
+ *  @return Upon success, the number of edit segments for the track. Upon an
+ *      error, 0.
+ *
+ *  @see MP4AddTrackEdit()
+ *  @see MP4DeleteTrackEdit()
+ */
 MP4V2_EXPORT
 uint32_t MP4GetTrackNumberOfEdits(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the start time of a track edit segment.
+ *
+ *  MP4GetTrackEditStart returns the start time of the specified track edit
+ *  segment in the timeline of the track edit list.
+ *
+ *  Caveat: The value is in units of the track time scale.
+ *
+ *  Note that this differs from the edit segment media start time,
+ *  MP4GetTrackEditMediaStart(). For example:
+ *
+ *  EditId | Start | MediaStart | Duration
+ *  -------|-------|------------|---------
+ *  1      | 0     | 15         | 30
+ *  2      | 30    | 120        | 20
+ *  3      | 50    | 3000       | 10
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment for which the start time is
+ *      desired.
+ *
+ *  @return The start time of the edit segment in track time scale units of the
+ *      track in the mp4 file.
+ *
+ *  @see MP4SetTrackEditStart()
+ */
 MP4V2_EXPORT
 MP4Timestamp MP4GetTrackEditStart(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId );
 
+/** Get the total duration of a sequence of track edit segments.
+ *
+ *  MP4GetTrackEditTotalDuration returns the total duration of the specified
+ *  sequence of track edit segments from the first edit segment up to and
+ *  including the specified edit segment. If the edit id value is
+ *  MP4_INVALID_EDIT_ID, then the total duration of all of the edit segments is
+ *  returned.
+ *
+ *  Caveat: The value is in units of the track time scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment for which the total duration is
+ *      desired. A value of MP4_INVALID_EDIT_ID specifies that all edit
+ *      segments should be included.
+ *
+ *  @return The total duration of the edit segment sequence in track time scale
+ *      units of the track in the mp4 file.
+ *
+ *  @see MP4GetTrackEditDuration()
+ */
 MP4V2_EXPORT
 MP4Duration MP4GetTrackEditTotalDuration(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId DEFAULT(MP4_INVALID_EDIT_ID) );
 
+/** Get the media start time of a track edit segment.
+ *
+ *  MP4GetTrackEditMediaStart returns the media start time of the specified
+ *  track edit segment. 
+ *
+ *  Caveat: The value is in units of the track time scale.
+ *
+ *  Note that this differs from the edit segment start time,
+ *  MP4GetTrackEditStart(). For example:
+ *
+ *  EditId | Start | MediaStart | Duration
+ *  -------|-------|------------|---------
+ *  1      | 0     | 15         | 30
+ *  2      | 30    | 120        | 20
+ *  3      | 50    | 3000       | 10
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment for which the media start time is
+ *      desired.
+ *
+ *  @return The media start time of the edit segment in track time scale units
+ *      of the track in the mp4 file.
+ *
+ *  @see MP4SetTrackEditMediaStart()
+ */
 MP4V2_EXPORT
 MP4Timestamp MP4GetTrackEditMediaStart(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId );
 
+/** Set the media start time of a track edit segment.
+ *
+ *  MP4SetTrackEditMediaStart sets the media start time of the specified edit
+ *  segment from the specified track in the track time scale units. See
+ *  MP4ConvertToTrackTimestamp() for how to map this value from another time
+ *  scale.
+ *
+ *  Note that this differs from the edit segment start time. For example:
+ *
+ *  EditId | Start | MediaStart | Duration
+ *  -------|-------|------------|---------
+ *  1      | 0     | 15         | 30
+ *  2      | 30    | 120        | 20
+ *  3      | 50    | 3000       | 10
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment to which the operation applies.
+ *      Caveat: the first edit has id 1 not 0.
+ *  @param startTime specifies the new value for the media start in track time
+ *      scale units.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetTrackEditMediaStart()
+ */
 MP4V2_EXPORT
 bool MP4SetTrackEditMediaStart(
     MP4FileHandle hFile,
@@ -317,12 +555,46 @@ bool MP4SetTrackEditMediaStart(
     MP4EditId     editId,
     MP4Timestamp  startTime );
 
+/** Get the duration of a track edit segment.
+ *
+ *  MP4GetTrackEditDuration returns the duration of the specified track edit
+ *  segment.
+ *
+ *  Caveat: The value is in units of the track time scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment for which the duration is desired.
+ *
+ *  @return The duration of the edit segment in track time scale units of the
+ *      track in the mp4 file.
+ *
+ *  @see MP4SetTrackEditDuration()
+ */
 MP4V2_EXPORT
 MP4Duration MP4GetTrackEditDuration(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId );
 
+/** Set the duration of a track edit segment.
+ *
+ *  MP4SetTrackEditDuration sets the duration of the specified edit segment
+ *  from the specified track in the track time scale units. See
+ *  MP4ConvertToTrackDuration() for how to map this value from another time
+ *  scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment to which the operation applies.
+ *      Caveat: the first edit has id 1 not 0.
+ *  @param duration specifies the new value for the duration in track time
+ *      scale units.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetTrackEditDuration()
+ */
 MP4V2_EXPORT
 bool MP4SetTrackEditDuration(
     MP4FileHandle hFile,
@@ -330,12 +602,47 @@ bool MP4SetTrackEditDuration(
     MP4EditId     editId,
     MP4Duration   duration );
 
+/** Get the dwell value of a track edit segment.
+ *
+ *  MP4GetTrackEditDwell returns the dwell value of the specified track edit
+ *  segment. A value of true (1) indicates that during this edit segment the
+ *  media will be paused; a value of false (0) indicates that during this edit
+ *  segment the media will be played at its normal rate.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment for which the dwell value is
+ *      desired.
+ *
+ *  @return The dwell value of the edit segment of the track in the mp4 file.
+ *
+ *  @see MP4SetTrackEditDwell()
+ */
 MP4V2_EXPORT
 int8_t MP4GetTrackEditDwell(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     MP4EditId     editId );
 
+/** Set the dwell value of a track edit segment.
+ *
+ *  MP4SetTrackEditDwell sets the dwell value of the specified edit segment
+ *  from the specified track.
+ *
+ *  A value of true (1) indicates that during this edit segment the media will
+ *  be paused; a value of false (0) indicates that during this edit segment the
+ *  media will be played at its normal rate.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param editId specifies the edit segment to which the operation applies.
+ *      Caveat: the first edit has id 1 not 0.
+ *  @param dwell specifies the new dwell value.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetTrackEditDwell()
+ */
 MP4V2_EXPORT
 bool MP4SetTrackEditDwell(
     MP4FileHandle hFile,
@@ -343,6 +650,68 @@ bool MP4SetTrackEditDwell(
     MP4EditId     editId,
     bool          dwell );
 
+/** Read a track sample based on a specified edit list time.
+ *
+ *  MP4ReadSampleFromEditTime reads the sample corresponding to the time on the
+ *  track edit list timeline from the specified track. Typically this sample is
+ *  then decoded in a codec dependent fashion and rendered in an appropriate
+ *  fashion.
+ *
+ *  The argument, <b>ppBytes</b>, allows for two possible approaches for
+ *  buffering:
+ *
+ *  @li If the calling application wishes to handle its own buffering it can
+ *      set <b>*ppBytes</b> to the buffer it wishes to use. The calling
+ *      application is responsible for ensuring that the buffer is large enough
+ *      to hold the sample. This can be done by using either MP4GetSampleSize()
+ *      or MP4GetTrackMaxSampleSize() to determine beforehand how large the
+ *      receiving buffer must be.
+ *
+ *  @li If the value of <b>*ppBytes</b> is NULL, then an appropriately sized
+ *      buffer is automatically allocated for the sample data and
+ *      <b>*ppBytes</b> set to this pointer. The calling application is
+ *      responsible for freeing this memory with MP4Free().
+ *
+ *  The last four arguments are pointers to variables that can receive optional
+ *  sample information. 
+ *
+ *  Typically for audio none of these are needed. MPEG audio such as MP3 or AAC
+ *  has a fixed sample duration and every sample can be accessed at random.
+ *
+ *  For video, all of these optional values could be needed. MPEG video can be
+ *  encoded at a variable frame rate, with only occasional random access
+ *  points, and with "B frames" which cause the rendering (display) order of
+ *  the video frames to differ from the storage/decoding order.
+ *
+ *  Other media types fall between these two extremes.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param when specifies which sample is to be read based on a time in the
+ *      edit list timeline. See MP4GetSampleIdFromEditTime() for details.
+ *  @param ppBytes Pointer to the pointer to the sample data. See function
+ *      description above for details on this argument.
+ *  @param pNumBytes Pointer to variable that will be hold the size in bytes of
+ *      the sample.
+ *  @param pStartTime If non-NULL, pointer to variable that will receive the
+ *      starting timestamp for this sample. Caveat: The timestamp is in the
+ *      track timescale.
+ *  @param pDuration If non-NULL, pointer to variable that will receive the
+ *      duration for this sample. Caveat: The duration is in the track
+ *      timescale units.
+ *  @param pRenderingOffset If non-NULL, pointer to variable that will receive
+ *      the rendering offset for this sample. Currently the only media type
+ *      that needs this feature is MPEG video. Caveat: The offset is in the
+ *      track timescale units.
+ *  @param pIsSyncSample If non-NULL, pointer to variable that will receive the
+ *      state of the sync/random access flag for this sample.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4ReadSample()
+ *  @see MP4GetSampleIdFromEditTime()
+ *  @see MP4ReadSampleFromTime()
+ */
 MP4V2_EXPORT
 bool MP4ReadSampleFromEditTime(
     /* input parameters */
@@ -350,14 +719,43 @@ bool MP4ReadSampleFromEditTime(
     MP4TrackId    trackId,
     MP4Timestamp  when,
     /* input/output parameters */
-    uint8_t** ppBytes,
-    uint32_t* pNumBytes,
+    uint8_t**     ppBytes,
+    uint32_t*     pNumBytes,
     /* output parameters */
     MP4Timestamp* pStartTime DEFAULT(NULL),
     MP4Duration*  pDuration DEFAULT(NULL),
     MP4Duration*  pRenderingOffset DEFAULT(NULL),
     bool*         pIsSyncSample DEFAULT(NULL) );
 
+/** Get the sample id of a specified time in the edit list timeline.
+ *
+ *  MP4GetSampleIdFromEditTime returns the sample id of the track sample in
+ *  which the specified time occurs in the edit list timeline. 
+ *
+ *  The specified time should be in the track time scale. See
+ *  MP4ConvertToTrackTimestamp() for how to map a time value to this time
+ *  scale.
+ *
+ *  Since the edit list can cause the sample start time and duration to be
+ *  different that it in the standard track timeline, it is strongly advised
+ *  that the caller retrieve the new sample start time and duration via this
+ *  function.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param when specifies the time in the track time scale that is desired.
+ *  @param pStartTime If non-NULL, pointer to variable that will receive the
+ *      starting timestamp for this sample. Caveat: The timestamp is in the
+ *      track edit list timescale.
+ *  @param pDuration If non-NULL, pointer to variable that will receive the
+ *      duration for this sample in the edit list timeline. Caveat: The
+ *      duration is in the track timescale units.
+ *
+ *  @return Upon success, the sample id that occurs at the specified time. Upon
+ *      an error, MP4_INVALID_SAMPLE_ID.
+ *
+ *  @see MP4GetSampleIdFromTime()
+ */
 MP4V2_EXPORT
 MP4SampleId MP4GetSampleIdFromEditTime(
     MP4FileHandle hFile,
@@ -379,12 +777,46 @@ MP4SampleId MP4GetSampleIdFromEditTime(
 #define MP4_USECS_TIME_SCALE    MP4_MICROSECONDS_TIME_SCALE
 #define MP4_NSECS_TIME_SCALE    MP4_NANOSECONDS_TIME_SCALE
 
+/** Convert a duration from the movie (file) time scale to a specified time
+ *      scale.
+ *
+ *  MP4ConvertFromMovieDuration converts a duration such as the total movie
+ *  (file) duration from the movie time scale to another specified time scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param duration specifies the duration that is to be converted.
+ *  @param timeScale specifies the new time scale in ticks per second to which
+ *      the duration should be converted.
+ *
+ *  @return Upon success, the duration in the new time scale units. Upon error,
+ *      (uint64_t) MP4_INVALID_DURATION.
+ *
+ *  @see MP4GetDuration()
+ */
 MP4V2_EXPORT
 uint64_t MP4ConvertFromMovieDuration(
     MP4FileHandle hFile,
     MP4Duration   duration,
     uint32_t      timeScale );
 
+/** Convert a timestamp from the track time scale to a specified time scale.
+ *
+ *  MP4ConvertFromTrackTimestamp converts a timestamp such as a sample start
+ *  time from the track time scale to another specified time scale. This can be
+ *  used by a player application to map all track samples to a common time
+ *  scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track from which the timestamp originates.
+ *  @param timeStamp specifies the timestamp that is to be converted.
+ *  @param timeScale specifies the new time scale in ticks per second to which
+ *      the timestamp should be converted.
+ *
+ *  @return Upon success, the timestamp in the new time scale units. Upon
+ *      error, (uint64_t) MP4_INVALID_TIMESTAMP.
+ *
+ *  @see MP4ConvertToTrackTimestamp()
+ */
 MP4V2_EXPORT
 uint64_t MP4ConvertFromTrackTimestamp(
     MP4FileHandle hFile,
@@ -392,6 +824,22 @@ uint64_t MP4ConvertFromTrackTimestamp(
     MP4Timestamp  timeStamp,
     uint32_t      timeScale );
 
+/** Convert a timestamp from a specified time scale to the track time scale.
+ *
+ *  MP4ConvertToTrackTimestamp converts a timestamp such as a sample start time
+ *  from the specified time scale to the track time scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *  @param timeStamp specifies the timestamp that is to be converted.
+ *  @param timeScale specifies the time scale in ticks per second in which the
+ *      timestamp is currently expressed.
+ *
+ *  @return Upon success, the timestamp in the track time scale units. Upon
+ *      error, MP4_INVALID_TIMESTAMP.
+ *
+ *  @see MP4ConvertFromTrackTimestamp()
+ */
 MP4V2_EXPORT
 MP4Timestamp MP4ConvertToTrackTimestamp(
     MP4FileHandle hFile,
@@ -411,10 +859,10 @@ MP4Timestamp MP4ConvertToTrackTimestamp(
  *  @param timeScale time scale in ticks per second.
  *
  *  @return On success, the duration in arbitrary time scale units.
- *      On error, <b>0</b>.
+ *      On error, (uint64_t) MP4_INVALID_DURATION.
  *
- *  @see MP4GetSampleDuration().
- *  @see MP4ConvertToTrackDuration().
+ *  @see MP4GetSampleDuration()
+ *  @see MP4ConvertToTrackDuration()
  */
 MP4V2_EXPORT
 uint64_t MP4ConvertFromTrackDuration(
@@ -436,7 +884,7 @@ uint64_t MP4ConvertFromTrackDuration(
  *  @return On success, the duration in track time scale units.
  *      On error, #MP4_INVALID_DURATION.
  *
- *  @see MP4ConvertFromTrackDuration().
+ *  @see MP4ConvertFromTrackDuration()
  */
 MP4V2_EXPORT
 MP4Duration MP4ConvertToTrackDuration(
@@ -445,51 +893,112 @@ MP4Duration MP4ConvertToTrackDuration(
     uint64_t      duration,
     uint32_t      timeScale );
 
+/** Convert binary data to a base 16 string.
+ *
+ *  MP4BinaryToBase16 converts binary data to a base 16 string. This encoding
+ *  maps groups of 4 bits into the character set [0-9a-f]. The string is in
+ *  newly allocated memory, so the caller is responsible for freeing the memory
+ *  with MP4Free().
+ *
+ *  This utility is useful for generating the SDP descriptions for some RTP
+ *  payloads.
+ *
+ *  Example:
+ *  @code
+ *    0x12, 0xAB -> "12ab"
+ *  @endcode
+ *
+ *  @param pData specifies the pointer to the binary data.
+ *  @param dataSize specifies the size in bytes of the binary data.
+ *
+ *  @return Upon success, a null terminated string representing the data in
+ *      base 16. Upon error, NULL.
+ */
 MP4V2_EXPORT
 char* MP4BinaryToBase16(
     const uint8_t* pData,
     uint32_t       dataSize );
 
+/** Convert binary data to a base 64 string.
+ *
+ *  MP4BinaryToBase64 converts binary data to a base 64 string. This encoding
+ *  maps groups of 6 bits into the character set [A-Za-z0-9+/=]. The string is
+ *  in newly allocated memory, so the caller is responsible for freeing the
+ *  memory with MP4Free().
+ *
+ *  This utility is useful for generating the SDP descriptions for some RTP
+ *  payloads.
+ *
+ *  Example:
+ *  @code
+ *    0x12, 0xAB -> "Eqs="
+ *  @endcode
+ *
+ *  @param pData specifies the pointer to the binary data.
+ *  @param dataSize specifies the size in bytes of the binary data.
+ *
+ *  @return Upon success, a null terminated string representing the data in
+ *      base 64. Upon error, NULL.
+ */
 MP4V2_EXPORT
 char* MP4BinaryToBase64(
     const uint8_t* pData,
     uint32_t       dataSize );
 
-MP4V2_EXPORT
-uint8_t* Base64ToBinary(
-    const char* pData,
-    uint32_t    decodeSize,
-    uint32_t*   pDataSize );
-
+/** Free memory allocated by other library functions.
+ *
+ *  MP4Free frees a block of memory previously allocated by another library
+ *  function.
+ *
+ *  Generally, library functions that allocate memory specify in their
+ *  documentation whether MP4Free or another function must be used to free that
+ *  memory.
+ *
+ *  @param p specifies a pointer to the memory block to free.
+ */
 MP4V2_EXPORT
 void MP4Free(
     void* p );
 
-/** Set the function to call in place of default logging behavior
+/** Set the current log handler function.
+ * 
+ *  MP4SetLogCallback sets the function to call to output diagnostic
+ *  information in place of the default log handler. The signature of the
+ *  specified function must be compatible with the MP4LogCallback typedef.
+ *
+ *  @param cb_func specifies the new log handler function.
  *
- * @param cb_func the function to call
+ *  @see MP4LogCallback
  */
 MP4V2_EXPORT
 void MP4SetLogCallback(
     MP4LogCallback cb_func );
-/** @} ***********************************************************************/
 
-/**
- * Accessor for the maximum level for diagnostic information
+/** Get the current maximum log level.
+ *
+ *  MP4LogGetLevel returns the currently set maximum level of diagnostic
+ *  information passed to the log handler.
  *
- * @return the maximum level for diagnostic information
+ *  @return the current maximum level of diagnostic information.
  *
- * @see MP4LogSetLevel() for further details.
+ *  @see MP4LogSetLevel()
  */
 MP4V2_EXPORT
 MP4LogLevel MP4LogGetLevel( void );
 
-/**
- * Set the maximum level for diagnostic information
+/** Set the maximum log level.
  *
- * @param verbosity the level to set
+ *  MP4LogSetLevel sets the maximum level of diagnostic information passed to
+ *  the current log handler.
+ *
+ *  @param verbosity specifies the log level to set.
+ *
+ *  @see MP4LogGetLevel()
  */
 MP4V2_EXPORT
-void MP4LogSetLevel( MP4LogLevel verbosity );
+void MP4LogSetLevel(
+    MP4LogLevel verbosity );
+
+/** @} ***********************************************************************/
 
 #endif /* MP4V2_GENERAL_H */
diff --git a/mp4v2/include/mp4v2/isma.h b/mp4v2/include/mp4v2/isma.h
index 074a06e..c88ffea 100644
--- a/mp4v2/include/mp4v2/isma.h
+++ b/mp4v2/include/mp4v2/isma.h
@@ -1,3 +1,25 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ */
 #ifndef MP4V2_ISMA_H
 #define MP4V2_ISMA_H
 
@@ -20,11 +42,12 @@ typedef struct mp4v2_ismacryp_session_params {
 
 /*
  * API to initialize ismacryp properties to sensible defaults
- * if input param is null then mallocs a params struct
+ * if input param is null, a params struct is allocated
  */
 
 MP4V2_EXPORT
-mp4v2_ismacrypParams* MP4DefaultISMACrypParams( mp4v2_ismacrypParams* ptr );
+mp4v2_ismacrypParams* MP4DefaultISMACrypParams(
+    mp4v2_ismacrypParams* ptr );
 
 MP4V2_EXPORT
 MP4TrackId MP4AddEncAudioTrack(
@@ -75,6 +98,27 @@ MP4TrackId MP4EncAndCopyTrack(
     bool                  applyEdits DEFAULT(false),
     MP4TrackId            dstHintTrackReferenceTrack DEFAULT(MP4_INVALID_TRACK_ID) );
 
+/** Add ISMA compliant OD and Scene tracks.
+ *
+ *  MP4MakeIsmaCompliant modifies an mp4 file so that it complies with the
+ *  minimal MPEG-4 Systems requirements defined by the Internet Streaming Media
+ *  Alliance (ISMA).
+ *
+ *  This involves creating an OD and Scene track, and using them to describe a
+ *  simple scene of one audio, or one video, or one of each. Whether an SDP
+ *  version of this information is added to the mp4 file can be controlled with
+ *  the @p addIsmaComplianceSdp parameter.
+ *
+ *  Caveat: whether the file is truly ISMA compliant also depends on the
+ *  contents of the media and hint tracks. This function does not guarantee
+ *  that these tracks are compliant.
+ *
+ *  @param fileName specifies the path name of the file to be modified.
+ *  @param addIsmaComplianceSdp specifies whether an SDP declaring ISMA
+ *      compliance should be added to the file.
+ * 
+ *  @return Upon success, true (1). Upon an error, false (0).
+ */
 MP4V2_EXPORT
 bool MP4MakeIsmaCompliant(
     const char* fileName,
diff --git a/mp4v2/include/mp4v2/itmf_generic.h b/mp4v2/include/mp4v2/itmf_generic.h
index b780b1e..c5ac0c5 100644
--- a/mp4v2/include/mp4v2/itmf_generic.h
+++ b/mp4v2/include/mp4v2/itmf_generic.h
@@ -1,3 +1,23 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MP4v2.
+ *
+ * The Initial Developer of the Original Code is Kona Blend.
+ * Portions created by Kona Blend are Copyright (C) 2009.
+ * All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Kona Blend, kona8lend@gmail.com
+ */
 #ifndef MP4V2_ITMF_GENERIC_H
 #define MP4V2_ITMF_GENERIC_H
 
@@ -8,36 +28,36 @@
  *
  *  This is a low-level API used to manage iTMF metadata.
  *
- *  It provides support for virtually any kind of iTMF metadata item,
- *  including meaning atoms, sometimes referred to as reverse-DNS meanings.
- *  Structures are directly modified; ie: there are no fuctions which
- *  modify values for you. There is little type-safety, logic checks, or
- *  specifications compliance checks. For these reasons it is recommended
- *  to use iTMF Tags API when possible.
- *
- *  At the heart of this API is an #MP4ItmfItem which corresponds to an
- *  iTMF metadata item atom. The item, and any recursive data structures
- *  contained within require <b>manual</b> memory management. The general
- *  rule to follow is that you must always check/free a ptr if you intend
- *  to resize data. In cases where you know the existing data size is
- *  exactly what is needed, you may overwrite the buffer contents.
- *
- *  Each item always has at least 1 data elements which corresponds to
- *  a data atom. Additionally, each item has optional <b>mean</b> and
- *  <b>name</b> values which correspond to mean and name atoms.
- *
- *  Each #MP4ItmfItem has a list of #MP4ItmfData. Similarily, care must
- *  be taken to manage memory with one key difference; these structures
- *  also have a valueSize field. If value is NULL then set valueSize=0.
- *  Otherwise, set valueSize to the size (in bytes) of value buffer.
- *
- *  In rare cases where the number of data elements in a single item
- *  is > 1, the user must manually free/alloc/copy the <b>elements</b>
- *  buffer and update <b>size</b> accordingly.
- *
- *  The mp4 file structure is modified only when MP4AddItem(),
- *  MP4SetItem() and MP4RemoveItem() are used. Simply free'ing
- *  the item list does not modify the mp4 file.
+ *  It provides support for virtually any kind of iTMF metadata item, including
+ *  meaning atoms, sometimes referred to as reverse-DNS meanings. Structures
+ *  are directly modified; i.e. there are no fuctions which modify values for
+ *  you. There is little type-safety, logic checks, or specifications
+ *  compliance checks. For these reasons it is recommended to use iTMF Tags API
+ *  when possible.
+ *
+ *  At the heart of this API is an #MP4ItmfItem which corresponds to an iTMF
+ *  metadata item atom. The item, and any recursive data structures contained
+ *  within require <b>manual</b> memory management. The general rule to follow
+ *  is that you must always check/free a ptr if you intend to resize data. In
+ *  cases where you know the existing data size is exactly what is needed, you
+ *  may overwrite the buffer contents.
+ *
+ *  Each item always has at least 1 data elements which corresponds to a data
+ *  atom. Additionally, each item has optional <b>mean</b> and <b>name</b>
+ *  values which correspond to mean and name atoms.
+ *
+ *  Each #MP4ItmfItem has a list of #MP4ItmfData. Similarily, care must be
+ *  taken to manage memory with one key difference; these structures also have
+ *  a valueSize field. If value is NULL then set valueSize=0. Otherwise, set
+ *  valueSize to the size (in bytes) of value buffer.
+ *
+ *  In rare cases where the number of data elements in a single item is > 1,
+ *  the user must manually free/alloc/copy the <b>elements</b> buffer and
+ *  update <b>size</b> accordingly.
+ *
+ *  The mp4 file structure is modified only when MP4AddItem(), MP4SetItem() and
+ *  MP4RemoveItem() are used. Simply free'ing the item list does not modify the
+ *  mp4 file.
  *
  *  <b>iTMF Generic read workflow:</b>
  *
@@ -61,9 +81,9 @@
  *
  *  @par Warning:
  *  Care must be taken when using multiple mechanisms to modify an open mp4
- *  file as it is not thread-safe, nor does it permit overlapping different
- *  API workflows which have a begin/end to their workflow. That is to say
- *  do not interleave an iTMF Generic workflow with an iTMF Tags workflow.
+ *  file as it is not thread-safe, nor does it permit overlapping different API
+ *  workflows which have a begin/end to their workflow. That is to say do not
+ *  interleave an iTMF Generic workflow with an iTMF Tags workflow.
  *
  *****************************************************************************/
 
@@ -138,69 +158,85 @@ typedef struct MP4ItmfItemList_s
  *  @param numData number of data elements to allocate. Must be >= 1.
  *  @return newly allocated item.
  */
-MP4V2_EXPORT MP4ItmfItem*
-MP4ItmfItemAlloc( const char* code, uint32_t numData );
+MP4V2_EXPORT
+MP4ItmfItem* MP4ItmfItemAlloc(
+    const char* code,
+    uint32_t    numData );
 
 /** Free an item (deep free).
  *  @param item to be free'd.
  */
-MP4V2_EXPORT void
-MP4ItmfItemFree( MP4ItmfItem* item );
+MP4V2_EXPORT
+void MP4ItmfItemFree(
+    MP4ItmfItem* item );
 
 /** Free an item list (deep free).
  *  @param itemList to be free'd.
  */
-MP4V2_EXPORT void
-MP4ItmfItemListFree( MP4ItmfItemList* itemList );
+MP4V2_EXPORT
+void MP4ItmfItemListFree(
+    MP4ItmfItemList* itemList );
 
 /** Get list of all items from file.
  *  @param hFile handle of file to operate on.
  *  @return On succes, list of items, which must be free'd. On failure, NULL.
  */
-MP4V2_EXPORT MP4ItmfItemList*
-MP4ItmfGetItems( MP4FileHandle hFile );
+MP4V2_EXPORT
+MP4ItmfItemList* MP4ItmfGetItems(
+    MP4FileHandle hFile );
 
 /** Get list of items by code from file.
  *  @param hFile handle of file to operate on.
  *  @param code four-char code identifying atom type. NULL-terminated.
  *  @return On succes, list of items, which must be free'd. On failure, NULL.
  */
-MP4V2_EXPORT MP4ItmfItemList*
-MP4ItmfGetItemsByCode( MP4FileHandle hFile, const char* code );
+MP4V2_EXPORT
+MP4ItmfItemList* MP4ItmfGetItemsByCode(
+    MP4FileHandle hFile,
+    const char*   code );
 
 /** Get list of items by meaning from file.
- *  Implicitly only returns atoms of code @b{----}.
+ *  Implicitly only returns atoms of code <b>{----}</b>.
  *  @param hFile handle of file to operate on.
  *  @param meaning UTF-8 meaning. NULL-terminated.
  *  @param name may be NULL. UTF-8 name. NULL-terminated.
  *  @return On succes, list of items, which must be free'd. On failure, NULL.
  */
-MP4V2_EXPORT MP4ItmfItemList*
-MP4ItmfGetItemsByMeaning( MP4FileHandle hFile, const char* meaning, const char* name );
+MP4V2_EXPORT
+MP4ItmfItemList* MP4ItmfGetItemsByMeaning(
+    MP4FileHandle hFile,
+    const char*   meaning,
+    const char*   name );
 
 /** Add an item to file.
  *  @param hFile handle of file to operate on.
  *  @param item object to add.
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
-MP4V2_EXPORT bool
-MP4ItmfAddItem( MP4FileHandle hFile, const MP4ItmfItem* item );
+MP4V2_EXPORT
+bool MP4ItmfAddItem(
+    MP4FileHandle      hFile,
+    const MP4ItmfItem* item );
 
 /** Overwrite an existing item in file.
  *  @param hFile handle of file to operate on.
  *  @param item object to overwrite. Must have a valid index obtained from prior get.
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
-MP4V2_EXPORT bool
-MP4ItmfSetItem( MP4FileHandle hFile, const MP4ItmfItem* item );
+MP4V2_EXPORT
+bool MP4ItmfSetItem(
+    MP4FileHandle      hFile,
+    const MP4ItmfItem* item );
 
 /** Remove an existing item from file.
  *  @param hFile handle of file to operate on.
  *  @param item object to remove. Must have a valid index obtained from prior get.
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
-MP4V2_EXPORT bool
-MP4ItmfRemoveItem( MP4FileHandle hFile, const MP4ItmfItem* item );
+MP4V2_EXPORT
+bool MP4ItmfRemoveItem(
+    MP4FileHandle      hFile,
+    const MP4ItmfItem* item );
 
 /** @} ***********************************************************************/
 
diff --git a/mp4v2/include/mp4v2/itmf_tags.h b/mp4v2/include/mp4v2/itmf_tags.h
index 3115a3c..61ab862 100644
--- a/mp4v2/include/mp4v2/itmf_tags.h
+++ b/mp4v2/include/mp4v2/itmf_tags.h
@@ -1,3 +1,24 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MP4v2.
+ *
+ * The Initial Developer of the Original Code is Kona Blend.
+ * Portions created by Kona Blend are Copyright (C) 2009.
+ * All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Kona Blend, kona8lend@gmail.com
+ *      David Byron, dbyron0@gmail.com
+ */
 #ifndef MP4V2_ITMF_TAGS_H
 #define MP4V2_ITMF_TAGS_H
 
@@ -99,64 +120,64 @@ typedef struct MP4Tags_s
 {
     void* __handle; /* internal use only */
 
-    const char*        name;
-    const char*        artist;
-    const char*        albumArtist; 
-    const char*        album;
-    const char*        grouping;
-    const char*        composer;
-    const char*        comments;
-    const char*        genre;
-    const uint16_t*    genreType;
-    const char*        releaseDate;
-    const MP4TagTrack* track;
-    const MP4TagDisk*  disk;
-    const uint16_t*    tempo;
-    const uint8_t*     compilation;
+    const char*          name;
+    const char*          artist;
+    const char*          albumArtist; 
+    const char*          album;
+    const char*          grouping;
+    const char*          composer;
+    const char*          comments;
+    const char*          genre;
+    const uint16_t*      genreType;
+    const char*          releaseDate;
+    const MP4TagTrack*   track;
+    const MP4TagDisk*    disk;
+    const uint16_t*      tempo;
+    const uint8_t*       compilation;
 
-    const char*     tvShow;
-    const char*     tvNetwork;
-    const char*     tvEpisodeID;
-    const uint32_t* tvSeason;
-    const uint32_t* tvEpisode;
+    const char*          tvShow;
+    const char*          tvNetwork;
+    const char*          tvEpisodeID;
+    const uint32_t*      tvSeason;
+    const uint32_t*      tvEpisode;
 
-    const char* description;
-    const char* longDescription;
-    const char* lyrics;
+    const char*          description;
+    const char*          longDescription;
+    const char*          lyrics;
 
-    const char* sortName;
-    const char* sortArtist;
-    const char* sortAlbumArtist;
-    const char* sortAlbum;
-    const char* sortComposer;
-    const char* sortTVShow;
+    const char*          sortName;
+    const char*          sortArtist;
+    const char*          sortAlbumArtist;
+    const char*          sortAlbum;
+    const char*          sortComposer;
+    const char*          sortTVShow;
 
     const MP4TagArtwork* artwork;
     uint32_t             artworkCount;
 
-    const char* copyright;
-    const char* encodingTool;
-    const char* encodedBy;
-    const char* purchaseDate;
+    const char*          copyright;
+    const char*          encodingTool;
+    const char*          encodedBy;
+    const char*          purchaseDate;
 
-    const uint8_t* podcast;
-    const char*    keywords;  /* TODO: Needs testing */
-    const char*    category;    
+    const uint8_t*       podcast;
+    const char*          keywords;  /* TODO: Needs testing */
+    const char*          category;    
 
-    const uint8_t* hdVideo;
-    const uint8_t* mediaType;
-    const uint8_t* contentRating;
-    const uint8_t* gapless;
+    const uint8_t*       hdVideo;
+    const uint8_t*       mediaType;
+    const uint8_t*       contentRating;
+    const uint8_t*       gapless;
 
-    const char*     iTunesAccount;
-    const uint8_t*  iTunesAccountType;
-    const uint32_t* iTunesCountry;
-    const uint32_t* contentID;
-    const uint32_t* artistID;
-    const uint64_t* playlistID;
-    const uint32_t* genreID;
-    const uint32_t* composerID;
-    const char*     xid;
+    const char*          iTunesAccount;
+    const uint8_t*       iTunesAccountType;
+    const uint32_t*      iTunesCountry;
+    const uint32_t*      contentID;
+    const uint32_t*      artistID;
+    const uint64_t*      playlistID;
+    const uint32_t*      genreID;
+    const uint32_t*      composerID;
+    const char*          xid;
 } MP4Tags;
 
 /** Allocate tags convenience structure for reading and settings tags.
@@ -182,7 +203,9 @@ const MP4Tags* MP4TagsAlloc( void );
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
 MP4V2_EXPORT
-bool MP4TagsFetch( const MP4Tags* tags, MP4FileHandle hFile );
+bool MP4TagsFetch(
+    const MP4Tags* tags,
+    MP4FileHandle  hFile );
 
 /** Store data to mp4 file from structure.
  *
@@ -196,7 +219,9 @@ bool MP4TagsFetch( const MP4Tags* tags, MP4FileHandle hFile );
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
 MP4V2_EXPORT
-bool MP4TagsStore( const MP4Tags* tags, MP4FileHandle hFile );
+bool MP4TagsStore(
+    const MP4Tags* tags,
+    MP4FileHandle  hFile );
 
 /** Free tags convenience structure.
  *
@@ -205,7 +230,8 @@ bool MP4TagsStore( const MP4Tags* tags, MP4FileHandle hFile );
  *  @param tags structure to destroy.
  */
 MP4V2_EXPORT
-void MP4TagsFree( const MP4Tags* tags );
+void MP4TagsFree(
+    const MP4Tags* tags );
 
 /** Accessor that indicates whether a tags structure
  * contains any metadata
@@ -222,57 +248,59 @@ void MP4TagsFree( const MP4Tags* tags );
  * metadata
  */
 MP4V2_EXPORT
-bool MP4TagsHasMetadata ( const MP4Tags* tags, bool *hasMetadata );
+bool MP4TagsHasMetadata (
+    const MP4Tags* tags,
+    bool*          hasMetadata );
 
-MP4V2_EXPORT bool MP4TagsSetName            ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetArtist          ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetAlbumArtist     ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetAlbum           ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetGrouping        ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetComposer        ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetComments        ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetGenre           ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetGenreType       ( const MP4Tags*, const uint16_t* );
-MP4V2_EXPORT bool MP4TagsSetReleaseDate     ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetTrack           ( const MP4Tags*, const MP4TagTrack* );
-MP4V2_EXPORT bool MP4TagsSetDisk            ( const MP4Tags*, const MP4TagDisk* );
-MP4V2_EXPORT bool MP4TagsSetTempo           ( const MP4Tags*, const uint16_t* );
-MP4V2_EXPORT bool MP4TagsSetCompilation     ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetName              ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetArtist            ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetAlbumArtist       ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetAlbum             ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetGrouping          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetComposer          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetComments          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetGenre             ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetGenreType         ( const MP4Tags*, const uint16_t* );
+MP4V2_EXPORT bool MP4TagsSetReleaseDate       ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetTrack             ( const MP4Tags*, const MP4TagTrack* );
+MP4V2_EXPORT bool MP4TagsSetDisk              ( const MP4Tags*, const MP4TagDisk* );
+MP4V2_EXPORT bool MP4TagsSetTempo             ( const MP4Tags*, const uint16_t* );
+MP4V2_EXPORT bool MP4TagsSetCompilation       ( const MP4Tags*, const uint8_t* );
 
-MP4V2_EXPORT bool MP4TagsSetTVShow          ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetTVNetwork       ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetTVEpisodeID     ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetTVSeason        ( const MP4Tags*, const uint32_t* );
-MP4V2_EXPORT bool MP4TagsSetTVEpisode       ( const MP4Tags*, const uint32_t* );
+MP4V2_EXPORT bool MP4TagsSetTVShow            ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetTVNetwork         ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetTVEpisodeID       ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetTVSeason          ( const MP4Tags*, const uint32_t* );
+MP4V2_EXPORT bool MP4TagsSetTVEpisode         ( const MP4Tags*, const uint32_t* );
 
-MP4V2_EXPORT bool MP4TagsSetDescription     ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetLongDescription ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetLyrics          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetDescription       ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetLongDescription   ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetLyrics            ( const MP4Tags*, const char* );
 
-MP4V2_EXPORT bool MP4TagsSetSortName        ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetSortArtist      ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetSortAlbumArtist ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetSortAlbum       ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetSortComposer    ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetSortTVShow      ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortName          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortArtist        ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortAlbumArtist   ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortAlbum         ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortComposer      ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetSortTVShow        ( const MP4Tags*, const char* );
 
-MP4V2_EXPORT bool MP4TagsAddArtwork         ( const MP4Tags*, MP4TagArtwork* );
-MP4V2_EXPORT bool MP4TagsSetArtwork         ( const MP4Tags*, uint32_t, MP4TagArtwork* );
-MP4V2_EXPORT bool MP4TagsRemoveArtwork      ( const MP4Tags*, uint32_t );
+MP4V2_EXPORT bool MP4TagsAddArtwork           ( const MP4Tags*, MP4TagArtwork* );
+MP4V2_EXPORT bool MP4TagsSetArtwork           ( const MP4Tags*, uint32_t, MP4TagArtwork* );
+MP4V2_EXPORT bool MP4TagsRemoveArtwork        ( const MP4Tags*, uint32_t );
 
-MP4V2_EXPORT bool MP4TagsSetCopyright       ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetEncodingTool    ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetEncodedBy       ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetPurchaseDate    ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetCopyright         ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetEncodingTool      ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetEncodedBy         ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetPurchaseDate      ( const MP4Tags*, const char* );
 
-MP4V2_EXPORT bool MP4TagsSetPodcast         ( const MP4Tags*, const uint8_t* );
-MP4V2_EXPORT bool MP4TagsSetKeywords        ( const MP4Tags*, const char* );
-MP4V2_EXPORT bool MP4TagsSetCategory        ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetPodcast           ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetKeywords          ( const MP4Tags*, const char* );
+MP4V2_EXPORT bool MP4TagsSetCategory          ( const MP4Tags*, const char* );
 
-MP4V2_EXPORT bool MP4TagsSetHDVideo         ( const MP4Tags*, const uint8_t* );
-MP4V2_EXPORT bool MP4TagsSetMediaType       ( const MP4Tags*, const uint8_t* );
-MP4V2_EXPORT bool MP4TagsSetContentRating   ( const MP4Tags*, const uint8_t* );
-MP4V2_EXPORT bool MP4TagsSetGapless         ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetHDVideo           ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetMediaType         ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetContentRating     ( const MP4Tags*, const uint8_t* );
+MP4V2_EXPORT bool MP4TagsSetGapless           ( const MP4Tags*, const uint8_t* );
 
 MP4V2_EXPORT bool MP4TagsSetITunesAccount     ( const MP4Tags*, const char* );
 MP4V2_EXPORT bool MP4TagsSetITunesAccountType ( const MP4Tags*, const uint8_t* );
diff --git a/mp4v2/include/mp4v2/mp4v2.h b/mp4v2/include/mp4v2/mp4v2.h
index 4d8e807..301a044 100644
--- a/mp4v2/include/mp4v2/mp4v2.h
+++ b/mp4v2/include/mp4v2/mp4v2.h
@@ -15,17 +15,11 @@
  * Portions created by Cisco Systems Inc. are
  * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
  *
- * 3GPP features implementation is based on 3GPP's TS26.234-v5.60,
- * and was contributed by Ximpo Group Ltd.
- *
- * Portions created by Ximpo Group Ltd. are
- * Copyright (C) Ximpo Group Ltd. 2003, 2004.  All Rights Reserved.
- *
  * Contributor(s):
- *      Dave Mackie                 dmackie@cisco.com
- *      Alix Marchandise-Franquet   alix@cisco.com
- *      Ximpo Group Ltd.            mp4v2@ximpo.com
- *      Bill May                    wmay@cisco.com
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
  */
 #ifndef MP4V2_MP4V2_H
 #define MP4V2_MP4V2_H
diff --git a/mp4v2/include/mp4v2/platform.h b/mp4v2/include/mp4v2/platform.h
index 95f0d13..a3c63c3 100644
--- a/mp4v2/include/mp4v2/platform.h
+++ b/mp4v2/include/mp4v2/platform.h
@@ -1,3 +1,23 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MP4v2.
+ *
+ * The Initial Developer of the Original Code is Kona Blend.
+ * Portions created by Kona Blend are Copyright (C) 2008.
+ * All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Kona Blend, kona8lend@gmail.com
+ */
 #ifndef MP4V2_PLATFORM_H
 #define MP4V2_PLATFORM_H
 
@@ -6,27 +26,9 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <stdarg.h>
+#include <stdint.h>
 
-// Thanks, MSFT, for making C99 a total PITA.  Declare this not to define any stdint stuff; this is useful
-// if you're going to be using mp4v2 on windows with some other library that defines its own stdint.
-// The 1600 version check is for Visual Studio 2010 which has stdint once again.
-#ifndef MP4V2_NO_STDINT_DEFS
-    #if defined( _WIN32 ) && !defined( __MINGW32__ ) && !(defined(_MSC_VER) && _MSC_VER >= 1600)
-        typedef char      int8_t;
-        typedef short     int16_t;
-        typedef int       int32_t;
-        typedef long long int64_t;
-
-        typedef unsigned char      uint8_t;
-        typedef unsigned short     uint16_t;
-        typedef unsigned int       uint32_t;
-        typedef unsigned long long uint64_t;
-    #else
-        #include <stdint.h>
-    #endif
-#endif
-
-#if defined( _WIN32 ) && !defined( __MINGW32__ )
+#if defined( _WIN32 ) || defined( __MINGW32__ )
 #   if defined( MP4V2_EXPORTS )
 #       define MP4V2_EXPORT __declspec(dllexport)
 #   elif defined( MP4V2_USE_DLL_IMPORT ) || !defined( MP4V2_USE_STATIC_LIB )
diff --git a/mp4v2/include/mp4v2/project.h.in b/mp4v2/include/mp4v2/project.h.in
index 59777c6..72b442d 100644
--- a/mp4v2/include/mp4v2/project.h.in
+++ b/mp4v2/include/mp4v2/project.h.in
@@ -10,20 +10,14 @@
 #define MP4V2_PROJECT_url_website     "@PROJECT_url_website@"
 #define MP4V2_PROJECT_url_downloads   "@PROJECT_url_downloads@"
 #define MP4V2_PROJECT_url_discussion  "@PROJECT_url_discussion@"
-#define MP4V2_PROJECT_irc             "@PROJECT_irc@"
-#define MP4V2_PROJECT_bugreport       "@PROJECT_bugreport@"
+#define MP4V2_PROJECT_url_bugreport   "@PROJECT_url_bugreport@"
+#define MP4V2_PROJECT_support         "@PROJECT_support@"
 #define MP4V2_PROJECT_version         "@PROJECT_version@"
 #define MP4V2_PROJECT_version_hex     @PROJECT_version_hex@
 #define MP4V2_PROJECT_version_major   @PROJECT_version_major@
 #define MP4V2_PROJECT_version_minor   @PROJECT_version_minor@
 #define MP4V2_PROJECT_version_point   @PROJECT_version_point@
 #define MP4V2_PROJECT_repo_url        "@PROJECT_repo_url@"
-#define MP4V2_PROJECT_repo_branch     "@PROJECT_repo_branch@"
-#define MP4V2_PROJECT_repo_root       "@PROJECT_repo_root@"
-#define MP4V2_PROJECT_repo_uuid       "@PROJECT_repo_uuid@"
-#define MP4V2_PROJECT_repo_rev        @PROJECT_repo_rev@
-#define MP4V2_PROJECT_repo_date       "@PROJECT_repo_date@"
-#define MP4V2_PROJECT_repo_type       "@PROJECT_repo_type@"
 #define MP4V2_PROJECT_build           "@PROJECT_build@"
 
 /*****************************************************************************/
diff --git a/mp4v2/include/mp4v2/sample.h b/mp4v2/include/mp4v2/sample.h
index ba35a57..55e7272 100644
--- a/mp4v2/include/mp4v2/sample.h
+++ b/mp4v2/include/mp4v2/sample.h
@@ -1,3 +1,26 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ */
 #ifndef MP4V2_SAMPLE_H
 #define MP4V2_SAMPLE_H
 
@@ -37,13 +60,13 @@ typedef enum MP4SampleDependencyType_e {
  *  *ppBytes to the buffer it wishes to use. The calling application is
  *  responsible for ensuring that the buffer is large enough to hold the
  *  sample. This can be done by using either MP4GetSampleSize() or
- *  MP4GetTrackMaxSampleSize() to determine before-hand how large the
+ *  MP4GetTrackMaxSampleSize() to determine beforehand how large the
  *  receiving buffer must be.
  *
  *  If the value of *ppBytes is NULL, then an appropriately sized buffer is
- *  automatically malloc'ed for the sample data and *ppBytes set to this
- *  pointer. The calling application is responsible for free'ing this
- *  memory.
+ *  automatically allocated for the sample data and *ppBytes set to this
+ *  pointer. The calling application is responsible for freeing this memory
+ *  with MP4Free().
  *
  *  The last four arguments are pointers to variables that can receive
  *  optional sample information.
@@ -81,8 +104,8 @@ typedef enum MP4SampleDependencyType_e {
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  *
- *  @see MP4GetSampleSize().
- *  @see MP4GetTrackMaxSampleSize().
+ *  @see MP4GetSampleSize()
+ *  @see MP4GetTrackMaxSampleSize()
  */
 MP4V2_EXPORT
 bool MP4ReadSample(
@@ -91,8 +114,8 @@ bool MP4ReadSample(
     MP4TrackId    trackId,
     MP4SampleId   sampleId,
     /* input/output parameters */
-    uint8_t** ppBytes,
-    uint32_t* pNumBytes,
+    uint8_t**     ppBytes,
+    uint32_t*     pNumBytes,
     /* output parameters */
     MP4Timestamp* pStartTime DEFAULT(NULL),
     MP4Duration*  pDuration DEFAULT(NULL),
@@ -113,13 +136,13 @@ bool MP4ReadSample(
  *  *ppBytes to the buffer it wishes to use. The calling application is
  *  responsible for ensuring that the buffer is large enough to hold the
  *  sample. This can be done by using either MP4GetSampleSize() or
- *  MP4GetTrackMaxSampleSize() to determine before-hand how large the
+ *  MP4GetTrackMaxSampleSize() to determine beforehand how large the
  *  receiving buffer must be.
  *
  *  If the value of *ppBytes is NULL, then an appropriately sized buffer is
- *  automatically malloc'ed for the sample data and *ppBytes set to this
- *  pointer. The calling application is responsible for free'ing this
- *  memory.
+ *  automatically allocated for the sample data and *ppBytes set to this
+ *  pointer. The calling application is responsible for freeing this memory
+ *  with MP4Free().
  *
  *  The last four arguments are pointers to variables that can receive
  *  optional sample information.
@@ -157,10 +180,10 @@ bool MP4ReadSample(
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  *
- *  @see MP4ReadSample().
- *  @see MP4GetSampleIdFromTime().
- *  @see MP4GetSampleSize().
- *  @see MP4GetTrackMaxSampleSize().
+ *  @see MP4ReadSample()
+ *  @see MP4GetSampleIdFromTime()
+ *  @see MP4GetSampleSize()
+ *  @see MP4GetTrackMaxSampleSize()
  */
 MP4V2_EXPORT
 bool MP4ReadSampleFromTime(
@@ -169,8 +192,8 @@ bool MP4ReadSampleFromTime(
     MP4TrackId    trackId,
     MP4Timestamp  when,
     /* input/output parameters */
-    uint8_t** ppBytes,
-    uint32_t* pNumBytes,
+    uint8_t**     ppBytes,
+    uint32_t*     pNumBytes,
     /* output parameters */
     MP4Timestamp* pStartTime DEFAULT(NULL),
     MP4Duration*  pDuration DEFAULT(NULL),
@@ -212,7 +235,7 @@ bool MP4ReadSampleFromTime(
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  *
- *  @see MP4AddTrack().
+ *  @see MP4AddTrack()
  */
 MP4V2_EXPORT
 bool MP4WriteSample(
@@ -226,11 +249,11 @@ bool MP4WriteSample(
 
 /** Write a track sample and supply dependency information.
  *
- *  MP4WriteSampleDependency writes the given sample at the end of the specified track.
- *  Currently the library does not support random insertion of samples into
- *  the track timeline. Note that with mp4 there cannot be any holes or
- *  overlapping samples in the track timeline. The last three arguments give
- *  optional sample information.
+ *  MP4WriteSampleDependency writes the given sample at the end of the
+ *  specified track. Currently the library does not support random insertion of
+ *  samples into the track timeline. Note that with mp4 there cannot be any
+ *  holes or overlapping samples in the track timeline. The last three
+ *  arguments give optional sample information.
  *
  *  The value of duration can be given as #MP4_INVALID_DURATION if all samples
  *  in the track have the same duration. This can be specified with
@@ -260,7 +283,7 @@ bool MP4WriteSample(
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  *
- *  @see MP4AddTrack().
+ *  @see MP4AddTrack()
  */
 MP4V2_EXPORT
 bool MP4WriteSampleDependency(
@@ -277,11 +300,11 @@ bool MP4WriteSampleDependency(
  *
  *  MP4CopySample creates a new sample based on an existing sample. Note that
  *  another copy of the media sample data is created in the file using this
- *  function. ie. this call is equivalent to MP4ReadSample() followed by
+ *  function. I.e. this call is equivalent to MP4ReadSample() followed by
  *  MP4WriteSample().
  *
  *  Note that is the responsibility of the caller to ensure that the copied
- *  media sample makes sense in the destination track. eg. copying a video
+ *  media sample makes sense in the destination track, e.g. copying a video
  *  sample to an audio track is unlikely to result in anything good happening,
  *  even copying a sample from video track to another requires that the tracks
  *  use the same encoding and that issues such as image size are addressed.
@@ -302,8 +325,8 @@ bool MP4WriteSampleDependency(
  *  @return On success, thew id of the new sample.
  *      On error, #MP4_INVALID_SAMPLE_ID.
  *
- *  @see MP4ReadSample().
- *  @see MP4WriteSample().
+ *  @see MP4ReadSample()
+ *  @see MP4WriteSample()
  */
 MP4V2_EXPORT
 bool MP4CopySample(
@@ -337,7 +360,7 @@ bool MP4CopySample(
  *  @return On success, thew id of the new sample.
  *      On error, #MP4_INVALID_SAMPLE_ID.
  *
- *  @see MP4CopySample().
+ *  @see MP4CopySample()
  */
 MP4V2_EXPORT
 bool MP4EncAndCopySample(
@@ -389,7 +412,7 @@ uint32_t MP4GetSampleSize(
  *
  *  @return On success, the maximum sample size in bytes. On error, <b>0</b>.
  *
- *  @see MP4GetSampleSize().
+ *  @see MP4GetSampleSize()
  */
 MP4V2_EXPORT
 uint32_t MP4GetTrackMaxSampleSize(
@@ -412,6 +435,9 @@ uint32_t MP4GetTrackMaxSampleSize(
  *  be the case for a player that is implementing a positioning function and
  *  needs to be able to start decoding a track from the returned sample id.
  *
+ *  See MP4ConvertToTrackTimestamp() for how to map a time value to this
+ *  timescale.
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
  *  @param when time in track timescale.
@@ -421,8 +447,7 @@ uint32_t MP4GetTrackMaxSampleSize(
  *  @return On success, the sample id that occurs at the specified time.
  *      On error, #MP4_INVALID_SAMPLE_ID.
  *
- *  @see MP4ConvertToTrackTimestamp() for how to map a time value to this
- *      timescale.
+ *  @see MP4ConvertToTrackTimestamp()
  */
 MP4V2_EXPORT
 MP4SampleId MP4GetSampleIdFromTime(
@@ -436,6 +461,9 @@ MP4SampleId MP4GetSampleIdFromTime(
  *  MP4GetSampleTime returns the start time of the specified sample from
  *  the specified track in the track timescale units.
  *
+ *  See MP4ConvertFromTrackTimestamp() for how to map this value to another
+ *      timescale.
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
  *  @param sampleId id of sample for operation. Caveat: the first sample has
@@ -444,8 +472,7 @@ MP4SampleId MP4GetSampleIdFromTime(
  *  @return On success, sample start time in track timescale units.
  *      On error, #MP4_INVALID_TIMESTAMP.
  *
- *  @see MP4ConvertFromTrackTimestamp() for how to map this value to another
- *      timescale.
+ *  @see MP4ConvertFromTrackTimestamp()
  */
 MP4V2_EXPORT
 MP4Timestamp MP4GetSampleTime(
@@ -458,6 +485,9 @@ MP4Timestamp MP4GetSampleTime(
  *  MP4GetSampleDuration returns the duration of the specified sample from
  *  the specified track in the track timescale units.
  *
+ *  See MP4ConvertFromTrackDuration() for how to map this value to another
+ *      timescale.
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
  *  @param sampleId id of sample for operation. Caveat: the first sample has
@@ -466,8 +496,7 @@ MP4Timestamp MP4GetSampleTime(
  *  @return On success, the sample duration in track timescale units.
  *      On error, #MP4_INVALID_DURATION.
  *
- *  @see MP4ConvertFromTrackDuration() for how to map this value to another
- *      timescale.
+ *  @see MP4ConvertFromTrackDuration()
  */
 MP4V2_EXPORT
 MP4Duration MP4GetSampleDuration(
@@ -492,6 +521,9 @@ MP4Duration MP4GetSampleDuration(
  *  decoded, the start time plus the rendering offset indicates when it
  *  should be rendered.
  *
+ *  See MP4ConvertFromTrackDuration() for how to map this value to another
+ *      timescale.
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
  *  @param sampleId id of sample for operation. Caveat: the first sample has
@@ -500,8 +532,7 @@ MP4Duration MP4GetSampleDuration(
  *  @return On success, the rendering offset in track timescale units.
  *      On error, #MP4_INVALID_DURATION.
  *
- *  @see MP4ConvertFromTrackDuration() for how to map this value to another
- *      timescale.
+ *  @see MP4ConvertFromTrackDuration()
  */
 MP4V2_EXPORT
 MP4Duration MP4GetSampleRenderingOffset(
@@ -514,6 +545,10 @@ MP4Duration MP4GetSampleRenderingOffset(
  *  MP4SetSampleRenderingOffset sets the rendering offset of the specified
  *  sample from the specified track in the track timescale units.
  *
+ *  See MP4ConvertToTrackDuration() for how to map this value from another
+ *  timescale and MP4GetSampleRenderingOffset() for a description of this
+ *  sample property.
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
  *  @param sampleId id of sample for operation. Caveat: the first sample has
@@ -522,10 +557,8 @@ MP4Duration MP4GetSampleRenderingOffset(
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  *
- *  @see MP4ConvertToTrackDuration() for how to map this value from another
- *      timescale.
- *  @see MP4GetSampleRenderingOffset() for a description of this sample
- *      property.
+ *  @see MP4ConvertToTrackDuration()
+ *  @see MP4GetSampleRenderingOffset()
  */
 MP4V2_EXPORT
 bool MP4SetSampleRenderingOffset(
@@ -552,6 +585,6 @@ int8_t MP4GetSampleSync(
     MP4TrackId    trackId,
     MP4SampleId   sampleId );
 
-/* @} ***********************************************************************/
+/** @} ***********************************************************************/
 
 #endif /* MP4V2_SAMPLE_H */
diff --git a/mp4v2/include/mp4v2/streaming.h b/mp4v2/include/mp4v2/streaming.h
index 36389d6..6fc3ed8 100644
--- a/mp4v2/include/mp4v2/streaming.h
+++ b/mp4v2/include/mp4v2/streaming.h
@@ -1,3 +1,26 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Robert Kausch,             robert.kausch@freac.org
+ */
 #ifndef MP4V2_STREAMING_H
 #define MP4V2_STREAMING_H
 
@@ -8,6 +31,40 @@
  *
  *****************************************************************************/
 
+/** Get the RTP payload parameters of the hint track.
+ *
+ *  MP4GetHintTrackRtpPayload gets the RTP payload parameters for the hint
+ *  track. The RTP payload is the set of rules by which media samples are
+ *  packed into RTP packets. This call is typically used in constructing the
+ *  SDP media level description for the hint track.
+ *
+ *  The payloadName identifies which RTP payload is being used for the RTP
+ *  packets created from the hint track. This value is sent to the receiver in
+ *  the SDP description. For example, MP3 audio sent according to the rules in
+ *  IETF RFC 2250 uses the name "MPA" for the RTP payload.
+ *
+ *  The payloadNumber is a shorter form of the payloadName. This value is
+ *  associated with the payload name in the SDP description and then sent in
+ *  every RTP packet. Payload numbers 1 thru 95 are statically assigned in IETF
+ *  RFC 1890, numbers 96 thru 127 are dynamically assigned within a session.
+ *
+ *  The maxPayloadSize specifies the maximum number of bytes that should be
+ *  placed in the RTP payload section of the RTP packets.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param ppPayloadName specifies a pointer to the variable to receive the
+ *      string RTP payload name.
+ *  @param pPayloadNumber specifies a pointer to the variable to receive the
+ *      RTP payload number.
+ *  @param pMaxPayloadSize specifies a pointer to the variable to receive the
+ *      maximum RTP payload size in bytes.
+ *  @param ppEncodingParams
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4SetHintTrackRtpPayload()
+ */
 MP4V2_EXPORT
 bool MP4GetHintTrackRtpPayload(
     MP4FileHandle hFile,
@@ -19,6 +76,56 @@ bool MP4GetHintTrackRtpPayload(
 
 #define MP4_SET_DYNAMIC_PAYLOAD 0xff
 
+/** Set the RTP payload parameters of the hint track.
+ *
+ *  MP4SetHintTrackRtpPayload sets the RTP payload parameters for the hint
+ *  track. The RTP payload is the set of rules by which media samples are
+ *  packed into RTP packets.
+ *
+ *  The payload name identifies which RTP payload is being used for the RTP
+ *  packets created from the hint track. This value is sent to the receiver in
+ *  the SDP description. For example, MP3 audio sent according to the rules in
+ *  IETF RFC 2250 uses the name "MPA" for the RTP payload.
+ *
+ *  The payload number is a shorter form of the payload name. This value is
+ *  associated with the payload name in the SDP description and then sent in
+ *  every RTP packet. Payload numbers 1 thru 95 are statically assigned in IETF
+ *  RFC 1890, numbers 96 thru 127 are dynamically assigned within a session. If
+ *  the RTP payload in use is one of the statically assigned ones, you should
+ *  pass this value to the library. If you need a dynamic payload number
+ *  assigned, pass the define value MP4_SET_DYNAMIC_PAYLOAD for this parameter
+ *  and the library will choose an valid available number and return this
+ *  value.
+ *
+ *  The maxPayloadSize specifies the maximum number of bytes that should be
+ *  placed in the RTP payload section of the RTP packets. It is desirable that
+ *  RTP packets not exceed the maximum transmission unit (MTU) of the IP
+ *  network they travel over since otherwise the packets must be fragmented at
+ *  the IP level which consumes router resources and can lead to less robust
+ *  behavior in the face of packet loss.
+ *
+ *  The default value for maxPayloadSize is 1460, which is the MTU for an
+ *  Ethernet or similar network minus the standard sizes of the IP, UDP, and
+ *  RTP headers (1500 - 20 - 8 - 12 = 1460).
+ *
+ *  If you anticipate streaming over IP networks with smaller MTU sizes, or
+ *  that extensions to the network headers might be used, a more conservative
+ *  value should be chosen. The minimum MTU for an IP network is 576 bytes.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param pPayloadName specifies the RTP payload name.
+ *  @param pPayloadNumber specifies a pointer to the RTP payload number.
+ *  @param maxPayloadSize specifies the maximum RTP payload size in bytes.
+ *  @param encode_params
+ *  @param include_rtp_map specifies if the a=rtpmap statement is included.
+ *  @param include_mpeg4_esid specifies if the a=mpeg4-esid statement is
+ *      included.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetHintTrackRtpPayload()
+ */
 MP4V2_EXPORT
 bool MP4SetHintTrackRtpPayload(
     MP4FileHandle hFile,
@@ -30,42 +137,176 @@ bool MP4SetHintTrackRtpPayload(
     bool          include_rtp_map DEFAULT(true),
     bool          include_mpeg4_esid DEFAULT(true) );
 
+/** Get the SDP session level description of the file.
+ *
+ *  MP4GetSessionSdp returns the SDP (IETF RFC 2327) session level fragment for
+ *  the file. This is used by a streaming server to create a complete SDP
+ *  description of the multimedia session represented by the file.
+ *
+ *  The mp4broadcaster test program provided with the MP4v2 library gives an
+ *  example of using this call to create the complete SDP description.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *
+ *  @return The SDP session level description fragment of the mp4 file.
+ *
+ *  @see MP4SetSessionSdp()
+ *  @see MP4AppendSessionSdp()
+ *  @see MP4GetHintTrackSdp()
+ */
 MP4V2_EXPORT
 const char* MP4GetSessionSdp(
     MP4FileHandle hFile );
 
+/** Set the SDP session level description of the file.
+ *
+ *  MP4SetSessionSdp sets the SDP (IETF RFC 2327) session level fragment for
+ *  the file. This is used by a streaming server to create a complete SDP
+ *  description of the multimedia session represented by the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param sdpString specifies the new value of the session SDP string.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetSessionSdp()
+ *  @see MP4AppendSessionSdp()
+ */
 MP4V2_EXPORT
 bool MP4SetSessionSdp(
     MP4FileHandle hFile,
     const char*   sdpString );
 
+/** Add to the SDP session level description of the file.
+ *
+ *  MP4AppendSessionSdp appends the specified string to the SDP (IETF RFC 2327)
+ *  session level fragment for the file. This is used by a streaming server to
+ *  create a complete SDP description of the multimedia session represented by
+ *  the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param sdpString specifies the addition to the session SDP string.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetSessionSdp()
+ *  @see MP4SetSessionSdp()
+ */
 MP4V2_EXPORT
 bool MP4AppendSessionSdp(
     MP4FileHandle hFile,
     const char*   sdpString );
 
+/** Get the SDP media level description associated with a hint track.
+ *
+ *  MP4GetHintTrackSdp returns the SDP (IETF RFC 2327) media level fragment
+ *  associated with the hint track. This is used by a streaming server to
+ *  create a complete SDP description of the multimedia session represented by
+ *  the file.
+ *
+ *  The mp4broadcaster test program provided with the MP4 library gives an
+ *  example of using this call to create the complete SDP description.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return SDP media level description fragment associated with the hint
+ *      track.
+ *
+ *  @see MP4SetHintTrackSdp()
+ *  @see MP4AppendHintTrackSdp()
+ *  @see MP4GetSessionSdp()
+ */
 MP4V2_EXPORT
 const char* MP4GetHintTrackSdp(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Set the SDP media level description of the hint track.
+ *
+ *  MP4SetHintTrackSdp sets the SDP (IETF RFC 2327) media level fragment for
+ *  the hint track. This is used by a streaming server to create a complete SDP
+ *  description of the multimedia session represented by the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param sdpString specifies the new value of the hint track SDP string.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetHintTrackSdp()
+ *  @see MP4AppendHintTrackSdp()
+ */
 MP4V2_EXPORT
 bool MP4SetHintTrackSdp(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
     const char*   sdpString );
 
+/** Add to the SDP media level description of the hint track.
+ *
+ *  MP4AppendHintTrackSdp appends the specified string to the SDP (IETF RFC
+ *  2327) media level fragment for the hint track. This is used by a streaming
+ *  server to create a complete SDP description of the multimedia session
+ *  represented by the file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param sdpString specifies the addition to the hint track SDP string.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetHintTrackSdp()
+ *  @see MP4AppendHintTrackSdp()
+ */
 MP4V2_EXPORT
 bool MP4AppendHintTrackSdp(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
     const char*   sdpString );
 
+/** Get the reference track id for a hint track.
+ *
+ *  MP4GetHintTrackReferenceTrackId gets the track id of the reference media
+ *  track associated with the specified hint track.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return Upon success, the track id of the reference media track. Upon an
+ *      error, MP4_INVALID_TRACK_ID.
+ *
+ *  @see MP4AddHintTrack()
+ */
 MP4V2_EXPORT
 MP4TrackId MP4GetHintTrackReferenceTrackId(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Read an RTP hint.
+ *
+ *  MP4ReadRtpHint reads the specified hint sample from the specified hint
+ *  track and enables subsequent calls to MP4ReadRtpPacket() to read the
+ *  individual RTP packets associated with this hint. If desired, the number of
+ *  RTP packets associated with this hint is returned.
+ *
+ *  Note that a hint track sample is just like any other track sample. I.e.
+ *  MP4ReadSample(), MP4GetSampleSize(), MP4GetSampleTime(), etc. are all
+ *  valid. The RTP specific functions are provided to interpret the information
+ *  contain in the hint track samples that give instructions on how to form the
+ *  actual RTP packets.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param hintSampleId specifies which hint sample is to be read. Caveat: the
+ *      first sample has id 1 not 0.
+ *  @param pNumPackets Pointer to variable that will be hold the number of
+ *      packets in the hint.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4ReadRtpPacket()
+ */
 MP4V2_EXPORT
 bool MP4ReadRtpHint(
     MP4FileHandle hFile,
@@ -73,23 +314,127 @@ bool MP4ReadRtpHint(
     MP4SampleId   hintSampleId,
     uint16_t*     pNumPackets DEFAULT(NULL) );
 
+/** Get the number of packets in an RTP hint.
+ *
+ *  MP4GetRtpHintNumberOfPackets returns the number of packets contained in the
+ *  current RTP hint as established by a call to MP4ReadRtpHint().
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return Upon success, the number of packets in the current RTP hint. Upon
+ *      an error, 0.
+ *
+ *  @see MP4ReadRtpHint()
+ */
 MP4V2_EXPORT
 uint16_t MP4GetRtpHintNumberOfPackets(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Get the B frame flag of an RTP packet.
+ *
+ *  MP4GetRtpPacketBFrame returns the state of the B Frame flag of an RTP
+ *  packet. See MP4AddRtpHint() for a description of this flag.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param packetIndex specifies the packet to which the operation applies.
+ *
+ *  @return Upon success, the state of the B frame flag for the specified
+ *      packet. Upon an error, -1.
+ *
+ *  @see MP4AddRtpHint()
+ *  @see MP4ReadRtpPacket()
+ */
 MP4V2_EXPORT
 int8_t MP4GetRtpPacketBFrame(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
     uint16_t      packetIndex );
 
+/** Get the transmit offset of an RTP packet.
+ *
+ *  MP4GetRtpPacketTransmitOffset returns the transmit offset of an RTP packet.
+ *  This offset may be set by some hinters to smooth out the packet
+ *  transmission times and reduce network burstiness. A transmitter would need
+ *  to apply this offset to the calculated transmission time based on the hint
+ *  start time.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param packetIndex specifies the packet to which the operation applies.
+ *
+ *  @return The transmit offset for the specified packet in the hint track
+ *      timescale.
+ *
+ *  @see MP4AddRtpHint()
+ *  @see MP4ReadRtpPacket()
+ */
 MP4V2_EXPORT
 int32_t MP4GetRtpPacketTransmitOffset(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
     uint16_t      packetIndex );
 
+/** Read an RTP packet.
+ *
+ *  MP4ReadRtpPacket reads the specified packet from the current hint sample,
+ *  as previously read by MP4ReadRtpHint().
+ *
+ *  The argument ppBytes allows for two possible approaches for buffering:
+ *
+ *  @li If the calling application wishes to handle its own buffering it can
+ *      set *ppBytes to the buffer it wishes to use. The calling application is
+ *      responsible for ensuring that the buffer is large enough to hold the
+ *      packet. This can be done by using MP4GetRtpPayload() to retrieve the
+ *      maximum packet payload size and hence how large the receiving buffer
+ *      must be. Caveat: the value returned by MP4GetRtpPayload() is the
+ *      maximum payload size, if the RTP packet header is going to be included
+ *      by the library this value should be incremented by 12.
+ *
+ *  @li If the value of *ppBytes is NULL, then an appropriately sized buffer is
+ *      automatically allocated for the sample data and *ppBytes set to this
+ *      pointer. The calling application is responsible for freeing this memory
+ *      with MP4Free().
+ *
+ *  The application is expected to provide the value of the RTP SSRC identifier
+ *  which uniquely identifies the originator of the media stream. For most
+ *  applications, a single random value can be provided. The value should be
+ *  the same for all packets for the duration of the RTP transmission. If the
+ *  parameter @p includeHeader is false, then this value has no effect.
+ *
+ *  By default the library constructs the standard 12 byte RTP header from the
+ *  information in the hint sample, and the specified SSRC. It then
+ *  concatenates the RTP header with the packet payload, that is the RTP
+ *  payload specific header and the media data for the packet. The @p
+ *  includeHeader and @p includePayload parameters allow control over these
+ *  steps, so that either just the packet payloads or just the RTP headers can
+ *  be returned. A potential use of this feature is if the calling application
+ *  wishes to construct an extended RTP header with non-standard options.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param packetIndex specifies which packet is to be read. Valid values range
+ *      from zero to the number of packets in this hint minus one.
+ *  @param ppBytes Pointer to the pointer to the packet data. See the function
+ *      description for details on this argument. 
+ *  @param pNumBytes Pointer to variable that will be hold the size in bytes of
+ *      the packet.
+ *  @param ssrc specifies the RTP SSRC to be used when constructing the RTP
+ *      packet header.
+ *  @param includeHeader specifies whether the library should include the
+ *      standard 12 byte RTP header to the returned packet. The header is
+ *      constructed from the information in the hint sample and the specified
+ *      ssrc.
+ *  @param includePayload specifies whether the library should include the
+ *      packet payload (RTP payload header and media data) in the returned
+ *      packet.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4ReadRtpHint()
+ */
 MP4V2_EXPORT
 bool MP4ReadRtpPacket(
     MP4FileHandle hFile,
@@ -101,36 +446,174 @@ bool MP4ReadRtpPacket(
     bool          includeHeader DEFAULT(true),
     bool          includePayload DEFAULT(true) );
 
+/** Get the RTP start time of a hint track.
+ *
+ *  MP4GetRtpTimestampStart returns the RTP timestamp start of the specified
+ *  hint track. Typically this is a random value that is chosen when the first
+ *  RTP packet is constructed by the MP4 library. However the value can be set
+ *  explicitly for the hint track and stored. Typically this is used if it is
+ *  desired that timestamps start at zero.
+ *
+ *  An application will need this value in order to construct RTCP Sender
+ *  Reports that relate the hint track time to an real time clock. The
+ *  mp4broadcaster test program provided with the MP4 library gives an example
+ *  of this.
+ *
+ *  See IETF RFC 1889 for details regarding RTP timestamps and RTCP.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return Upon success, the RTP start time in the RTP time scale which is
+ *      identical to the hint track time scale. Upon an error,
+ *      MP4_INVALID_TIMESTAMP.
+ *
+ *  @see MP4SetRtpTimestampStart()
+ */
 MP4V2_EXPORT
 MP4Timestamp MP4GetRtpTimestampStart(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Get the RTP start time of a hint track.
+ *
+ *  MP4SetRtpTimestampStart sets the RTP timestamp start of the specified hint
+ *  track. Typically this is a random value that is chosen when the first RTP
+ *  packet is constructed by the MP4 library. However the value can be set
+ *  explicitly for the hint track and stored. Typically this is used if it is
+ *  desired that timestamps start at zero.
+ *
+ *  See IETF RFC 1889 for details regarding RTP timestamps and RTCP.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param rtpStart specifies the desired RTP start timestamp for the hint
+ *      track.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetRtpTimestampStart()
+ */
 MP4V2_EXPORT
 bool MP4SetRtpTimestampStart(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
     MP4Timestamp  rtpStart );
 
+/** Add an RTP hint.
+ *
+ *  MP4AddRtpHint creates a new hint sample for the specified hint track and
+ *  enables subsequent calls to MP4AddRtpPacket() to create the RTP packets
+ *  associated with this hint. After all the RTP packets for the hint have been
+ *  created, MP4WriteRtpHint() should be called to write the hint to the track.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpPacket()
+ *  @see MP4WriteRtpHint()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpHint(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Add an RTP video specific hint.
+ *
+ *  MP4AddRtpVideoHint is an extended version of MP4AddRtpHint specifically to
+ *  handle MPEG video frames. 
+ *
+ *  The isBFrame parameter allows the packets in the RTP hint to be marked as
+ *  belonging to a video B frame. This can be useful to a streaming server if
+ *  packets must be dropped due to system load or network congestion. No other
+ *  video frames are dependent on the contents of B frames, so they are least
+ *  damaging type of frames to drop.
+ *
+ *  The timestampOffset parameter allows an offset to be added to the RTP
+ *  timestamp of the packets in the RTP hint. This is necessary for MPEG video
+ *  that contains B frames since the video frames are transmitted out of order
+ *  with respect to when they should be rendered. I.e. I and P frames are
+ *  transmitted before any B frames that depend on them. The RTP timestamp must
+ *  represent the rendering time of the data in the packets hence an offset
+ *  must be added.
+ *
+ *  Note: The timestampOffset is equivalent to the sample rendering offset of a
+ *  video media track. See MP4GetSampleRenderingOffset().
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param isBFrame specifies if this hint will contain packets for a video B
+ *      frame.
+ *  @param timestampOffset specifies a positive offset to add to the RTP
+ *      timestamp for this hint. Caveat: the value is in the hint track
+ *      timescale.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpHint()
+ *  @see MP4AddRtpPacket()
+ *  @see MP4WriteRtpHint()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpVideoHint(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
-    bool          isBframe DEFAULT(false),
+    bool          isBFrame DEFAULT(false),
     uint32_t      timestampOffset DEFAULT(0) );
 
+/** Add an RTP packet.
+ *
+ *  MP4AddRtpPacket creates a new RTP packet for the currently pending RTP hint
+ *  sample for the specified hint track. It also enables subsequent calls to
+ *  MP4AddRtpImmediateData() and MP4AddRtpSampleData to add data to the RTP
+ *  packets. After all the RTP packets for the hint have been created,
+ *  MP4WriteRtpHint() should be called to write the hint to the track.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param setMBit specifies the value of the RTP packet header marker bit for
+ *      this packet. The value depends on the rules of the RTP payload used for
+ *      this hint track.
+ *  @param transmitOffset specifies an offset to apply to the normal
+ *      transmission time of this packet. The purpose of this offset is to
+ *      allow smoothing of packet transmission over the duration of the hint.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpHint()
+ *  @see MP4AddRtpImmediateData()
+ *  @see MP4AddRtpSampleData()
+ *  @see MP4WriteRtpHint()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpPacket(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId,
-    bool          setMbit DEFAULT(false),
+    bool          setMBit DEFAULT(false),
     int32_t       transmitOffset DEFAULT(0) );
 
+/** Add immediate data to an RTP packet.
+ *
+ *  MP4AddRtpImmediateData adds immediate data to the current pending RTP
+ *  packet. Typically, this is used to add RTP payload specific headers to RTP
+ *  packets. Note that the size of a block of immediate data is limited to 14
+ *  bytes. But multiple immediate data blocks can be added if more space is
+ *  needed.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param pBytes specifies a pointer to the immediate data that should be
+ *      included in the current RTP packet.
+ *  @param numBytes specifies the length in bytes of the immediate data that
+ *      should be included in the current RTP packet.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpPacket()
+ *  @see MP4AddRtpSampleData()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpImmediateData(
     MP4FileHandle  hFile,
@@ -138,6 +621,26 @@ bool MP4AddRtpImmediateData(
     const uint8_t* pBytes,
     uint32_t       numBytes );
 
+/** Add media sample data to an RTP packet.
+ *
+ *  MP4AddRtpSampleData adds a reference in the current pending RTP packet to
+ *  the media data in the specified media sample of the reference media track.
+ *  Note this is a reference, not a copy, of the media data.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param sampleId specifies the reference media sample id from which the
+ *      media data should be taken.
+ *  @param dataOffset specifies the byte offset in the specified media sample
+ *      where data should be taken from for the current RTP packet.
+ *  @param dataLength specifies the length in bytes of the media data that
+ *      should be included in the current RTP packet.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpPacket()
+ *  @see MP4AddRtpImmediateData()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpSampleData(
     MP4FileHandle hFile,
@@ -146,11 +649,44 @@ bool MP4AddRtpSampleData(
     uint32_t      dataOffset,
     uint32_t      dataLength );
 
+/** Add ES configuration information to an RTP hint.
+ *
+ *  MP4AddRtpESConfigurationPacket adds a packet to the current RTP hint that
+ *  contains a copy of the elementary stream configuration information of the
+ *  reference media track. Some RTP payloads require this information to be
+ *  transmitted at the start of streaming or periodically during streaming.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4SetTrackESConfiguration()
+ */
 MP4V2_EXPORT
 bool MP4AddRtpESConfigurationPacket(
     MP4FileHandle hFile,
     MP4TrackId    hintTrackId );
 
+/** Write an RTP hint.
+ *
+ *  MP4WriteRtpHint writes the current pending hint created with
+ *  MP4AddRtpHint() to the specified hint track.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param hintTrackId specifies the hint track to which the operation applies.
+ *  @param duration specifies the duration for this hint sample. Typically this
+ *      is the same duration as for the corresponding sample in the reference
+ *      media track. Caveat: The duration should be in the hint track timescale
+ *      units, again typically the same as the reference media track.
+ *  @param isSyncSample specifies the sync/random access flag for this sample.
+ *      Typically this is the same as for the corresponding sample in the
+ *      reference media track.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4AddRtpHint()
+ */
 MP4V2_EXPORT
 bool MP4WriteRtpHint(
     MP4FileHandle hFile,
diff --git a/mp4v2/include/mp4v2/track.h b/mp4v2/include/mp4v2/track.h
index 90eb7bc..8686004 100644
--- a/mp4v2/include/mp4v2/track.h
+++ b/mp4v2/include/mp4v2/track.h
@@ -1,3 +1,26 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ */
 #ifndef MP4V2_TRACK_H
 #define MP4V2_TRACK_H
 
@@ -37,6 +60,7 @@ MP4TrackId MP4AddTrack(
  *  this should not be used to add OD or scene tracks, MP4AddODTrack() and
  *  MP4AddSceneTrack() should be used for those purposes. Other known
  *  MPEG-4 System track types are:
+ *
  *      @li #MP4_CLOCK_TRACK_TYPE
  *      @li #MP4_MPEG7_TRACK_TYPE
  *      @li #MP4_OCI_TRACK_TYPE
@@ -100,7 +124,7 @@ MP4TrackId MP4AddSceneTrack(
  *  can then be used to add the desired audio samples.
  *
  *  It is recommended that the time scale be set to the sampling frequency
- *  (eg. 44100 Hz) of the audio so as to preserve the timing information
+ *  (e.g. 44100 Hz) of the audio so as to preserve the timing information
  *  accurately.
  *
  *  If the audio encoding uses a fixed duration for each sample that should
@@ -138,7 +162,7 @@ MP4TrackId MP4AddAudioTrack(
 MP4V2_EXPORT
 MP4TrackId MP4AddULawAudioTrack(
     MP4FileHandle hFile,
-    uint32_t timeScale);
+    uint32_t      timeScale);
 
 /** Add alaw track to mp4 file.
  *
@@ -365,6 +389,28 @@ MP4TrackId MP4AddColr(
     uint16_t      transfer,
     uint16_t      matrix );
 
+/** Make a clone of a specified track.
+ *
+ *  MP4CloneTrack creates a new track to an mp4 file that is a copy of an
+ *  existing track with respect to the track media type, and other control
+ *  information. 
+ *
+ *  Note this function does not copy the media samples of the source track to
+ *  the new track. If you want to do that use MP4CopyTrack() instead.
+ *
+ *  @param srcFile specifies the mp4 file of the source track of the operation.
+ *  @param srcTrackId specifies the track id of the track to be cloned.
+ *  @param dstFile specifies the mp4 file of the new, cloned track. If the
+ *      value is MP4_INVALID_FILE_HANDLE, the new track is created in the same
+ *      file as the source track.
+ *  @param dstHintTrackReferenceTrack specifies the track id of the reference
+ *      track in the destination file when cloning a hint track.
+ *
+ *  @return Upon success, the track id of the new track. Upon an error,
+ *      MP4_INVALID_TRACK_ID.
+ *
+ *  @see MP4CopyTrack()
+ */
 MP4V2_EXPORT
 MP4TrackId MP4CloneTrack(
     MP4FileHandle srcFile,
@@ -372,6 +418,39 @@ MP4TrackId MP4CloneTrack(
     MP4FileHandle dstFile DEFAULT(MP4_INVALID_FILE_HANDLE),
     MP4TrackId    dstHintTrackReferenceTrack DEFAULT(MP4_INVALID_TRACK_ID) );
 
+/** Make a copy of a specified track.
+ *
+ *  MP4CopyTrack creates a new track to an mp4 file that is a copy of an
+ *  existing track with respect to the track media type, other control
+ *  information, and media samples.
+ *
+ *  The applyEdits parameter of this function allows for easy creation of
+ *  standalone clips from a larger mp4 file. To do this use MP4AddTrackEdit()
+ *  to specify the start and duration of the clip, and then use MP4CopyTrack()
+ *  to export that portion of the media to a new mp4 file.
+ *
+ *  Note if you do not want to copy the media samples, but just want to create
+ *  a track with the same type and control information of the source track use
+ *  MP4CloneTrack().
+ *
+ *  @param srcFile specifies the mp4 file of the source track of the operation.
+ *  @param srcTrackId specifies the track id of the track to be copied.
+ *  @param dstFile specifies the mp4 file of the new, copied track. If the
+ *      value is MP4_INVALID_FILE_HANDLE, the new track is created in the same
+ *      file as the source track.
+ *  @param applyEdits specifies if the track edit list is to be applied during
+ *      the copying of media samples. If false, then all samples are copied, if
+ *      true then only those samples included by the track edit list are
+ *      copied.
+ *  @param dstHintTrackReferenceTrack specifies the track id of the reference
+ *      track in the destination file when cloning a hint track.
+ *
+ *  @return Upon success, the track id of the new track. Upon an error,
+ *      MP4_INVALID_TRACK_ID.
+ *
+ *  @see MP4CloneTrack()
+ *  @see MP4AddTrackEdit()
+ */
 MP4V2_EXPORT
 MP4TrackId MP4CopyTrack(
     MP4FileHandle srcFile,
@@ -380,17 +459,90 @@ MP4TrackId MP4CopyTrack(
     bool          applyEdits DEFAULT(false),
     MP4TrackId    dstHintTrackReferenceTrack DEFAULT(MP4_INVALID_TRACK_ID) );
 
+/** Delete a track.
+ *
+ *  MP4DeleteTrack deletes the control information associated with the
+ *  specified track. The trackId will become invalid if this call succeeds.
+ * 
+ *  Note that the samples associated with this track are not deleted with this
+ *  call. This can be accomplished via MP4Optimize(). The reason for this is
+ *  that multiple tracks can reference the same samples so a global view must
+ *  be taken when deleting them.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ */
 MP4V2_EXPORT
 bool MP4DeleteTrack(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the number of tracks.
+ *
+ *  MP4GetNumberOfTracks returns how many tracks of the specified type and
+ *  subtype exist in the mp4 file. This can be used to determine if an mp4 file
+ *  contains a track of a given type of media, for instance audio or video. It
+ *  can also be used to determine if multiple options may be available. For
+ *  instance multiple audio tracks in different languages.
+ *
+ *  For audio and video tracks, a subtype can be specified to only count tracks
+ *  of a particular encoding.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param type specifies the type of track for which a count is desired. A
+ *      NULL value implies any type of track. See MP4GetTrackType() for
+ *      predefined values.
+ *  @param subType specifies the subtype of the tracks to be counted. Subtypes
+ *      are only defined for audio and video tracks, see
+ *      MP4GetTrackEsdsObjectTypeId() for predefined values. A zero value
+ *      implies any subtype.
+ *
+ *  @return The number of tracks of the specified type and subType in the mp4
+ *      file.
+ */
 MP4V2_EXPORT
 uint32_t MP4GetNumberOfTracks(
     MP4FileHandle hFile,
     const char*   type DEFAULT(NULL),
     uint8_t       subType DEFAULT(0) );
 
+/** Find a track id.
+ *
+ *  MP4FindTrackId gets the track id associated with the index'th track of the
+ *  specified track type. For example, to get the track id of the first video
+ *  track:
+ *
+ *  @code
+ *    MP4FindTrackId(hFile, 0, MP4_VIDEO_TRACK_TYPE);
+ *  @endcode
+ *
+ *  For audio and video tracks, a subtype can be specified to find a track of a
+ *  particular encoding. For example, to get the track id of the first audio
+ *  track encoded with MPEG-1 audio:
+ *
+ *  @code
+ *    MP4FindTrackId(hFile, 0, MP4_AUDIO_TRACK_TYPE, MP4_MPEG1_AUDIO_TYPE);
+ *  @endcode
+ *
+ *  Caveat: The track id's do not imply anything about the ordering of the
+ *  track information within the mp4 file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param index specifies which track is desired from matching tracks.
+ *  @param type specifies the type of track to be matched. A NULL value implies
+ *      any type of track. See MP4GetTrackType() for predefined values.
+ *  @param subType specifies the subtype of the track to be matched. Subtypes
+ *      are only defined for audio and video tracks, see
+ *      MP4GetTrackEsdsObjectTypeId() for predefined values. A zero value
+ *      implies any subtype.
+ *
+ *  @return Upon success, the track index of the specified track. Upon an
+ *      error, 0xFFFF.
+ *
+ *  @see MP4FindTrackIndex()
+ */
 MP4V2_EXPORT
 MP4TrackId MP4FindTrackId(
     MP4FileHandle hFile,
@@ -398,6 +550,18 @@ MP4TrackId MP4FindTrackId(
     const char*   type DEFAULT(NULL),
     uint8_t       subType DEFAULT(0) );
 
+/** Find a track index.
+ *
+ *  MP4FindTrackIndex gets the index of the track with the specified track id.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the index is desired.
+ *
+ *  @return Upon success, the track index of the specified track. Upon an
+ *      error, 0xFFFF.
+ *
+ *  @see MP4FindTrackId()
+ */
 MP4V2_EXPORT
 uint16_t MP4FindTrackIndex(
     MP4FileHandle hFile,
@@ -411,7 +575,7 @@ uint16_t MP4FindTrackIndex(
  *  @param trackId id of track for operation.
  *  @param duration out value of duration in track timescale units.
  *
- *  return <b>true</b> on success, <b>false</b> on failure.
+ *  @return <b>true</b> on success, <b>false</b> on failure.
  */
 MP4V2_EXPORT
 bool MP4GetTrackDurationPerChunk(
diff --git a/mp4v2/include/mp4v2/track_prop.h b/mp4v2/include/mp4v2/track_prop.h
index 4b3adf4..f15bf05 100644
--- a/mp4v2/include/mp4v2/track_prop.h
+++ b/mp4v2/include/mp4v2/track_prop.h
@@ -1,21 +1,39 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001 - 2005.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie,               dmackie@cisco.com
+ *      Alix Marchandise-Franquet, alix@cisco.com
+ *      Bill May,                  wmay@cisco.com
+ *      Kona Blend,                kona8lend@gmail.com
+ *      Robert Kausch,             robert.kausch@freac.org
+ */
 #ifndef MP4V2_TRACK_PROP_H
 #define MP4V2_TRACK_PROP_H
 
 /**************************************************************************//**
  *
- *  @defgroup mp4_track_prop MP4v2 Track Property
+ *  @defgroup mp4_track_prop MP4v2 Track Properties
  *  @{
  *
  *****************************************************************************/
 
 /* specific track properties */
 
-MP4V2_EXPORT
-bool MP4HaveTrackAtom(
-    MP4FileHandle hFile,
-    MP4TrackId    trackId,
-    const char*   atomname );
-
 /** Get the track type.
  *
  *  MP4GetTrackType gets the type of the track with the specified track id.
@@ -25,6 +43,7 @@ bool MP4HaveTrackAtom(
  *  MP4AddSystemsTrack(MP4_OCI_TRACK_TYPE).
  *
  *  Known track types are:
+ *
  *      @li #MP4_OD_TRACK_TYPE
  *      @li #MP4_SCENE_TRACK_TYPE
  *      @li #MP4_AUDIO_TRACK_TYPE
@@ -48,16 +67,40 @@ const char* MP4GetTrackType(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the name of the track's media data atom.
+ *
+ *  MP4GetTrackMediaDataName returns the four character name of the specified
+ *  track's media data atom, i.e. the child atom of the track's @b stsd atom.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the media data atom name is
+ *      desired.
+ *
+ *  @return The name of the track's media data atom or NULL in case of an
+ *      error.
+ */
 MP4V2_EXPORT
 const char* MP4GetTrackMediaDataName(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
-/*
- * MP4GetTrackMediaDataOriginalFormat is to be used to get the original
- * MediaDataName if a track has been encrypted.
+/** Get the name of an encrypted track's original media data atom.
+ *
+ *  MP4GetTrackMediaDataOriginalFormat is used to get the original media data
+ *  atom name if a track has been encrypted. The track identified by @p trackId
+ *  must be an encrypted track with @b encv as the media data name returned by
+ *  MP4GetTrackMediaDataName.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the encoded track for which the original media
+ *      data atom name is desired.
+ *  @param originalFormat specifies a buffer to receive the original media data
+        atom name.
+ *  @param buflen specifies the size of the buffer pointed to by @p
+ *      originalFormat.
+ *
+ *  @return <b>true</b> on success, <b>false</b> on failure.
  */
-
 MP4V2_EXPORT
 bool MP4GetTrackMediaDataOriginalFormat(
     MP4FileHandle hFile,
@@ -65,6 +108,19 @@ bool MP4GetTrackMediaDataOriginalFormat(
     char*         originalFormat,
     uint32_t      buflen );
 
+/** Get the duration of a track.
+ *
+ *  MP4GetTrackDuration returns the total duration of all the samples in the
+ *  specified track in the mp4 file.
+ *
+ *  Caveat: The value is in units of the track time scale.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the duration is desired.
+ *
+ *  @return The duration in track time scale units of the track in the mp4
+ *      file.
+ */
 MP4V2_EXPORT
 MP4Duration MP4GetTrackDuration(
     MP4FileHandle hFile,
@@ -100,7 +156,7 @@ uint32_t MP4GetTrackTimeScale(
  *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
- *  @param timeScale desired time scale for the track.
+ *  @param value desired time scale for the track.
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
@@ -144,8 +200,12 @@ bool MP4SetTrackLanguage(
  *
  *  MP4GetTrackName gets the name of the track via udta.name property.
  *
+ *  The memory to store the track name is allocated by the library, so the
+ *  caller is responsible for freeing it with MP4Free().
+ *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
+ *  @param name pointer to a variable to receive the track name.
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
@@ -162,6 +222,7 @@ bool MP4GetTrackName(
  *
  *  @param hFile handle of file for operation.
  *  @param trackId id of track for operation.
+ *  @param name the name to set as the track name.
  *
  *  @return <b>true</b> on success, <b>false</b> on failure.
  */
@@ -171,22 +232,122 @@ bool MP4SetTrackName(
     MP4TrackId    trackId,
     const char*   name );
 
+/** Get the encoding type of an MPEG-4 audio track.
+ *
+ *  MP4GetTrackAudioMpeg4Type returns the MPEG-4 encoding type of the specified
+ *  MPEG-4 audio track in the mp4 file. If an mp4 audio track has type
+ *  MP4_MPEG4_AUDIO_TYPE, this call can be used to determine which specific
+ *  MPEG-4 audio encoding is contained in the track.
+ *
+ *  Known MPEG-4 audio encoding types are:
+ *
+ *  Type                                | Description
+ *  ------------------------------------|--------------------------------------
+ *  MP4_MPEG4_AAC_MAIN_AUDIO_TYPE       | MPEG-4 AAC Main profile
+ *  MP4_MPEG4_AAC_LC_AUDIO_TYPE         | MPEG-4 AAC Low Complexity profile
+ *  MP4_MPEG4_AAC_SSR_AUDIO_TYPE        | MPEG-4 AAC SSR profile
+ *  MP4_MPEG4_AAC_LTP_AUDIO_TYPE        | MPEG-4 AAC Long Term Prediction profile
+ *  MP4_MPEG4_AAC_SCALABLE_AUDIO_TYPE   | MPEG-4 AAC Scalable
+ *  MP4_MPEG4_CELP_AUDIO_TYPE           | MPEG-4 CELP
+ *  MP4_MPEG4_HVXC_AUDIO_TYPE           | MPEG-4 HVXC
+ *  MP4_MPEG4_TTSI_AUDIO_TYPE           | MPEG-4 Text To Speech
+ *  MP4_MPEG4_MAIN_SYNTHETIC_AUDIO_TYPE | MPEG-4 Main Synthetic profile
+ *  MP4_MPEG4_WAVETABLE_AUDIO_TYPE      | MPEG-4 Wavetable Synthesis profile
+ *  MP4_MPEG4_MIDI_AUDIO_TYPE           | MPEG-4 MIDI profile
+ *  MP4_MPEG4_ALGORITHMIC_FX_AUDIO_TYPE | MPEG-4 Algorithmic Synthesis and Audio FX profile
+ *
+ *  Note: This information is retrieved from the audio track ES configuration.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the MPEG-4 audio type is
+ *      desired.
+ *
+ *  @return Upon success, the MPEG-4 audio type of the track. Upon error,
+ *      MP4_MPEG4_INVALID_AUDIO_TYPE is returned.
+ *
+ *  @see MP4GetTrackAudioType()
+ */
 MP4V2_EXPORT
 uint8_t MP4GetTrackAudioMpeg4Type(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the encoding object type id from a track's esds atom.
+ *
+ *  MP4GetTrackEsdsObjectTypeId returns the encoding object type of the
+ *  specified audio or video track in the mp4 file.
+ *
+ *  Known audio object types are:
+ *
+ *  Type                          | Description
+ *  ------------------------------|--------------------------------------------
+ *  MP4_MPEG1_AUDIO_TYPE          | MPEG-1 Audio Layers I, II, & III
+ *  MP4_MPEG2_AUDIO_TYPE          | MPEG-2 low bitrate extensions to MPEG-1 Audio
+ *  ^                             | MP4_MP3_AUDIO_TYPE is an alias for this value
+ *  MP4_MPEG2_AAC_MAIN_AUDIO_TYPE | MPEG-2 AAC Main profile
+ *  MP4_MPEG2_AAC_LC_AUDIO_TYPE   | MPEG-2 AAC Low Complexity profile
+ *  MP4_MPEG2_AAC_SSR_AUDIO_TYPE  | MPEG-2 AAC SSR profile
+ *  MP4_MPEG4_AUDIO_TYPE          | MPEG-4 Audio, includes MPEG-4 extensions to AAC
+ *  MP4_PRIVATE_AUDIO_TYPE        | User private type
+ *
+ *  Known video object types are:
+ *
+ *  Type                         | Description
+ *  -----------------------------|---------------------------------------------
+ *  MP4_MPEG1_VIDEO_TYPE         | MPEG-1 Video
+ *  MP4_MPEG2_SIMPLE_VIDEO_TYPE  | MPEG-2 Simple Profile Video
+ *  MP4_MPEG2_MAIN_VIDEO_TYPE    | MPEG-2 Main Profile Video (Broadcast/DVD)
+ *  MP4_MPEG2_SNR_VIDEO_TYPE     | MPEG-2 SNR Profile Video
+ *  MP4_MPEG2_SPATIAL_VIDEO_TYPE | MPEG-2 Spatial Scalability Profile Video
+ *  MP4_MPEG2_HIGH_VIDEO_TYPE    | MPEG-2 High Profile Video (HDTV)
+ *  MP4_MPEG2_442_VIDEO_TYPE     | MPEG-2 442 Profile Video (Studio)
+ *  MP4_MPEG4_VIDEO_TYPE         | MPEG-4 Video
+ *  MP4_JPEG_VIDEO_TYPE          | JPEG stills or motion JPEG
+ *  MP4_PRIVATE_VIDEO_TYPE       | User private type
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the encoding object type is
+ *      desired.
+ *
+ *  @return Upon success, the encoding object type of the track. Upon error,
+ *      MP4_INVALID_AUDIO_TYPE is returned.
+ */
 MP4V2_EXPORT
 uint8_t MP4GetTrackEsdsObjectTypeId(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
-/* returns MP4_INVALID_DURATION if track samples do not have a fixed duration */
+/** Get the fixed duration of samples in a track.
+ *
+ *  MP4GetTrackFixedSampleDuration returns the duration of samples in the
+ *  specified track in the mp4 file, if this value is fixed for all samples.
+ *  This is typically the case for audio tracks and video tracks. If the track
+ *  samples have variable duration, then MP4_INVALID_DURATION is returned.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track to which the operation applies.
+ *
+ *  @return Upon success, the number of fixed duration of the samples in the
+ *      track in track time scale units. Upon an error, MP4_INVALID_DURATION.
+ */
 MP4V2_EXPORT
 MP4Duration MP4GetTrackFixedSampleDuration(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the average bit rate in bits per second of the specified track.
+ *
+ *  MP4GetTrackBitRate returns the average bit rate in bits per second in the
+ *  specified track in the mp4 file.
+ *
+ *  Note: hint tracks will not return their bit rate via this mechanism.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the bit rate is desired.
+ *
+ *  @return Upon success, the average bit rate in bits per second of the track.
+ *      Upon an error, 0.
+ */
 MP4V2_EXPORT
 uint32_t MP4GetTrackBitRate(
     MP4FileHandle hFile,
@@ -195,10 +356,36 @@ uint32_t MP4GetTrackBitRate(
 MP4V2_EXPORT
 bool MP4GetTrackVideoMetadata(
     MP4FileHandle hFile,
-    MP4TrackId trackId,
-    uint8_t**  ppConfig,
-    uint32_t*  pConfigSize );
+    MP4TrackId    trackId,
+    uint8_t**     ppConfig,
+    uint32_t*     pConfigSize );
 
+/** Get the elementary stream (ES) configuration of a track.
+ *
+ *  MP4GetTrackESConfiguration returns the elementary stream (ES) configuration
+ *  of the specified track in the mp4 file. This information is codec specific
+ *  and contains the configuration necessary for the given codec to decode the
+ *  samples in the track.
+ *
+ *  Caveat: the returned block of memory has been allocated by the library. The
+ *  caller may safely modify the value without effecting the library, but the
+ *  caller takes responsiblity for freeing the memory with MP4Free().
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the ES configuration is
+ *      desired.
+ *  @param ppConfig specifies a pointer to a pointer variable that will be
+ *      given the address of the configuration information.
+ *  @param pConfigSize specifies a pointer to a variable to hold the size of
+ *      the ES configuration information.
+ *
+ *  @return Upon success, *ppConfig will point to a newly allocated block of
+ *      memory with the ES configuration, and *pConfigSize will indicated the
+ *      number of bytes of the ES configuration. Upon error, *ppConfig will be
+ *      NULL, and *pConfigSize will be 0.
+ *
+ *  @see MP4SetTrackESConfiguration()
+ */
 MP4V2_EXPORT
 bool MP4GetTrackESConfiguration(
     MP4FileHandle hFile,
@@ -206,6 +393,22 @@ bool MP4GetTrackESConfiguration(
     uint8_t**     ppConfig,
     uint32_t*     pConfigSize );
 
+/** Set the elementary stream (ES) configuration of a track.
+ *
+ *  MP4SetTrackESConfiguration sets the elementary stream (ES) configuration of
+ *  the specified track in the mp4 file. This information is codec specific and
+ *  contains the configuration necessary for the given codec to decode the
+ *  samples in the track.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId the track to which the operation applies.
+ *  @param pConfig specifies a pointer to the ES configuration information.
+ *  @param configSize specifies the size of the ES configuration information.
+ *
+ *  @return Upon success, true (1). Upon an error, false (0).
+ *
+ *  @see MP4GetTrackESConfiguration()
+ */
 MP4V2_EXPORT
 bool MP4SetTrackESConfiguration(
     MP4FileHandle  hFile,
@@ -215,6 +418,22 @@ bool MP4SetTrackESConfiguration(
 
 /* h264 information routines */
 
+MP4V2_EXPORT
+bool MP4GetTrackH264ProfileLevel(
+    MP4FileHandle hFile,
+    MP4TrackId    trackId,
+    uint8_t*      pProfile,
+    uint8_t*      pLevel );
+
+MP4V2_EXPORT
+bool MP4GetTrackH264SeqPictHeaders(
+    MP4FileHandle hFile,
+    MP4TrackId    trackId,
+    uint8_t***    pSeqHeaders,
+    uint32_t**    pSeqHeaderSize,
+    uint8_t***    pPictHeader,
+    uint32_t**    pPictHeaderSize );
+
 /** Frees the memory allocated by MP4GetTrackH264SeqPictHeaders.
  *
  *  MP4FreeH264SeqPictHeaders frees the memory that was allocated by a
@@ -243,53 +462,131 @@ void MP4FreeH264SeqPictHeaders(
     uint8_t** pPictHeader,
     uint32_t* pPictHeaderSize );
 
-MP4V2_EXPORT
-bool MP4GetTrackH264ProfileLevel(
-    MP4FileHandle hFile,
-    MP4TrackId    trackId,
-    uint8_t*      pProfile,
-    uint8_t*      pLevel );
-
-MP4V2_EXPORT
-bool MP4GetTrackH264SeqPictHeaders(
-    MP4FileHandle hFile,
-    MP4TrackId    trackId,
-    uint8_t***    pSeqHeaders,
-    uint32_t**    pSeqHeaderSize,
-    uint8_t***    pPictHeader,
-    uint32_t**    pPictHeaderSize );
-
 MP4V2_EXPORT
 bool MP4GetTrackH264LengthSize(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     uint32_t*     pLength );
 
+/** Get the number of samples in a track.
+ *
+ *  MP4GetTrackNumberOfSamples returns the number of samples in the specified
+ *  track in the mp4 file. Sample id's are the consecutive sequence of numbers
+ *  from 1 to the total number of samples, i.e. 1-based indexing, not 0-based
+ *  indexing.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the number of samples is
+ *      desired.
+ *
+ *  @return Upon success, the number of samples in the track. Upon an error, 0.
+ */
 MP4V2_EXPORT
 MP4SampleId MP4GetTrackNumberOfSamples(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the video width in pixels of the specified video track.
+ *
+ *  MP4GetTrackVideoWidth returns the width of the video in pixels in the
+ *  specified track in the mp4 file.
+ *
+ *  Caveat: Not all mp4 implementations set this value accurately. The mp4
+ *  specification states that the authoritative values are contained in the
+ *  track ES configuration which is video encoding specific, and hence not
+ *  interpretable by the mp4 library.
+ *
+ *  If the value of 320 is returned, care should be taken to verify the
+ *  accuracy of this value since this is the default value in the mp4
+ *  specification.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the video width is desired.
+ *
+ *  @return Upon success, the number of pixels of the video width in the
+ *      track. Upon an error, 0.
+ *
+ *  @see MP4GetTrackVideoHeight()
+ *  @see MP4GetTrackESConfiguration()
+ */
 MP4V2_EXPORT
 uint16_t MP4GetTrackVideoWidth(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the video height in pixels of the specified video track.
+ *
+ *  MP4GetTrackVideoHeight returns the height of the video in pixels in the
+ *  specified track in the mp4 file.
+ *
+ *  Caveat: Not all mp4 implementations set this value accurately. The mp4
+ *  specification states that the authoritative values are contained in the
+ *  track ES configuration which is video encoding specific, and hence not
+ *  interpretable by the mp4 library.
+ *
+ *  If the value of 240 is returned, care should be taken to verify the
+ *  accuracy of this value since this is the default value in the mp4
+ *  specification.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the video height is desired.
+ *
+ *  @return Upon success, the number of pixels of the video height in the
+ *      track. Upon an error, 0.
+ *
+ *  @see MP4GetTrackVideoWidth()
+ *  @see MP4GetTrackESConfiguration()
+ */
 MP4V2_EXPORT
 uint16_t MP4GetTrackVideoHeight(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the video frame rate of the specified video track.
+ *
+ *  MP4GetTrackVideoFrameRate returns the frame rate of the video in the
+ *  specified track in the mp4 file. If the video is variable rate, the average
+ *  frame rate is returned.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the video frame rate is
+ *      desired.
+ *
+ *  @return Upon success, the number of video frames per second of the track.
+ *      Upon an error, 0.
+ */
 MP4V2_EXPORT
 double MP4GetTrackVideoFrameRate(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Get the number of channels of the specified audio track.
+ *
+ *  MP4GetTrackAudioChannels returns the number of audio channels in the
+ *  specified track in the mp4 file.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the number of audio channels
+ *      is desired.
+ *
+ *  @return Upon success, the number of audio channels of the track. Upon an
+ *      error, -1.
+ */
 MP4V2_EXPORT
 int MP4GetTrackAudioChannels(
     MP4FileHandle hFile,
     MP4TrackId    trackId );
 
+/** Check whether a track is ISMACrypt encrypted.
+ *
+ *  MP4IsIsmaCrypMediaTrack checks whether the specified track is encrypted
+ *  using ISMACrypt.
+ *
+ *  @param hFile specifies the mp4 file to which the operation applies.
+ *  @param trackId specifies the track for which the information is desired.
+ *
+ *  @return true (1) if the track is ISMACrypt encrypted, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4IsIsmaCrypMediaTrack(
     MP4FileHandle hFile,
@@ -297,33 +594,103 @@ bool MP4IsIsmaCrypMediaTrack(
 
 /* generic track properties */
 
+/** Check for presence of a track atom.
+ *
+ *  MP4HaveTrackAtom checks for the presence of the track atom passed in @p
+ *  atomName. @p atomName can specify an atom path to check for atoms that are
+ *  not direct children of the @b trak atom, e.g. "mdia.minf.stbl".
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param atomName name of the atom to check for.
+ *
+ *  @return true (1) if the atom is present, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4HaveTrackAtom(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     const char*   atomName );
 
+/** Get the value of an integer property for a track.
+ *
+ *  MP4GetTrackIntegerProperty determines the value of the integer property
+ *  identified by @p propName, e.g. "tkhd.layer", for the track identified by
+ *  @p trackId. The value is stored in the variable pointed to by @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetTrackIntegerProperty(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     const char*   propName,
-    uint64_t*     retvalue );
+    uint64_t*     retVal );
 
+/** Get the value of a float property for a track.
+ *
+ *  MP4GetTrackFloatProperty determines the value of the float property
+ *  identified by @p propName, e.g. "tkhd.volume", for the track identified by
+ *  @p trackId. The value is stored in the variable pointed to by @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetTrackFloatProperty(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     const char*   propName,
-    float*        ret_value );
+    float*        retVal );
 
+/** Get the value of a string property for a track.
+ *
+ *  MP4GetTrackStringProperty determines the value of the string property
+ *  identified by @p propName, e.g. "udta.hnti.sdp .sdpText", for the track
+ *  identified by @p trackId. The value is stored in the variable pointed to by
+ *  @p retVal.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to get.
+ *  @param retVal pointer to a variable to receive the return value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetTrackStringProperty(
     MP4FileHandle hFile,
     MP4TrackId    trackId,
     const char*   propName,
-    const char**  retvalue );
+    const char**  retVal );
 
+/** Get the value of a bytes property for a track.
+ *
+ *  MP4GetTrackBytesProperty determines the value of the bytes property
+ *  identified by @p propName, e.g. "tkhd.matrix", for the track identified by
+ *  @p trackId. The value is stored in a newly allocated buffer the location of
+ *  which is assigned to the variable pointed to by ppValue. The caller is
+ *  responsible for freeing the memory with MP4Free().
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to get.
+ *  @param ppValue pointer to a variable to receive the memory location
+ *      containing the property bytes.
+ *  @param pValueSize pointer to a variable to receive the length of the
+ *      property bytes value.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4GetTrackBytesProperty(
     MP4FileHandle hFile,
@@ -332,13 +699,38 @@ bool MP4GetTrackBytesProperty(
     uint8_t**     ppValue,
     uint32_t*     pValueSize );
 
+/** Set the value of an integer property for a track.
+ *
+ *  MP4SetTrackIntegerProperty sets the value of the integer property
+ *  identified by @p propName, e.g. "tkhd.layer", for the track identified by
+ *  @p trackId.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetTrackIntegerProperty(
     MP4FileHandle hFile,
-    MP4TrackId   trackId,
-    const char*  propName,
-    int64_t      value );
+    MP4TrackId    trackId,
+    const char*   propName,
+    int64_t       value );
 
+/** Set the value of a float property for a track.
+ *
+ *  MP4SetTrackFloatProperty sets the value of the float property identified by
+ *  @p propName, e.g. "tkhd.volume", for the track identified by @p trackId.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetTrackFloatProperty(
     MP4FileHandle hFile,
@@ -346,6 +738,19 @@ bool MP4SetTrackFloatProperty(
     const char*   propName,
     float         value );
 
+/** Set the value of a string property for a track.
+ *
+ *  MP4SetTrackStringProperty sets the value of the string property identified
+ *  by @p propName, e.g. "udta.hnti.sdp .sdpText", for the track identified by
+ *  @p trackId.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to set.
+ *  @param value the new value of the property.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetTrackStringProperty(
     MP4FileHandle hFile,
@@ -353,6 +758,19 @@ bool MP4SetTrackStringProperty(
     const char*   propName,
     const char*   value );
 
+/** Set the value of a bytes property for a track.
+ *
+ *  MP4SetTrackBytesProperty sets the value of the bytes property identified by
+ *  @p propName, e.g. "tkhd.matrix", for the track identified by @p trackId.
+ *
+ *  @param hFile handle of file for operation.
+ *  @param trackId id of track for operation.
+ *  @param propName path to the property to set.
+ *  @param pValue pointer the bytes representing the new value of the property.
+ *  @param valueSize the size of the bytes value pointed to by <b>pValue</b>.
+ *
+ *  @return true (1) on success, false (0) otherwise.
+ */
 MP4V2_EXPORT
 bool MP4SetTrackBytesProperty(
     MP4FileHandle  hFile,
diff --git a/mp4v2/libplatform/config.h.cmake b/mp4v2/libplatform/config.h.cmake
new file mode 100644
index 0000000..49bacbe
--- /dev/null
+++ b/mp4v2/libplatform/config.h.cmake
@@ -0,0 +1,58 @@
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#cmakedefine HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H 1
+
+/* libtool defines DLL_EXPORT for windows dll
+   builds, but we use MP4V2_EXPORTS instead. */
+#ifdef DLL_EXPORT
+# define MP4V2_EXPORTS
+#else
+# define MP4V2_USE_STATIC_LIB
+#endif
+
+/* Define to 1 if LFS should be activated */
+#cmakedefine NEED_LFS_ACTIVATION 1
+
+/* Name of package */
+#define PACKAGE "@PROJECT_name_lower@"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "@PROJECT_email@"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "@PROJECT_name@"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "@PROJECT_name_formal@"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "@PROJECT_name_lower@"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "@PROJECT_url_website@"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "@PROJECT_version@"
+
+/* Version number of package */
+#define VERSION "@PROJECT_version@"
diff --git a/mp4v2/libplatform/config.h.in b/mp4v2/libplatform/config.h.in
index f501a09..155387b 100644
--- a/mp4v2/libplatform/config.h.in
+++ b/mp4v2/libplatform/config.h.in
@@ -6,12 +6,12 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#undef HAVE_STDIO_H
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
@@ -33,6 +33,14 @@
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
+/* libtool defines DLL_EXPORT for windows dll
+   builds, but we use MP4V2_EXPORTS instead. */
+#ifdef DLL_EXPORT
+# define MP4V2_EXPORTS
+#else
+# define MP4V2_USE_STATIC_LIB
+#endif
+
 /* Define to 1 if LFS should be activated */
 #undef NEED_LFS_ACTIVATION
 
@@ -57,7 +65,9 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C90 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #undef STDC_HEADERS
 
 /* Version number of package */
diff --git a/mp4v2/libplatform/io/File.cpp b/mp4v2/libplatform/io/File.cpp
index 2ea0e8d..37969b9 100644
--- a/mp4v2/libplatform/io/File.cpp
+++ b/mp4v2/libplatform/io/File.cpp
@@ -4,13 +4,7 @@ namespace mp4v2 { namespace platform { namespace io {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-namespace {
-    const File::Size __maxChunkSize = 1024*1024;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-File::File( std::string name_, Mode mode_, FileProvider* provider_ )
+File::File( const std::string& name_, Mode mode_, FileProvider* provider_ )
     : _name     ( name_ )
     , _isOpen   ( false )
     , _mode     ( mode_ )
@@ -50,7 +44,7 @@ File::setName( const std::string& name_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-File::open( std::string name_, Mode mode_ )
+File::open( const std::string& name_, Mode mode_ )
 {
     if( _isOpen )
         return true;
@@ -83,14 +77,14 @@ File::seek( Size pos )
 }
 
 bool
-File::read( void* buffer, Size size, Size& nin, Size maxChunkSize )
+File::read( void* buffer, Size size, Size& nin )
 {
     nin = 0;
 
     if( !_isOpen )
         return true;
 
-    if( _provider.read( buffer, size, nin, maxChunkSize ))
+    if( _provider.read( buffer, size, nin ))
         return true;
 
     _position += nin;
@@ -101,14 +95,14 @@ File::read( void* buffer, Size size, Size& nin, Size maxChunkSize )
 }
 
 bool
-File::write( const void* buffer, Size size, Size& nout, Size maxChunkSize )
+File::write( const void* buffer, Size size, Size& nout )
 {
     nout = 0;
 
     if( !_isOpen )
         return true;
 
-    if( _provider.write( buffer, size, nout, maxChunkSize ))
+    if( _provider.write( buffer, size, nout ))
         return true;
 
     _position += nout;
@@ -118,6 +112,20 @@ File::write( const void* buffer, Size size, Size& nout, Size maxChunkSize )
     return false;
 }
 
+bool
+File::truncate( Size size )
+{
+    if( !_isOpen )
+        return true;
+
+    if( _provider.truncate( size ))
+        return true;
+
+    _size = size;
+
+    return false;
+}
+
 bool
 File::close()
 {
@@ -148,8 +156,10 @@ CustomFileProvider::CustomFileProvider( const MP4FileProvider& provider )
 }
 
 bool
-CustomFileProvider::open( std::string name, Mode mode )
+CustomFileProvider::open( const std::string& name, Mode mode )
 {
+    _name = name;
+
     MP4FileMode fm;
     switch( mode ) {
         case MODE_READ:   fm = FILEMODE_READ;   break;
@@ -162,7 +172,7 @@ CustomFileProvider::open( std::string name, Mode mode )
             break;
     }
 
-    _handle = _call.open( name.c_str(), fm );
+    _handle = _call.open( _name.c_str(), fm );
     return _handle == NULL;
 }
 
@@ -173,15 +183,21 @@ CustomFileProvider::seek( Size pos )
 }
 
 bool
-CustomFileProvider::read( void* buffer, Size size, Size& nin, Size maxChunkSize )
+CustomFileProvider::read( void* buffer, Size size, Size& nin )
+{
+    return _call.read( _handle, buffer, size, &nin, 0 );
+}
+
+bool
+CustomFileProvider::write( const void* buffer, Size size, Size& nout )
 {
-    return _call.read( _handle, buffer, size, &nin, maxChunkSize );
+    return _call.write( _handle, buffer, size, &nout, 0 );
 }
 
 bool
-CustomFileProvider::write( const void* buffer, Size size, Size& nout, Size maxChunkSize )
+CustomFileProvider::truncate( Size size )
 {
-    return _call.write( _handle, buffer, size, &nout, maxChunkSize );
+    return true;
 }
 
 bool
@@ -193,7 +209,65 @@ CustomFileProvider::close()
 bool
 CustomFileProvider::getSize( Size& nout )
 {
-    return _call.getSize( _handle, &nout );
+    return FileSystem::getFileSize( _name, nout );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+CallbacksFileProvider::CallbacksFileProvider( const MP4IOCallbacks& callbacks, void* handle )
+    : _handle( handle )
+{
+    memcpy( &_call, &callbacks, sizeof(MP4IOCallbacks) );
+}
+
+bool
+CallbacksFileProvider::open( const std::string& name, Mode mode )
+{
+    return seek(0);
+}
+
+bool
+CallbacksFileProvider::seek( Size pos )
+{
+    return _call.seek( _handle, pos );
+}
+
+bool
+CallbacksFileProvider::read( void* buffer, Size size, Size& nin )
+{
+    return _call.read( _handle, buffer, size, &nin );
+}
+
+bool
+CallbacksFileProvider::write( const void* buffer, Size size, Size& nout )
+{
+    return _call.write( _handle, buffer, size, &nout );
+}
+
+bool
+CallbacksFileProvider::truncate( Size size )
+{
+    if( !_call.truncate )
+        return true;
+
+    return _call.truncate( _handle, size );
+}
+
+bool
+CallbacksFileProvider::close()
+{
+    return false;
+}
+
+bool
+CallbacksFileProvider::getSize( Size& nout )
+{
+    Size size = _call.size( _handle );
+    if (size == -1)
+        return true;
+
+    nout = size;
+    return false;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/mp4v2/libplatform/io/File.h b/mp4v2/libplatform/io/File.h
index bf8536c..4f4b0e4 100644
--- a/mp4v2/libplatform/io/File.h
+++ b/mp4v2/libplatform/io/File.h
@@ -16,7 +16,7 @@ public:
         MODE_UNDEFINED, //!< undefined
         MODE_READ,      //!< file may be read
         MODE_MODIFY,    //!< file may be read/written
-        MODE_CREATE,    //!< file will be created/truncated for read/write
+        MODE_CREATE     //!< file will be created/truncated for read/write
     };
 
     //! type used to represent all file sizes and offsets
@@ -25,10 +25,11 @@ public:
 public:
     virtual ~FileProvider() { }
 
-    virtual bool open( std::string name, Mode mode ) = 0;
+    virtual bool open( const std::string& name, Mode mode ) = 0;
     virtual bool seek( Size pos ) = 0;
-    virtual bool read( void* buffer, Size size, Size& nin, Size maxChunkSize ) = 0;
-    virtual bool write( const void* buffer, Size size, Size& nout, Size maxChunkSize ) = 0;
+    virtual bool read( void* buffer, Size size, Size& nin ) = 0;
+    virtual bool write( const void* buffer, Size size, Size& nout ) = 0;
+    virtual bool truncate( Size size ) = 0;
     virtual bool close() = 0;
     virtual bool getSize( Size& nout ) = 0;
 
@@ -58,7 +59,7 @@ public:
     //! A new file object is constructed but not opened.
     //!
     //! @param name filename of file object, or empty-string.
-	//!  On Windows, this should be a UTF-8 encoded string.
+    //!  On Windows, this should be a UTF-8 encoded string.
     //!  On other platforms, it should be an 8-bit encoding that is
     //!  appropriate for the platform, locale, file system, etc.
     //!  (prefer to use UTF-8 when possible).
@@ -70,7 +71,8 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    explicit File( std::string name = "", Mode mode = MODE_UNDEFINED, FileProvider* = NULL );
+    explicit File( const std::string& name = "", Mode mode = MODE_UNDEFINED,
+        FileProvider* provider = NULL );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -88,16 +90,18 @@ public:
     //! Open file.
     //!
     //! @param name filename of file object, or empty-string to use #name.
-	//!     On Windows, this should be a UTF-8 encoded string.
+    //!     On Windows, this should be a UTF-8 encoded string.
     //!     On other platforms, it should be an 8-bit encoding that is
     //!     appropriate for the platform, locale, file system, etc.
     //!     (prefer to use UTF-8 when possible).
+    //! @param mode bitmask specifying mode flags.
+    //!     See #Mode for bit constants.
     //!
     //! @return true on failure, false on success.
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    bool open( std::string name = "", Mode mode = MODE_UNDEFINED );
+    bool open( const std::string& name = "", Mode mode = MODE_UNDEFINED );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -135,14 +139,12 @@ public:
     //! @param buffer storage for data read from file.
     //! @param size maximum number of bytes to read from file.
     //! @param nin output indicating number of bytes read from file.
-    //! @param maxChunkSize maximum chunk size for reads issued to operating
-    //!     system or 0 for default.
     //!
     //! @return true on failure, false on success.
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    bool read( void* buffer, Size size, Size& nin, Size maxChunkSize = 0 );
+    bool read( void* buffer, Size size, Size& nin );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -155,14 +157,24 @@ public:
     //! @param buffer data to be written out to file.
     //! @param size maximum number of bytes to read from file.
     //! @param nout output indicating number of bytes written to file.
-    //! @param maxChunkSize maximum chunk size for writes issued to operating
-    //!     system or 0 for default.
     //!
     //! @return true on failure, false on success.
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    bool write( const void* buffer, Size size, Size& nout, Size maxChunkSize = 0 );
+    bool write( const void* buffer, Size size, Size& nout );
+
+    ///////////////////////////////////////////////////////////////////////////
+    //!
+    //! Truncate file to length in bytes.
+    //!
+    //! @param size number of bytes to truncate the file to.
+    //!
+    //! @return true on failure, false on success.
+    //!
+    ///////////////////////////////////////////////////////////////////////////
+
+    bool truncate( Size size );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -203,16 +215,38 @@ class CustomFileProvider : public FileProvider
 public:
     CustomFileProvider( const MP4FileProvider& );
 
-    bool open( std::string name, Mode mode );
+    bool open( const std::string& name, Mode mode );
     bool seek( Size pos );
-    bool read( void* buffer, Size size, Size& nin, Size maxChunkSize );
-    bool write( const void* buffer, Size size, Size& nout, Size maxChunkSize );
+    bool read( void* buffer, Size size, Size& nin );
+    bool write( const void* buffer, Size size, Size& nout );
+    bool truncate( Size size );
     bool close();
     bool getSize( Size& nout );
 
 private:
     MP4FileProvider _call;
     void*           _handle;
+    std::string     _name;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+class CallbacksFileProvider : public FileProvider
+{
+public:
+    CallbacksFileProvider( const MP4IOCallbacks& callbacks, void* handle );
+
+    bool open( const std::string& name, Mode mode );
+    bool seek( Size pos );
+    bool read( void* buffer, Size size, Size& nin );
+    bool write( const void* buffer, Size size, Size& nout );
+    bool truncate( Size size );
+    bool close();
+    bool getSize( Size& nout );
+
+private:
+    MP4IOCallbacks _call;
+    void*          _handle;
 };
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/mp4v2/libplatform/io/FileSystem.cpp b/mp4v2/libplatform/io/FileSystem.cpp
index 073b026..eef3bfa 100644
--- a/mp4v2/libplatform/io/FileSystem.cpp
+++ b/mp4v2/libplatform/io/FileSystem.cpp
@@ -77,7 +77,7 @@ FileSystem::pathnameStripExtension( string& name )
 ///////////////////////////////////////////////////////////////////////////////
 
 void
-FileSystem::pathnameTemp( string& name, string dir, string prefix, string suffix )
+FileSystem::pathnameTemp( string& name, const std::string& dir, const std::string& prefix, const std::string& suffix )
 {
     ostringstream buf;
 
diff --git a/mp4v2/libplatform/io/FileSystem.h b/mp4v2/libplatform/io/FileSystem.h
index b348752..a76f4d2 100644
--- a/mp4v2/libplatform/io/FileSystem.h
+++ b/mp4v2/libplatform/io/FileSystem.h
@@ -29,7 +29,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static bool exists( std::string name );
+    static bool exists( const std::string& name );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -44,7 +44,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static bool isDirectory( std::string name );
+    static bool isDirectory( const std::string& name );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -59,7 +59,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static bool isFile( std::string name );
+    static bool isFile( const std::string& name );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -75,7 +75,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static bool getFileSize( std::string name, File::Size& size );
+    static bool getFileSize( const std::string& name, File::Size& size );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -102,7 +102,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static bool rename( std::string oldname, std::string newname );
+    static bool rename( const std::string& oldname, const std::string& newname );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
@@ -115,7 +115,7 @@ public:
     //!
     ///////////////////////////////////////////////////////////////////////////
 
-    static void pathnameTemp( string& name, string dir = ".", string prefix = "tmp", string suffix = "" );
+    static void pathnameTemp( string& name, const std::string& dir = ".", const std::string& prefix = "tmp", const std::string& suffix = "" );
 
     ///////////////////////////////////////////////////////////////////////////
     //!
diff --git a/mp4v2/libplatform/io/FileSystem_posix.cpp b/mp4v2/libplatform/io/FileSystem_posix.cpp
index 46cf933..7308df2 100644
--- a/mp4v2/libplatform/io/FileSystem_posix.cpp
+++ b/mp4v2/libplatform/io/FileSystem_posix.cpp
@@ -6,7 +6,7 @@ namespace mp4v2 { namespace platform { namespace io {
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::exists( string path_ )
+FileSystem::exists( const std::string& path_ )
 {
     struct stat buf;
     return stat( path_.c_str(), &buf ) == 0;
@@ -15,7 +15,7 @@ FileSystem::exists( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::isDirectory( string path_ )
+FileSystem::isDirectory( const std::string& path_ )
 {
     struct stat buf;
     if( stat( path_.c_str(), &buf ))
@@ -26,7 +26,7 @@ FileSystem::isDirectory( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::isFile( string path_ )
+FileSystem::isFile( const std::string& path_ )
 {
     struct stat buf;
     if( stat( path_.c_str(), &buf ))
@@ -37,7 +37,7 @@ FileSystem::isFile( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::getFileSize( string path_, File::Size& size_ )
+FileSystem::getFileSize( const std::string& path_, File::Size& size_ )
 {
     size_ = 0;
     struct stat buf;
@@ -50,7 +50,7 @@ FileSystem::getFileSize( string path_, File::Size& size_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::rename( string from, string to )
+FileSystem::rename( const std::string& from, const std::string& to )
 {
     return ::rename( from.c_str(), to.c_str() ) != 0;
 }
diff --git a/mp4v2/libplatform/io/FileSystem_win32.cpp b/mp4v2/libplatform/io/FileSystem_win32.cpp
index 4a21381..e1e0b15 100644
--- a/mp4v2/libplatform/io/FileSystem_win32.cpp
+++ b/mp4v2/libplatform/io/FileSystem_win32.cpp
@@ -10,7 +10,7 @@ namespace mp4v2 { namespace platform { namespace io {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-static DWORD    getAttributes ( string   path_ );
+static DWORD    getAttributes ( const std::string& path_ );
 
 /**
  * Call GetFileAttributesW throw exceptions for errors
@@ -21,7 +21,7 @@ static DWORD    getAttributes ( string   path_ );
  * @retval anything else the attributes of @p path_
  */
 static DWORD
-getAttributes ( string  path_ )
+getAttributes ( const std::string& path_ )
 {
     win32::Utf8ToFilename filename(path_);
 
@@ -32,7 +32,7 @@ getAttributes ( string  path_ )
         // the places it's called.
         ostringstream msg;
         msg << "can't convert file to UTF-16(" << filename.utf8 << ")";
-        throw new Exception(msg.str(),__FILE__,__LINE__,__FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 
     DWORD attributes = ::GetFileAttributesW(filename);
@@ -49,7 +49,7 @@ getAttributes ( string  path_ )
         // Anything else is an error
         ostringstream msg;
         msg << "GetFileAttributes(" << filename.utf8 << ") failed (" << last_err << ")";
-        throw new Exception(msg.str(),__FILE__,__LINE__,__FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 
     // path exists so return its attributes
@@ -57,7 +57,7 @@ getAttributes ( string  path_ )
 }
 
 bool
-FileSystem::exists( string path_ )
+FileSystem::exists( const std::string& path_ )
 {
     return( getAttributes(path_) != INVALID_FILE_ATTRIBUTES );
 }
@@ -65,7 +65,7 @@ FileSystem::exists( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::isDirectory( string path_ )
+FileSystem::isDirectory( const std::string& path_ )
 {
     DWORD attributes = getAttributes( path_ );
     if( attributes == INVALID_FILE_ATTRIBUTES )
@@ -77,7 +77,7 @@ FileSystem::isDirectory( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::isFile( string path_ )
+FileSystem::isFile( const std::string& path_ )
 {
     DWORD attributes = getAttributes( path_ );
     if( attributes == INVALID_FILE_ATTRIBUTES )
@@ -89,7 +89,7 @@ FileSystem::isFile( string path_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::getFileSize( string path_, File::Size& size_ )
+FileSystem::getFileSize( const std::string& path_, File::Size& size_ )
 {
     win32::Utf8ToFilename filename(path_);
 
@@ -115,7 +115,7 @@ FileSystem::getFileSize( string path_, File::Size& size_ )
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
-FileSystem::rename( string from, string to )
+FileSystem::rename( const std::string& from, const std::string& to )
 {
     win32::Utf8ToFilename from_file(from);
     win32::Utf8ToFilename to_file(to);
diff --git a/mp4v2/libplatform/io/File_posix.cpp b/mp4v2/libplatform/io/File_posix.cpp
index cae75ea..761acc3 100644
--- a/mp4v2/libplatform/io/File_posix.cpp
+++ b/mp4v2/libplatform/io/File_posix.cpp
@@ -9,10 +9,11 @@ class StandardFileProvider : public FileProvider
 public:
     StandardFileProvider();
 
-    bool open( std::string name, Mode mode );
+    bool open( const std::string& name, Mode mode );
     bool seek( Size pos );
-    bool read( void* buffer, Size size, Size& nin, Size maxChunkSize );
-    bool write( const void* buffer, Size size, Size& nout, Size maxChunkSize );
+    bool read( void* buffer, Size size, Size& nin );
+    bool write( const void* buffer, Size size, Size& nout );
+    bool truncate( Size size );
     bool close();
     bool getSize( Size& nout );
 
@@ -32,7 +33,7 @@ StandardFileProvider::StandardFileProvider()
 }
 
 bool
-StandardFileProvider::open( std::string name, Mode mode )
+StandardFileProvider::open( const std::string& name, Mode mode )
 {
     ios::openmode om = ios::binary;
     switch( mode ) {
@@ -73,7 +74,7 @@ StandardFileProvider::seek( Size pos )
 }
 
 bool
-StandardFileProvider::read( void* buffer, Size size, Size& nin, Size maxChunkSize )
+StandardFileProvider::read( void* buffer, Size size, Size& nin )
 {
     _fstream.read( (char*)buffer, size );
     if( _fstream.fail() )
@@ -83,7 +84,7 @@ StandardFileProvider::read( void* buffer, Size size, Size& nin, Size maxChunkSiz
 }
 
 bool
-StandardFileProvider::write( const void* buffer, Size size, Size& nout, Size maxChunkSize )
+StandardFileProvider::write( const void* buffer, Size size, Size& nout )
 {
     _fstream.write( (const char*)buffer, size );
     if( _fstream.fail() )
@@ -92,6 +93,25 @@ StandardFileProvider::write( const void* buffer, Size size, Size& nout, Size max
     return false;
 }
 
+bool
+StandardFileProvider::truncate( Size size )
+{
+    // close the file prior to truncating it
+    _fstream.close();
+
+    // truncate the file using the POSIX truncate function
+    if( ::truncate( _name.c_str(), size ) != 0)
+        return true;
+
+    // reopen the file and seek to the new end
+    _fstream.clear();
+    _fstream.open( _name.c_str(), ios::binary | ios::in | ios::out);
+    if ( _fstream.fail() )
+        return true;
+
+    return seek( size );
+}
+
 bool
 StandardFileProvider::close()
 {
@@ -104,12 +124,10 @@ StandardFileProvider::getSize( Size& nout )
 {
     bool retval;
 
-    streampos curpos = _fstream.tellg();
-    _fstream.seekg(0, ios::end);
-    nout = _fstream.tellg();
-    _fstream.seekg(curpos, ios::beg);
+    // getFileSize will log if it fails
+    retval = FileSystem::getFileSize( _name, nout );
 
-    return _fstream.fail();
+    return retval;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/mp4v2/libplatform/io/File_win32.cpp b/mp4v2/libplatform/io/File_win32.cpp
index cc15731..b54f6c8 100644
--- a/mp4v2/libplatform/io/File_win32.cpp
+++ b/mp4v2/libplatform/io/File_win32.cpp
@@ -1,26 +1,39 @@
 #include "src/impl.h"
 #include "libplatform/impl.h" /* for platform_win32_impl.h which declares Utf8ToFilename */
-#include <windows.h>
 
-namespace mp4v2 {
-    using namespace impl;
-}
+#if _WIN32_WINNT < 0x0600
+#   include <io.h> // for _lseeki64 in pre Windows Vista code
 
-/**
- * Set this to 1 to compile in extra debugging
- */
-#define EXTRA_DEBUG 0
+#   ifndef GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
+#       define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 0x2
+#       define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS       0x4
+#   endif
 
-/**
- * @def LOG_PRINTF
- *
- * call log.printf if EXTRA_DEBUG is defined to 1.  Do
- * nothing otherwise
- */
-#if EXTRA_DEBUG
-#define LOG_PRINTF(X) log.printf X
-#else
-#define LOG_PRINTF(X)
+    typedef int (*_fseeki64_type)(FILE*, __int64, int);
+
+    static _fseeki64_type GetFileSeekFunction()
+    {
+        // find the module containing file IO functions and check if it has _fseeki64
+        HMODULE crtdll = NULL;
+
+#   if _WIN32_WINNT >= 0x0501
+        GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCSTR) &_wfopen, &crtdll);
+#   else
+        HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
+
+        typedef BOOL (WINAPI *GetModuleHandleExA_type)(DWORD, LPCSTR, HMODULE*);
+
+        if (GetModuleHandleExA_type GetModuleHandleExA_func = (GetModuleHandleExA_type) GetProcAddress(kernel32, "GetModuleHandleExA"))
+            GetModuleHandleExA_func(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCSTR) &_wfopen, &crtdll);
+#   endif
+
+        if (crtdll)
+            return (_fseeki64_type) GetProcAddress(crtdll, "_fseeki64");
+
+        return NULL;
+    }
+
+    static _fseeki64_type _fseeki64_func = GetFileSeekFunction();
 #endif
 
 namespace mp4v2 { namespace platform { namespace io {
@@ -32,18 +45,19 @@ class StandardFileProvider : public FileProvider
 public:
     StandardFileProvider();
 
-    bool open( std::string name, Mode mode );
+    bool open( const std::string& name, Mode mode );
     bool seek( Size pos );
-    bool read( void* buffer, Size size, Size& nin, Size maxChunkSize );
-    bool write( const void* buffer, Size size, Size& nout, Size maxChunkSize );
+    bool read( void* buffer, Size size, Size& nin );
+    bool write( const void* buffer, Size size, Size& nout );
+    bool truncate( Size size );
     bool close();
     bool getSize( Size& nout );
 
 private:
-    HANDLE _handle;
+    FILE* _file;
 
     /**
-     * The UTF-8 encoded file name
+     * Argument for FileSystem::getFileSize()
      */
     std::string _name;
 };
@@ -51,7 +65,7 @@ private:
 ///////////////////////////////////////////////////////////////////////////////
 
 StandardFileProvider::StandardFileProvider()
-    : _handle( INVALID_HANDLE_VALUE )
+    : _file( NULL )
 {
 }
 
@@ -65,30 +79,24 @@ StandardFileProvider::StandardFileProvider()
  * @retval true error opening @p name
  */
 bool
-StandardFileProvider::open( std::string name, Mode mode )
+StandardFileProvider::open( const std::string& name, Mode mode )
 {
-    DWORD access = 0;
-    DWORD share  = 0;
-    DWORD crdisp = 0;
-    DWORD flags  = FILE_ATTRIBUTE_NORMAL;
+    _name = name;
 
+    const wchar_t *om;
     switch( mode ) {
         case MODE_UNDEFINED:
         case MODE_READ:
         default:
-            access |= GENERIC_READ;
-            share  |= FILE_SHARE_READ;
-            crdisp |= OPEN_EXISTING;
+            om = L"rbN";
             break;
 
         case MODE_MODIFY:
-            access |= GENERIC_READ | GENERIC_WRITE;
-            crdisp |= OPEN_EXISTING;
+            om = L"r+bN";
             break;
 
         case MODE_CREATE:
-            access |= GENERIC_READ | GENERIC_WRITE;
-            crdisp |= CREATE_ALWAYS;
+            om = L"w+bN";
             break;
     }
 
@@ -101,20 +109,10 @@ StandardFileProvider::open( std::string name, Mode mode )
     }
 
     ASSERT(LPCWSTR(filename));
-    _handle = CreateFileW( filename, access, share, NULL, crdisp, flags, NULL );
-    if (_handle == INVALID_HANDLE_VALUE)
-    {
-        log.errorf("%s: CreateFileW(%s) failed (%d)",__FUNCTION__,filename.utf8.c_str(),GetLastError());
-        return true;
-    }
 
-    /*
-    ** Make a copy of the name for future log messages, etc.
-    */
-    log.verbose2f("%s: CreateFileW(%s) succeeded",__FUNCTION__,filename.utf8.c_str());
+    _file = _wfopen( filename, om );
 
-    _name = filename.utf8;
-    return false;
+    return (_file == NULL);
 }
 
 /**
@@ -129,19 +127,18 @@ StandardFileProvider::open( std::string name, Mode mode )
 bool
 StandardFileProvider::seek( Size pos )
 {
-    LARGE_INTEGER n;
-
-    ASSERT(_handle != INVALID_HANDLE_VALUE);
+#if _WIN32_WINNT >= 0x0600 // Windows Vista or later
+    return _fseeki64( _file, pos, SEEK_SET );
+#else
+    if (_fseeki64_func)
+        return _fseeki64_func( _file, pos, SEEK_SET );
 
-    n.QuadPart = pos;
-    if (!SetFilePointerEx( _handle, n, NULL, FILE_BEGIN ))
-    {
-        log.errorf("%s: SetFilePointerEx(%s,%" PRId64 ") failed (%d)",__FUNCTION__,_name.c_str(),
-                                pos,GetLastError());
-        return true;
-    }
+    // if _fseeki64 is not available, cause a cache flush
+    // before calling _lseeki64 on the underlying fileno
+    rewind( _file );
 
-    return false;
+    return _lseeki64( _fileno( _file ), pos, SEEK_SET ) == -1;
+#endif
 }
 
 /**
@@ -158,25 +155,12 @@ StandardFileProvider::seek( Size pos )
  * @retval true error reading from the file
  */
 bool
-StandardFileProvider::read( void* buffer, Size size, Size& nin, Size maxChunkSize )
+StandardFileProvider::read( void* buffer, Size size, Size& nin )
 {
-    DWORD nread = 0;
-
-    ASSERT(_handle != INVALID_HANDLE_VALUE);
-
-    // ReadFile takes a DWORD for number of bytes to read so
-    // make sure we're not asking for more than fits.
-    // MAXDWORD from WinNT.h.
-    ASSERT(size <= MAXDWORD);
-    if( ReadFile( _handle, buffer, (DWORD)(size & MAXDWORD), &nread, NULL ) == 0 )
-    {
-        log.errorf("%s: ReadFile(%s,%d) failed (%d)",__FUNCTION__,_name.c_str(),
-                   (DWORD)(size & MAXDWORD),GetLastError());
+    Size count = fread( buffer, 1, size, _file );
+    if( ferror(_file) )
         return true;
-    }
-    LOG_PRINTF((MP4_LOG_VERBOSE3,"%s: ReadFile(%s,%d) succeeded: read %d byte(s)",__FUNCTION__,
-               _name.c_str(),(DWORD)(size & MAXDWORD),nread));
-    nin = nread;
+    nin = count;
     return false;
 }
 
@@ -194,26 +178,50 @@ StandardFileProvider::read( void* buffer, Size size, Size& nin, Size maxChunkSiz
  * @retval true error writing to the file
  */
 bool
-StandardFileProvider::write( const void* buffer, Size size, Size& nout, Size maxChunkSize )
+StandardFileProvider::write( const void* buffer, Size size, Size& nout )
+{
+    Size count = fwrite( buffer, 1, size, _file );
+    if( ferror(_file) )
+        return true;
+    nout = count;
+    return false;
+}
+
+/**
+ * Truncate file size
+ *
+ * @param size the number of bytes to truncate the file to
+ *
+ * @retval false successfully truncated the file
+ * @retval true error truncating the file
+ */
+bool
+StandardFileProvider::truncate( Size size )
 {
-    DWORD nwrote = 0;
+    // close the file prior to truncating it
+    fclose( _file );
 
-    ASSERT(_handle != INVALID_HANDLE_VALUE);
+    // truncate the file using Windows API functions
+    win32::Utf8ToFilename filename(_name);
+    HANDLE handle = CreateFileW( filename, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
+    if ( handle == INVALID_HANDLE_VALUE )
+        return true;
 
-    // ReadFile takes a DWORD for number of bytes to read so
-    // make sure we're not asking for more than fits.
-    // MAXDWORD from WinNT.h.
-    ASSERT(size <= MAXDWORD);
-    if( WriteFile( _handle, buffer, (DWORD)(size & MAXDWORD), &nwrote, NULL ) == 0 )
-    {
-        log.errorf("%s: WriteFile(%s,%d) failed (%d)",__FUNCTION__,_name.c_str(),
-                   (DWORD)(size & MAXDWORD),GetLastError());
+    LARGE_INTEGER end;
+    end.QuadPart = size;
+    if ( !SetFilePointerEx( handle, end, NULL, FILE_BEGIN ) || !SetEndOfFile( handle ) ) {
+        CloseHandle( handle );
         return true;
     }
-    log.verbose2f("%s: WriteFile(%s,%d) succeeded: wrote %d byte(s)",__FUNCTION__,
-                  _name.c_str(),(DWORD)(size & MAXDWORD),nwrote);
-    nout = nwrote;
-    return false;
+
+    CloseHandle( handle );
+
+    // reopen the file and seek to the new end
+    _file = _wfopen( filename, L"r+bN" );
+    if ( _file == NULL )
+        return true;
+
+    return seek( size );
 }
 
 /**
@@ -225,23 +233,7 @@ StandardFileProvider::write( const void* buffer, Size size, Size& nout, Size max
 bool
 StandardFileProvider::close()
 {
-    BOOL retval;
-
-    retval = CloseHandle( _handle );
-    if (!retval)
-    {
-        log.errorf("%s: CloseHandle(%s) failed (%d)",__FUNCTION__,
-                   _name.c_str(),GetLastError());
-    }
-
-    // Whether we succeeded or not, clear the handle and
-    // forget the name
-    _handle = INVALID_HANDLE_VALUE;
-    _name.clear();
-
-    // CloseHandle return 0/false to indicate failure, but
-    // we return 0/false to indicate success, so negate.
-    return !retval;
+    return fclose(_file);
 }
 
 /**
@@ -256,11 +248,10 @@ StandardFileProvider::close()
 bool
 StandardFileProvider::getSize( Size& nout )
 {
-    BOOL retval;
+    bool retval;
 
-    BY_HANDLE_FILE_INFORMATION fi;
-    retval = !GetFileInformationByHandle(_handle, &fi);
-    nout = ((static_cast<int64_t>(fi.nFileSizeHigh) << 32) | fi.nFileSizeLow);
+    // getFileSize will log if it fails
+    retval = FileSystem::getFileSize( _name, nout );
 
     return retval;
 }
diff --git a/mp4v2/libplatform/number/random.h b/mp4v2/libplatform/number/random.h
index 9d0f105..08117b9 100644
--- a/mp4v2/libplatform/number/random.h
+++ b/mp4v2/libplatform/number/random.h
@@ -6,10 +6,10 @@ namespace mp4v2 { namespace platform { namespace number {
 ///////////////////////////////////////////////////////////////////////////////
 
 /// Generate 32-bit pseudo-random number.
-MP4V2_EXPORT uint32_t random32();
+uint32_t random32();
 
 /// Seed pseudo-random number generator.
-MP4V2_EXPORT void srandom( uint32_t );
+void srandom( uint32_t );
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/libplatform/platform.h b/mp4v2/libplatform/platform.h
index 633ad7e..eab546a 100644
--- a/mp4v2/libplatform/platform.h
+++ b/mp4v2/libplatform/platform.h
@@ -33,7 +33,6 @@
 #include "libplatform/io/FileSystem.h"
 
 #include "libplatform/number/random.h"
-#include "libplatform/process/process.h"
 #include "libplatform/prog/commandline.h"
 #include "libplatform/prog/option.h"
 #include "libplatform/sys/error.h"
diff --git a/mp4v2/libplatform/platform_posix.h b/mp4v2/libplatform/platform_posix.h
index af5901a..9d4738f 100644
--- a/mp4v2/libplatform/platform_posix.h
+++ b/mp4v2/libplatform/platform_posix.h
@@ -54,14 +54,6 @@ namespace mp4v2 { namespace platform {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-// win32 platform requires O_BINARY when using old open() calls so we add
-// this harmless bit-flag for posix to avoid .cpp platform conditionals
-#ifndef O_BINARY
-#   define O_BINARY  0
-#endif
-
-///////////////////////////////////////////////////////////////////////////////
-
 // ARM seems to require integer instructions operands to have 4-byte alignment
 // so we set this macro to for some int<->string code to manually copy string
 // bytes into an int which aligns it. This is much easier than trying to
diff --git a/mp4v2/libplatform/platform_win32.cpp b/mp4v2/libplatform/platform_win32.cpp
index 7b8c0a2..2e622f8 100644
--- a/mp4v2/libplatform/platform_win32.cpp
+++ b/mp4v2/libplatform/platform_win32.cpp
@@ -71,12 +71,12 @@ struct utf8_len_info
     /**
      * This structure applies to a number >= @p range_min.
      */
-    UINT32      range_min;
+    uint32_t    range_min;
 
     /**
      * This structure applies to a number <= @p range_max.
      */
-    UINT32      range_max;
+    uint32_t    range_max;
 
     /**
      * The number of characters required to encode a number
@@ -117,15 +117,17 @@ std::wstring GetFullPathNameStr(const wchar_t *path)
  * Utf8ToFilename constructor
  *
  * @param utf8string a UTF-8 encoded string that does not
- * begin with \\\?\\ nor \\\?\\UNC\\
+ * begin with \\?\ nor \\?\UNC\
  *
  * @see IsValidUTF16 to see whether the constructor
  * succeeded
  */
-Utf8ToFilename::Utf8ToFilename( const string &utf8string )
+Utf8ToFilename::Utf8ToFilename( const string &_utf8string )
     : _wideCharString( NULL )
       , utf8( _utf8 )
 {
+    string utf8string = StripPrefix( _utf8string );
+
     // See
     // http://msdn.microsoft.com/en-us/library/aa365247%28v=vs.85%29.aspx
     // for notes about path lengths, prefixes, etc.  The
@@ -210,7 +212,7 @@ Utf8ToFilename::~Utf8ToFilename( )
 wchar_t *
 Utf8ToFilename::ConvertToUTF16 ( const string &utf8string )
 {
-    int         num_bytes;
+    size_t      num_bytes;
     size_t      num_chars;
     wchar_t     *retval;
 
@@ -297,13 +299,13 @@ Utf8ToFilename::ConvertToUTF16Buf ( const char      *utf8,
                                     wchar_t         *utf16_buf,
                                     size_t          num_bytes )
 {
-    size_t      i;
-    const UINT8 *next_char;
-    size_t      num_chars;
-    size_t      num_utf16_chars;
-    size_t      num_input_bytes;
-    const UINT8 *p;
-    wchar_t     this_utf16[2];
+    size_t        i;
+    const uint8_t *next_char;
+    size_t        num_chars;
+    size_t        num_utf16_chars;
+    size_t        num_input_bytes;
+    const uint8_t *p;
+    wchar_t       this_utf16[2];
 
     ASSERT(utf8);
     ASSERT(utf16_buf || (num_bytes == 0));
@@ -348,7 +350,7 @@ Utf8ToFilename::ConvertToUTF16Buf ( const char      *utf8,
     // in utf16_buf
     num_utf16_chars = num_bytes / sizeof(wchar_t);
 
-    p = (const UINT8 *)utf8;
+    p = (const uint8_t *)utf8;
     i = 0;
     while (*p && (i < num_utf16_chars))
     {
@@ -414,63 +416,76 @@ Utf8ToFilename::ConvertToUTF16Buf ( const char      *utf8,
 }
 
 /**
- * Accessor for the length of a prefix (i.e. \\\?\\ or
- * \\\?\\UNC\\) that begins a filename
+ * Check for the presence of a prefix (i.e. \\?\) 
+ * at the beginning of a filename
  *
  * @param utf8string the UTF-8 encoded filename to
  * examine
  *
- * @return the length of the prefix of @p utf8string in
- * characters
+ * @return true if @p utf8string begins with a
+ * prefix, false otherwise
  */
-int
-Utf8ToFilename::GetPrefixLen ( const string &utf8string )
+bool
+Utf8ToFilename::HasPrefix ( const string &utf8string )
 {
-    if (utf8string.find("\\\\?\\") == 0)
-    {
-        return strlen("\\\\?\\");
-    }
+    return (utf8string.find("\\\\?\\") == 0);
+}
+
+/**
+ * Strip a prefix (i.e. \\?\ or \\?\UNC\) from a
+ * filename and return the corresponding unprefixed
+ * path
+ *
+ * @param utf8string the UTF-8 encoded filename to
+ * work on
+ *
+ * @return the unprefixed path corresponding to
+ * @p utf8string
+ */
+string
+Utf8ToFilename::StripPrefix ( const string &utf8string )
+{
+    if (!HasPrefix( utf8string ))
+        return utf8string;
 
+    // convert \\?\UNC\server\path to \\server\path
     if (utf8string.find("\\\\?\\UNC\\") == 0)
-    {
-        return strlen("\\\\?\\UNC\\");
-    }
+        return string("\\\\").append(utf8string.substr(8));
 
-    return 0;
+    // just strip Windows \\?\ prefix otherwise
+    return utf8string.substr(4);
 }
 
 /**
  * Determine if a path is absolute or not
  *
  * @param utf8string the UTF-8 encoded path to examine
- * that does not begin with \\\?\\ nor \\\?\\UNC\\
+ * that does not begin with \\?\ nor \\?\UNC\
  *
  * @retval 0 @p utf8string is not an absolute path
  * @retval 1 @p utf8string is an absolute path
- */       
+ */
 int
 Utf8ToFilename::IsAbsolute ( const string &utf8string )
 {
     // Assume utf8string doesn't already start with a
     // long filename prefix (i.e. \\?\ or \\?\UNC\)
     // since the logic here depends on that.
-    ASSERT(GetPrefixLen(utf8string) == 0);
+    ASSERT(!HasPrefix(utf8string));
 
     // Is an empty string absolute or relative?  It's
     // not absolute since we can't tell what
     // drive/volume it's for so say it's relative.
     if (utf8string.length() == 0)
-    {
         return 0;
-    }
-        
+
     // Here we're looking for:
     //  x:   drive relative
     //  x:\  absolute path
-    if (utf8string[1] == ':')
+    if (utf8string.length() > 1 && utf8string[1] == ':')
     {
         // It starts with x:, but is it x:/ ?
-        if ((utf8string.length() >= 2) && IsPathSeparator(utf8string[2]))
+        if ((utf8string.length() > 2) && IsPathSeparator(utf8string[2]))
         {
             // Yup -- it's absolute
             return 1;
@@ -502,11 +517,11 @@ Utf8ToFilename::IsPathSeparator ( char c )
  * Determine if a path is a UNC path
  *
  * @param utf8string the UTF-8 encoded path to examine
- * that does not begin with \\\?\\ nor \\\?\\UNC\\
+ * that does not begin with \\?\ nor \\?\UNC\
  *
  * @retval 0 @p utf8string is not a UNC path
  * @retval 1 @p utf8string is a UNC path
- */       
+ */
 int
 Utf8ToFilename::IsUncPath ( const string &utf8string )
 {
@@ -517,13 +532,11 @@ Utf8ToFilename::IsUncPath ( const string &utf8string )
     // Assume utf8string doesn't already start with a
     // long filename prefix (i.e. \\?\ or \\?\UNC\)
     // since the logic here depends on that.
-    ASSERT(GetPrefixLen(utf8string) == 0);
+    ASSERT(!HasPrefix(utf8string));
 
     // Is an empty string a UNC path?  No.
     if (utf8string.length() == 0)
-    {
         return 0;
-    }
 
     //  Recognize:
     //    //volume/path
@@ -565,10 +578,8 @@ Utf8ToFilename::IsUncPath ( const string &utf8string )
     // but that's someone else's problem.  It's not a
     // UNC path.
     if (num_slashes == 1)
-    {
         return 0;
-    }
-    
+
     // If we're here, we've got two slashes followed by
     // a non-slash.  Something like //foo.  To be a
     // proper UNC path, we need to see a hostname
@@ -690,21 +701,21 @@ Utf8ToFilename::IsUTF16Valid( ) const
  * be valid to dereference depending on the value of @p
  * num_bytes.
  */
-const UINT8 *
-Utf8ToFilename::Utf8DecodeChar ( const UINT8    *utf8_char,
+const uint8_t *
+Utf8ToFilename::Utf8DecodeChar ( const uint8_t  *utf8_char,
                                  size_t         num_bytes,
                                  wchar_t        *utf16,
                                  int            *invalid )
 
 {
-    wchar_t     high_half;
-    int         i;
-    UINT8       len;
-    wchar_t     low_half;
-    UINT8       mask;
-    const UINT8 *p;
-    UINT32      ucs4;
-    int         valid_len;
+    wchar_t       high_half;
+    int           i;
+    uint8_t       len;
+    wchar_t       low_half;
+    uint8_t       mask;
+    const uint8_t *p;
+    uint32_t      ucs4;
+    size_t        valid_len;
 
     ASSERT(utf8_char);
     ASSERT(num_bytes > 0);
@@ -725,7 +736,7 @@ Utf8ToFilename::Utf8DecodeChar ( const UINT8    *utf8_char,
     ** Traverse the UTF-8 encoding and figure out what we've
     ** got.
     */
-    p = (const UINT8 *)(utf8_char);
+    p = (const uint8_t *)(utf8_char);
 
     /*
     ** This is the number of bytes we expect based on the
@@ -998,7 +1009,7 @@ Utf8ToFilename::Utf8DecodeChar ( const UINT8    *utf8_char,
  * UTF-8 encoding of @p ucs4
  */
 size_t
-Utf8ToFilename::Utf8LenFromUcs4 ( UINT32 ucs4 )
+Utf8ToFilename::Utf8LenFromUcs4 ( uint32_t ucs4 )
 {
     size_t      table_idx;
 
@@ -1033,8 +1044,8 @@ Utf8ToFilename::Utf8LenFromUcs4 ( UINT32 ucs4 )
  * @retval [1,6] the number of octets that @p
  * utf8_first_byte should occupy
  */
-UINT8
-Utf8ToFilename::Utf8NumOctets ( UINT8 utf8_first_byte )
+uint8_t
+Utf8ToFilename::Utf8NumOctets ( uint8_t utf8_first_byte )
 {
     /**
      * Here's a mapping from the first byte of a UTF-8
diff --git a/mp4v2/libplatform/platform_win32.h b/mp4v2/libplatform/platform_win32.h
index b7f4a7b..29db012 100644
--- a/mp4v2/libplatform/platform_win32.h
+++ b/mp4v2/libplatform/platform_win32.h
@@ -3,6 +3,12 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 
+#ifdef __MINGW32__
+#   include "libplatform/config.h"
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+
 // mingw needs this to enable some newer 64-bit functions
 #ifdef __MINGW32__
 #   undef  __MSVCRT_VERSION__
@@ -10,12 +16,23 @@
 #endif
 
 // set minimum win32 API requirement to Windows 2000 or higher
-#ifndef _WIN32_WINNT
-#   define _WIN32_WINNT 0x0500
-#endif 
 #ifndef WINVER
-#   define WINVER 0x0500
-#endif 
+#   ifndef _MSC_VER
+#       define WINVER 0x0500
+#   elif _MSC_VER >= 1930 // toolset versions >= 17.0 support Windows 7 or later
+#       define WINVER 0x0601
+#   elif _MSC_VER >= 1910 // toolset versions >= 15.0 support Windows Vista or later
+#       define WINVER 0x0600
+#   elif _MSC_VER >= 1600 // toolset versions >= 10.0 support Windows XP or later
+#       define WINVER 0x0501
+#   else
+#       define WINVER 0x0500
+#   endif
+#endif
+
+#ifndef _WIN32_WINNT
+#   define _WIN32_WINNT WINVER
+#endif
 
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -58,18 +75,17 @@ namespace mp4v2 { namespace platform {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-// If using Visual Studio 2010 or newer these aren't needed since stdint.h is available.
-#if !(defined(_MSC_VER) && _MSC_VER >= 1600)
 // some macros for constant expressions
-#define INT8_C(x)    x
-#define INT16_C(x)   x
-#define INT32_C(x)   x ## L
-#define INT64_C(x)   x ## LL
-
-#define UINT8_C(x)   x
-#define UINT16_C(x)  x
-#define UINT32_C(x)  x ## UL
-#define UINT64_C(x)  x ## ULL
+#ifndef INT8_C
+#   define INT8_C(x)    x
+#   define INT16_C(x)   x
+#   define INT32_C(x)   x ## L
+#   define INT64_C(x)   x ## LL
+
+#   define UINT8_C(x)   x
+#   define UINT16_C(x)  x
+#   define UINT32_C(x)  x ## UL
+#   define UINT64_C(x)  x ## ULL
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -84,11 +100,13 @@ namespace mp4v2 { namespace platform {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-#define snprintf(s,n,...)  _snprintf(s,n,__VA_ARGS__)
 #ifndef strcasecmp
-#define strcasecmp(s1,s2)  _stricmp(s1,s2)
+#   define strcasecmp(s1,s2) _stricmp(s1,s2)
+#endif
+
+#ifndef strncasecmp
+#   define strncasecmp(s1,s2,l) _strnicmp(s1,s2,l)
 #endif
-#define strdup(s)          _strdup(s)
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/libplatform/platform_win32_impl.h b/mp4v2/libplatform/platform_win32_impl.h
index 65a872b..8ad4432 100644
--- a/mp4v2/libplatform/platform_win32_impl.h
+++ b/mp4v2/libplatform/platform_win32_impl.h
@@ -28,7 +28,9 @@ class Utf8ToFilename
     static int          ConvertToUTF16Buf ( const char      *utf8,
                                             wchar_t         *utf16_buf,
                                             size_t          num_bytes );
-    static int          GetPrefixLen ( const string &utf8string );
+
+    static bool         HasPrefix ( const string &utf8string );
+    static string       StripPrefix ( const string &utf8string );
 
     static int          IsAbsolute ( const string &utf8string );
 
@@ -36,16 +38,16 @@ class Utf8ToFilename
 
     static int          IsUncPath ( const string &utf8string );
 
-    static const UINT8  *Utf8DecodeChar (
-        const UINT8     *utf8_char,
-        size_t          num_bytes,
-        wchar_t         *utf16,
-        int             *invalid
+    static const uint8_t    *Utf8DecodeChar (
+        const uint8_t       *utf8_char,
+        size_t              num_bytes,
+        wchar_t             *utf16,
+        int                 *invalid
         );
 
-    static size_t       Utf8LenFromUcs4 ( UINT32 ucs4 );
+    static size_t       Utf8LenFromUcs4 ( uint32_t ucs4 );
 
-    static UINT8        Utf8NumOctets ( UINT8 utf8_first_byte );
+    static uint8_t      Utf8NumOctets ( uint8_t utf8_first_byte );
 
     /**
      * The UTF-8 encoding of the filename actually used
diff --git a/mp4v2/libplatform/process/process.h b/mp4v2/libplatform/process/process.h
deleted file mode 100644
index 446b100..0000000
--- a/mp4v2/libplatform/process/process.h
+++ /dev/null
@@ -1,16 +0,0 @@
-#ifndef MP4V2_PLATFORM_PROCESS_PROCESS_H
-#define MP4V2_PLATFORM_PROCESS_PROCESS_H
-
-/// @namespace mp4v2::platform::process (private) Process.
-/// <b>WARNING: THIS IS A PRIVATE NAMESPACE. NOT FOR PUBLIC CONSUMPTION.</b>
-namespace mp4v2 { namespace platform { namespace process {
-
-///////////////////////////////////////////////////////////////////////////////
-
-MP4V2_EXPORT int32_t getpid();
-
-///////////////////////////////////////////////////////////////////////////////
-
-}}} // namespace mp4v2::platform::process
-
-#endif // MP4V2_PLATFORM_PROCESS_PROCESS_H
diff --git a/mp4v2/libplatform/process/process_posix.cpp b/mp4v2/libplatform/process/process_posix.cpp
deleted file mode 100644
index 74b4e17..0000000
--- a/mp4v2/libplatform/process/process_posix.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "libplatform/impl.h"
-
-namespace mp4v2 { namespace platform { namespace process {
-
-///////////////////////////////////////////////////////////////////////////////
-
-int32_t
-getpid()
-{
-    return ::getpid();
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-}}} // namespace mp4v2::platform::process
diff --git a/mp4v2/libplatform/process/process_win32.cpp b/mp4v2/libplatform/process/process_win32.cpp
deleted file mode 100644
index b784680..0000000
--- a/mp4v2/libplatform/process/process_win32.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-#include "libplatform/impl.h"
-#include <process.h>
-
-namespace mp4v2 { namespace platform { namespace process {
-
-///////////////////////////////////////////////////////////////////////////////
-
-int32_t
-getpid()
-{
-    return ::_getpid();
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-}}} // namespace mp4v2::platform::process
diff --git a/mp4v2/libplatform/prog/commandline_win32.cpp b/mp4v2/libplatform/prog/commandline_win32.cpp
index 1e209a6..67335cd 100644
--- a/mp4v2/libplatform/prog/commandline_win32.cpp
+++ b/mp4v2/libplatform/prog/commandline_win32.cpp
@@ -1,35 +1,24 @@
 #include "libplatform/impl.h"
+#include <shellapi.h>
 
 namespace mp4v2 { namespace platform { namespace prog {
 
-typedef struct
-{
-    int newmode;
-} _startupinfo;
-
-extern "C"
-int __wgetmainargs(int *, wchar_t ***, wchar_t ***, int, _startupinfo *);
-
 CommandLine::CommandLine(int argc, char **argv)
 {
-    wchar_t **wargv, **envp;
-    _startupinfo si = { 0 };
-    __wgetmainargs(&_argc, &wargv, &envp, 1, &si);
+    wchar_t **wargv = CommandLineToArgvW(GetCommandLineW(), &_argc);
 
     _vargv.resize(_argc + 1);
 
     size_t buffer_size = 0;
     for (int i = 0; i < _argc; ++i) {
-	buffer_size +=
-	    WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, 0, 0, 0, 0);
+        buffer_size += WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, 0, 0, 0, 0);
     }
     _commandline.resize(buffer_size);
     char *bp = &_commandline[0], *endp = bp + _commandline.size();
     for (int i = 0; i < _argc; ++i) {
-	int rc = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, bp,
-				     endp - bp, 0, 0);
-	_vargv[i] = bp;
-	bp += rc;
+        int rc = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1, bp, endp - bp, 0, 0);
+        _vargv[i] = bp;
+        bp += rc;
     }
 }
 void CommandLine::get(int *argc, char ***argv)
diff --git a/mp4v2/libplatform/prog/option.cpp b/mp4v2/libplatform/prog/option.cpp
index 645dccf..749e47e 100644
--- a/mp4v2/libplatform/prog/option.cpp
+++ b/mp4v2/libplatform/prog/option.cpp
@@ -244,7 +244,7 @@ parse_long_options(char * const *nargv, const char *options,
     for (i = 0; long_options[i].name; i++) {
         /* find matching long option */
         if (strncmp(current_argv, long_options[i].name,
-                    current_argv_len))
+                    current_argv_len) != 0)
             continue;
 
         if (strlen(long_options[i].name) == current_argv_len) {
diff --git a/mp4v2/libplatform/prog/option.h b/mp4v2/libplatform/prog/option.h
index 9f7a82a..3055c29 100644
--- a/mp4v2/libplatform/prog/option.h
+++ b/mp4v2/libplatform/prog/option.h
@@ -58,7 +58,7 @@ struct MP4V2_EXPORT Option
         //! indicates exactly 1 argument follow option
         REQUIRED_ARG,
         //! indicates 0 or 1 arguments follow option
-        OPTIONAL_ARG,
+        OPTIONAL_ARG
     };
 
     //! contains the option name without leading double-dash
diff --git a/mp4v2/libplatform/sys/error.h b/mp4v2/libplatform/sys/error.h
index 8776458..ebd7ced 100644
--- a/mp4v2/libplatform/sys/error.h
+++ b/mp4v2/libplatform/sys/error.h
@@ -5,9 +5,9 @@ namespace mp4v2 { namespace platform { namespace sys {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-MP4V2_EXPORT int         getLastError    ( );
+             int         getLastError    ( );
 MP4V2_EXPORT const char* getLastErrorStr ( );
-MP4V2_EXPORT const char* getErrorStr     ( int );
+             const char* getErrorStr     ( int );
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/libplatform/time/time.h b/mp4v2/libplatform/time/time.h
index d4d8e7a..2d86423 100644
--- a/mp4v2/libplatform/time/time.h
+++ b/mp4v2/libplatform/time/time.h
@@ -23,7 +23,7 @@ typedef int64_t seconds_t;
 //! @return local-time in milliseconds elapsed since the epoch.
 //!
 ///////////////////////////////////////////////////////////////////////////////
-MP4V2_EXPORT milliseconds_t getLocalTimeMilliseconds();
+milliseconds_t getLocalTimeMilliseconds();
 
 ///////////////////////////////////////////////////////////////////////////////
 //!
@@ -37,11 +37,7 @@ MP4V2_EXPORT milliseconds_t getLocalTimeMilliseconds();
 //! @return local-time in seconds elapsed since the epoch.
 //!
 ///////////////////////////////////////////////////////////////////////////////
-MP4V2_EXPORT seconds_t getLocalTimeSeconds();
-
-///////////////////////////////////////////////////////////////////////////////
-//! @}
-///////////////////////////////////////////////////////////////////////////////
+seconds_t getLocalTimeSeconds();
 
 }}} // namespace mp4v2::platform::time
 
diff --git a/mp4v2/libutil/Timecode.cpp b/mp4v2/libutil/Timecode.cpp
new file mode 100644
index 0000000..53cb0c7
--- /dev/null
+++ b/mp4v2/libutil/Timecode.cpp
@@ -0,0 +1,591 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "libutil/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode::Timecode( const Timecode& obj )
+    : _scale            ( 1.0 )
+    , _duration         ( 0 )
+    , _format           ( FRAME )
+    , _svalue           ( "" )
+    , _hours            ( 0 )
+    , _minutes          ( 0 )
+    , _seconds          ( 0 )
+    , _subseconds       ( 0 )
+    , scale             ( _scale )
+    , duration          ( _duration )
+    , format            ( _format )
+    , svalue            ( _svalue )
+    , hours             ( _hours )
+    , minutes           ( _minutes )
+    , seconds           ( _seconds )
+    , subseconds        ( _subseconds )
+{
+    operator=( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode::Timecode( const string& time_, double scale_ )
+    : _scale            ( scale_ < 1.0 ? 1.0 : scale_ )
+    , _duration         ( 0 )
+    , _format           ( FRAME )
+    , _svalue           ( "" )
+    , _hours            ( 0 )
+    , _minutes          ( 0 )
+    , _seconds          ( 0 )
+    , _subseconds       ( 0 )
+    , scale             ( _scale )
+    , duration          ( _duration )
+    , format            ( _format )
+    , svalue            ( _svalue )
+    , hours             ( _hours )
+    , minutes           ( _minutes )
+    , seconds           ( _seconds )
+    , subseconds        ( _subseconds )
+{
+    parse( time_ );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode::Timecode( uint64_t duration_, double scale_ )
+    : _scale            ( scale_ < 1.0 ? 1.0 : scale_ )
+    , _duration         ( 0 )
+    , _format           ( FRAME )
+    , _svalue           ( "" )
+    , _hours            ( 0 )
+    , _minutes          ( 0 )
+    , _seconds          ( 0 )
+    , _subseconds       ( 0 )
+    , scale             ( _scale )
+    , duration          ( _duration )
+    , format            ( _format )
+    , svalue            ( _svalue )
+    , hours             ( _hours )
+    , minutes           ( _minutes )
+    , seconds           ( _seconds )
+    , subseconds        ( _subseconds )
+{
+    setDuration( duration_ );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+uint64_t
+Timecode::convertDuration( const Timecode& obj ) const
+{
+    if( _scale == obj._scale )
+        return obj._duration;
+
+    return static_cast<uint64_t>( ( _scale / obj._scale ) * obj._duration );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode&
+Timecode::operator=( const Timecode& rhs )
+{
+    _scale    = rhs._scale;
+    _duration = rhs._duration;
+    _format   = FRAME;
+    _svalue   = rhs._svalue;
+
+    _hours      = rhs._hours;
+    _minutes    = rhs._minutes;
+    _seconds    = rhs._seconds;
+    _subseconds = rhs._subseconds;
+
+    return *this;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode&
+Timecode::operator+=( const Timecode& rhs )
+{
+    uint64_t dur = _duration + convertDuration( rhs );
+    // overflow check
+    if( dur < _duration )
+        dur = numeric_limits<uint64_t>::max();
+
+    setDuration( dur );
+    return *this;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode&
+Timecode::operator-=( const Timecode& rhs )
+{
+    uint64_t dur = _duration - convertDuration( rhs );
+    // underflow check
+    if( dur > _duration )
+        dur = 0;
+
+    setDuration( dur );
+    return *this;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator<( const Timecode& obj ) const
+{
+    return _duration < convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator<=( const Timecode& obj ) const
+{
+    return _duration <= convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator>( const Timecode& obj ) const
+{
+    return _duration < convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator>=( const Timecode& obj ) const
+{
+    return _duration < convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator!=( const Timecode& obj ) const
+{
+    return _duration != convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::operator==( const Timecode& obj ) const
+{
+    return _duration == convertDuration( obj );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode
+Timecode::operator+( const Timecode& obj ) const
+{
+    Timecode t( *this );
+    t += obj;
+    return t;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Timecode
+Timecode::operator-( const Timecode& obj ) const
+{
+    Timecode t( *this );
+    t -= obj;
+    return t;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Timecode::parse( const string& time, string* outError )
+{
+    string outErrorPlacebo;
+    string& error = outError ? *outError : outErrorPlacebo;
+    error.clear();
+
+    _format     = FRAME;
+    _hours      = 0;
+    _minutes    = 0;
+    _seconds    = 0;
+    _subseconds = 0;
+
+    // bail if empty
+    if( time.empty() ) {
+        recompute();
+        return false;
+    }
+
+    // count number of ':'
+    int nsect = 0;
+    int nsemi = 0;
+    int ndot  = 0;
+
+    const string::size_type max = time.length();
+    for( string::size_type i = 0; i < max; i++ ) {
+        switch( time[i] ) {
+            case ':':
+                nsect++;
+                break;
+
+            case ';':
+                if( nsemi++ ) {
+                    error = "too many semicolons";
+                    return true;
+                }
+                nsect++;
+                break;
+
+            case '.':
+                if( ndot++ ) {
+                    error = "too many periods";
+                    return true;
+                }
+                nsect++;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    // bail if impossible number of sections
+    if( nsect > 3 ) {
+        recompute();
+        error = "too many sections";
+        return true;
+    }
+
+    enum Target {
+        HOURS,
+        MINUTES,
+        SECONDS,
+        SUBSECONDS
+    };
+
+    // setup target before parsing
+    Target target;
+    uint64_t* tvalue;
+    switch( nsect ) {
+        default:
+        case 0:
+            target = SUBSECONDS;
+            tvalue = &_subseconds;
+            break;
+
+        case 1:
+            target = SECONDS;
+            tvalue = &_seconds;
+            break;
+
+        case 2:
+            target = MINUTES;
+            tvalue = &_minutes;
+            break;
+
+        case 3:
+            target = HOURS;
+            tvalue = &_hours;
+            break;
+    }
+
+    istringstream convert;
+    string tbuffer;
+    for( string::size_type i = 0; i < max; i++ ) {
+        const char c = time[i];
+        switch( c ) {
+            case ':':
+                switch( target ) {
+                    case HOURS:
+                        convert.clear();
+                        convert.str( tbuffer );
+                        if( !tbuffer.empty() && !(convert >> *tvalue) ) {
+                            error = "failed to convert integer";
+                            return true;
+                        }
+                        tbuffer.clear();
+                        target = MINUTES;
+                        tvalue = &_minutes;
+                        break;
+
+                    case MINUTES:
+                        convert.clear();
+                        convert.str( tbuffer );
+                        if( !tbuffer.empty() && !(convert >> *tvalue) ) {
+                            error = "failed to convert integer";
+                            return true;
+                        }
+                        tbuffer.clear();
+                        target = SECONDS;
+                        tvalue = &_seconds;
+                        break;
+
+                    case SECONDS:
+                        convert.clear();
+                        convert.str( tbuffer );
+                        if( !tbuffer.empty() && !(convert >> *tvalue) ) {
+                            error = "failed to convert integer";
+                            return true;
+                        }
+                        tbuffer.clear();
+                        target = SUBSECONDS;
+                        tvalue = &_subseconds;
+                        break;
+
+                    default:
+                    case SUBSECONDS:
+                        error = "unexpected char ':'";
+                        return true;
+                }
+                break;
+
+            case '.':
+            {
+                if( target != SECONDS ) {
+                    error = "unexpected char '.'";
+                    return true;
+                }
+                _format = DECIMAL;
+                convert.clear();
+                convert.str( tbuffer );
+                if( !tbuffer.empty() && !(convert >> *tvalue) ) {
+                    error = "failed to convert integer";
+                    return true;
+                }
+                tbuffer.clear();
+                target = SUBSECONDS;
+                tvalue = &_subseconds;
+                break;
+            }
+
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+                tbuffer += c;
+                if( tbuffer.length() > 16 ) {
+                    error = "overflow";
+                    return true;
+                }
+                break;
+
+            default:
+                error = "unexpected char '";
+                error += c;
+                error += "'";
+                return true;
+        }
+    }
+
+    // apply final section
+    if( !tbuffer.empty() ) {
+        convert.clear();
+        convert.str( tbuffer );
+        if( !tbuffer.empty() && !(convert >> *tvalue) ) {
+            error = "failed to convert integer";
+            return true;
+        }
+    }
+
+    // special post processing
+    switch( _format ) {
+        case FRAME:
+        default:
+            break;
+
+        case DECIMAL:
+        {
+            double div = std::pow( 10.0, static_cast<double>(tbuffer.length()) );
+            if( div < 1.0 )
+                div = 1.0;
+            *tvalue = static_cast<uint64_t>( static_cast<double>(*tvalue) / div * std::ceil( _scale ));
+            break;
+        }
+    }
+
+    recompute();
+    return false;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::recompute()
+{
+    // case: 29.97 becomes 30.0
+    // case: 30.0  becomes 30.0
+    const uint64_t iscale = uint64_t( std::ceil( _scale ));
+
+    if( _subseconds > iscale - 1 ) {
+        uint64_t n = _subseconds / iscale;
+        _seconds += n;
+        _subseconds -= n * iscale;
+    }
+
+    if( _seconds > 59 ) {
+        uint64_t n = _seconds / 60;
+        _minutes += n;
+        _seconds -= n * 60;
+    }
+
+    if( _minutes > 59 ) {
+        uint64_t n = _minutes / 60;
+        _hours += n;
+        _minutes -= n * 60;
+    }
+
+    _duration = _subseconds + (iscale * _seconds) + (iscale * _minutes * 60) + (iscale * _hours * 3600);
+
+    ostringstream oss;
+    oss << setfill('0') << right
+        << setw(2) << _hours
+        << ':'
+        << setw(2) << _minutes
+        << ':'
+        << setw(2) << _seconds;
+
+    switch( _format ) {
+        case FRAME:
+            oss << ':' << setw(2) << setfill( '0' ) << _subseconds;
+            break;
+
+        case DECIMAL:
+        {
+            oss << '.' << setw(3) << setfill( '0' ) << static_cast<uint64_t>(_subseconds / _scale * 1000.0 + 0.5);
+            break;
+        }
+    }
+
+    _svalue = oss.str();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::reset()
+{
+    setDuration( 0 );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setDuration( uint64_t duration_, double scale_ )
+{
+    if( scale_ != 0.0 ) {
+        _scale = scale_;
+        if( _scale < 1.0 )
+            _scale = 1.0;
+    }
+
+    _duration = duration_;
+
+    const uint64_t iscale = uint64_t( std::ceil( _scale ));
+    uint64_t i = _duration;
+
+    _hours = i / (iscale * 3600);
+    i -= (iscale * 3600 * _hours);
+
+    _minutes = i / (iscale * 60);
+    i -= (iscale * 60 * _minutes);
+
+    _seconds = i / iscale;
+    i -= (iscale * _seconds);
+
+    _subseconds = i;
+
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setFormat( Format format_ )
+{
+    _format = format_;
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setHours( uint64_t hours_ )
+{
+    _hours = hours_;
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setMinutes( uint64_t minutes_ )
+{
+    _minutes = minutes_;
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setScale( double scale_ )
+{
+    const double oldscale = _scale;
+    _scale = scale_;
+    if( _scale < 1.0 )
+        _scale = 1.0;
+
+    _subseconds = static_cast<uint64_t>( (_scale / oldscale) * _subseconds );
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setSeconds( uint64_t seconds_ )
+{
+    _seconds = seconds_;
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Timecode::setSubseconds( uint64_t subseconds_ )
+{
+    _subseconds = subseconds_;
+    recompute();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
diff --git a/mp4v2/libutil/Timecode.h b/mp4v2/libutil/Timecode.h
new file mode 100644
index 0000000..3464135
--- /dev/null
+++ b/mp4v2/libutil/Timecode.h
@@ -0,0 +1,119 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef MP4V2_UTIL_TIMECODE_H
+#define MP4V2_UTIL_TIMECODE_H
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+/// Class representing SMPTE timecode.
+///
+/// Objects of this class represent a specific time or duration and can
+/// be converted to/from string values, and various epochs.
+///
+/// The standard pattern for string representation is as follows:
+///     @li HH:MM:SS:FF
+///     @li HH:MM:SS.DDD
+///
+/// where:
+///     @li <b>HH</b> specifies hours
+///     @li <b>MM</b> specifies minutes
+///     @li <b>SS</b> specifies seconds
+///     @li <b>:</b> specifies normal timecode
+///     @li <b>FF</b> specifies the frame number
+///     @li <b>.</b> specifies decimal fractions of a second follow
+///     @li <b>DDD</b> specifies decimal fractions of a second, rounded down to closest scale
+///
+class Timecode {
+public:
+    enum Format {
+        FRAME,
+        DECIMAL
+    };
+
+private:
+    double   _scale;
+    uint64_t _duration;
+    Format   _format;
+    string   _svalue;
+
+    uint64_t _hours;
+    uint64_t _minutes;
+    uint64_t _seconds;
+    uint64_t _subseconds;
+
+public:
+    const double&   scale;
+    const uint64_t& duration;
+    const Format&   format;
+    const string&   svalue;
+
+    const uint64_t& hours;
+    const uint64_t& minutes;
+    const uint64_t& seconds;
+    const uint64_t& subseconds;
+
+public:
+    Timecode( const Timecode& );
+    explicit Timecode( const string&, double = 1.0 );
+    explicit Timecode( uint64_t = 0, double = 1.0 );
+
+    Timecode& operator=  ( const Timecode& );
+    Timecode& operator+= ( const Timecode& );
+    Timecode& operator-= ( const Timecode& );
+
+    bool operator<  ( const Timecode& ) const;
+    bool operator<= ( const Timecode& ) const;
+    bool operator>  ( const Timecode& ) const;
+    bool operator>= ( const Timecode& ) const;
+    bool operator!= ( const Timecode& ) const;
+    bool operator== ( const Timecode& ) const;
+
+    Timecode operator+ ( const Timecode& ) const;
+    Timecode operator- ( const Timecode& ) const;
+
+    bool parse( const string&, string* = NULL );
+
+    void reset();
+
+    void setScale    ( double );
+    void setDuration ( uint64_t, double = 0.0 );
+    void setFormat   ( Format );
+
+    void setHours      ( uint64_t );
+    void setMinutes    ( uint64_t );
+    void setSeconds    ( uint64_t );
+    void setSubseconds ( uint64_t );
+
+private:
+    uint64_t convertDuration( const Timecode& ) const;
+    void recompute();
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+#endif // MP4V2_UTIL_TIMECODE_H
diff --git a/mp4v2/libutil/TrackModifier.cpp b/mp4v2/libutil/TrackModifier.cpp
new file mode 100644
index 0000000..a2497cb
--- /dev/null
+++ b/mp4v2/libutil/TrackModifier.cpp
@@ -0,0 +1,504 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "libutil/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+TrackModifier::TrackModifier( MP4FileHandle file_, uint16_t trackIndex_ )
+    : _track          ( refTrackAtom( *static_cast<MP4File*>(file_), trackIndex_ ))
+    , _props          ( *this ) // must come after _track is initialized
+    , _enabled        ( false )
+    , _inMovie        ( false )
+    , _inPreview      ( false )
+    , _layer          ( 0 )
+    , _alternateGroup ( 0 )
+    , _volume         ( 1.0f )
+    , _width          ( 0.0f )
+    , _height         ( 0.0f )
+    , _language       ( bmff::ILC_UND )
+    , _handlerType    ( "" )
+    , _handlerName    ( "" )
+    , _userDataName   ( "" )
+    , file            ( *static_cast<MP4File*>(file_) )
+    , trackIndex      ( trackIndex_ )
+    , trackId         ( MP4FindTrackId( file_, trackIndex_ ))
+    , enabled         ( _enabled )
+    , inMovie         ( _inMovie )
+    , inPreview       ( _inPreview )
+    , layer           ( _layer )
+    , alternateGroup  ( _alternateGroup )
+    , volume          ( _volume )
+    , width           ( _width )
+    , height          ( _height )
+    , language        ( _language )
+    , handlerType     ( _handlerType )
+    , handlerName     ( _handlerName )
+    , userDataName    ( _userDataName )
+{
+    fetch();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+TrackModifier::~TrackModifier()
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::dump( ostream& out, const string& xind )
+{
+    const uint32_t w = 14;
+    const string eq = " = ";
+    const string ind = "  ";
+
+    out << left << xind << "track[" << trackIndex << "] id=" << trackId
+        << '\n' << xind << ind << setw( w ) << "type" << eq << toStringTrackType( handlerType )
+        << '\n' << xind << ind << setw( w ) << "enabled" << eq << toString( enabled )
+        << '\n' << xind << ind << setw( w ) << "inMovie"  << eq << toString( inMovie )
+        << '\n' << xind << ind << setw( w ) << "inPreview"  << eq << toString( inPreview )
+        << '\n' << xind << ind << setw( w ) << "layer"  << eq << layer
+        << '\n' << xind << ind << setw( w ) << "alternateGroup"  << eq << alternateGroup
+        << '\n' << xind << ind << setw( w ) << "volume"  << eq << toString( volume, 8, 8 )
+        << '\n' << xind << ind << setw( w ) << "width"  << eq << toString( width, 16, 16 )
+        << '\n' << xind << ind << setw( w ) << "height"  << eq << toString( height, 16, 16 )
+        << '\n' << xind << ind << setw( w ) << "language"  << eq << bmff::enumLanguageCode.toString( language, true )
+        << '\n' << xind << ind << setw( w ) << "handlerName"  << eq << handlerName;
+
+    out << '\n' << xind << ind << setw( w ) << "userDataName"  << eq
+        << ( _props.userDataName ? userDataName : "<absent>" );
+
+    out << '\n';
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::fetch()
+{
+    _props.update();
+
+    const uint32_t flags = _props.flags.GetValue();
+    _enabled   = flags & 0x01;
+    _inMovie   = flags & 0x02;
+    _inPreview = flags & 0x04;
+
+    _layer          = _props.layer.GetValue();
+    _alternateGroup = _props.alternateGroup.GetValue();
+    _volume         = _props.volume.GetValue();
+    _width          = _props.width.GetValue();
+    _height         = _props.height.GetValue();
+
+    _language     = _props.language.GetValue();
+    _handlerType  = _props.handlerType.GetValue();
+    _handlerName  = _props.handlerName.GetValue();
+
+    if( _props.userDataName ) {
+        uint8_t* buffer;
+        uint32_t size;
+        _props.userDataName->GetValue( &buffer, &size );
+        _userDataName = string( reinterpret_cast<char*>(buffer), size );
+        _userDataName.resize( strlen( _userDataName.c_str() ) );
+    }
+    else {
+        _userDataName.clear();
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool&
+TrackModifier::fromString( const string& src, bool& dst )
+{
+    if( src == "true" )
+        dst = true;
+    else if ( src == "false" )
+        dst = false;
+    else {
+        istringstream iss( src );
+        iss >> dst;
+        if( iss.rdstate() != ios::eofbit ) {
+            ostringstream oss;
+            oss << "invalid value: " << src;
+            throw new EXCEPTION(oss.str());
+        }
+    }
+
+    return dst;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+float&
+TrackModifier::fromString( const string& src, float& dst )
+{
+    istringstream iss( src );
+    iss >> dst;
+    if( iss.rdstate() != ios::eofbit ) {
+        ostringstream oss;
+        oss << "invalid value: " << src;
+        throw new EXCEPTION(oss.str());
+    }
+
+    return dst;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+uint16_t&
+TrackModifier::fromString( const string& src, uint16_t& dst )
+{
+    istringstream iss( src );
+    iss >> dst;
+    if( iss.rdstate() != ios::eofbit ) { 
+        ostringstream oss;
+        oss << "invalid value: " << src;
+        throw new EXCEPTION(oss.str());
+    }   
+
+    return dst;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackModifier::hasUserDataName() const
+{
+    return _props.userDataName != NULL;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+MP4Atom&
+TrackModifier::refTrackAtom( MP4File& file, uint16_t index )
+{
+    MP4Atom& root = *file.FindAtom( NULL );
+
+    ostringstream oss;
+    oss << "moov.trak[" << index << "]";
+    MP4Atom* trak = root.FindAtom( oss.str().c_str() );
+    if( !trak ) {
+        oss.str( "" );
+        oss << "trackIndex " << index << " not found";
+        throw new EXCEPTION(oss.str());
+    }
+
+    return *trak;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::removeUserDataName()
+{
+    MP4Atom* name = _track.FindAtom( "trak.udta.name" );
+    if( name )
+        name->GetParentAtom()->DeleteChildAtom( name );
+
+    MP4Atom* udta = _track.FindAtom( "trak.udta" );
+    if( udta && !udta->GetNumberOfChildAtoms() )
+        udta->GetParentAtom()->DeleteChildAtom( udta );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setAlternateGroup( uint16_t value )
+{
+    _props.alternateGroup.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setAlternateGroup( const string& value )
+{
+    uint16_t tmp;
+    setAlternateGroup( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setEnabled( bool value )
+{
+    _enabled = value;
+    _props.flags.SetValue( (_enabled ? 0x01 : 0) | (_inMovie ? 0x02 : 0) | (_inPreview ? 0x04 : 0) );
+    fetch();
+}
+
+void
+TrackModifier::setEnabled( const string& value )
+{
+    bool tmp;
+    setEnabled( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setHandlerName( const string& value )
+{
+    _props.handlerName.SetValue( value.c_str() );
+    fetch();
+}
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setHeight( float value )
+{
+    _props.height.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setHeight( const string& value )
+{
+    float tmp;
+    setHeight( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setInMovie( bool value )
+{
+    _inMovie = value;
+    _props.flags.SetValue( (_enabled ? 0x01 : 0) | (_inMovie ? 0x02 : 0) | (_inPreview ? 0x04 : 0) );
+    fetch();
+}
+
+void
+TrackModifier::setInMovie( const string& value )
+{
+    bool tmp;
+    setInMovie( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setInPreview( bool value )
+{
+    _inPreview = value;
+    _props.flags.SetValue( (_enabled ? 0x01 : 0) | (_inMovie ? 0x02 : 0) | (_inPreview ? 0x04 : 0) );
+    fetch();
+}
+
+void
+TrackModifier::setInPreview( const string& value )
+{
+    bool tmp;
+    setInPreview( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setLanguage( bmff::LanguageCode value )
+{
+    _props.language.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setLanguage( const string& value )
+{
+    setLanguage( bmff::enumLanguageCode.toType( value ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setLayer( uint16_t value )
+{
+    _props.layer.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setLayer( const string& value )
+{
+    uint16_t tmp;
+    setLayer( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setUserDataName( const string& value )
+{
+    if( !_props.userDataName ) {
+        ostringstream oss;
+        oss << "moov.trak[" << trackIndex << "]";
+        file.AddDescendantAtoms( oss.str().c_str(), "udta.name" );
+        _props.update();
+    }
+
+    _props.userDataName->SetValue( reinterpret_cast<const uint8_t*>(value.c_str()), (uint32_t)value.size() );
+    fetch();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setVolume( float value )
+{
+    _props.volume.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setVolume( const string& value )
+{
+    float tmp;
+    setVolume( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::setWidth( float value )
+{
+    _props.width.SetValue( value );
+    fetch();
+}
+
+void
+TrackModifier::setWidth( const string& value )
+{
+    float tmp;
+    setWidth( fromString( value, tmp ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+string
+TrackModifier::toString( bool value )
+{
+    ostringstream oss;
+    oss << (value ? "true" : "false");
+    return oss.str();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+string
+TrackModifier::toString( float value, uint8_t i, uint8_t f )
+{
+    ostringstream oss;
+    oss << fixed << setprecision(f <= 8 ? 4 : 8) << value;
+    return oss.str();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+string
+TrackModifier::toStringTrackType( const string& code )
+{
+    if( !code.compare( "vide" ))    // 14496-12
+        return "video";
+    if( !code.compare( "soun" ))    // 14496-12
+        return "audio";
+    if( !code.compare( "hint" ))    // 14496-12
+        return "hint";
+
+    if( !code.compare( "text" ))    // QTFF
+        return "text";
+    if( !code.compare( "tmcd" ))    // QTFF
+        return "timecode";
+
+    if( !code.compare( "subt" ))    // QTFF
+        return "subtitle";
+
+    return string( "(" ) + code + ")";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+TrackModifier::Properties::Properties( TrackModifier& trackModifier_ )
+    : _trackModifier ( trackModifier_ )
+    , flags          ( static_cast<MP4Integer24Property&>   ( refProperty(  "trak.tkhd.flags" )))
+    , layer          ( static_cast<MP4Integer16Property&>   ( refProperty(  "trak.tkhd.layer" )))
+    , alternateGroup ( static_cast<MP4Integer16Property&>   ( refProperty(  "trak.tkhd.alternate_group" )))
+    , volume         ( static_cast<MP4Float32Property&>     ( refProperty(  "trak.tkhd.volume" )))
+    , width          ( static_cast<MP4Float32Property&>     ( refProperty(  "trak.tkhd.width" )))
+    , height         ( static_cast<MP4Float32Property&>     ( refProperty(  "trak.tkhd.height" )))
+    , language       ( static_cast<MP4LanguageCodeProperty&>( refProperty(  "trak.mdia.mdhd.language" )))
+    , handlerType    ( static_cast<MP4StringProperty&>      ( refProperty(  "trak.mdia.hdlr.handlerType" )))
+    , handlerName    ( static_cast<MP4StringProperty&>      ( refProperty(  "trak.mdia.hdlr.name" )))
+    , userDataName   ( static_cast<MP4BytesProperty*>       ( findProperty( "trak.udta.name.value" )))
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+MP4Property*
+TrackModifier::Properties::findProperty( const char* name )
+{
+    MP4Property* property;
+    if( !_trackModifier._track.FindProperty( name, &property ))
+        return NULL;
+
+    return property;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+MP4Property&
+TrackModifier::Properties::refProperty( const char* name )
+{
+    MP4Property* property;
+    if( !_trackModifier._track.FindProperty( name, &property )) {
+        ostringstream oss;
+        oss << "trackId " << _trackModifier.trackId << " property '" << name << "' not found";
+        throw new EXCEPTION(oss.str());
+    }
+
+    return *property;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::Properties::update()
+{
+    // update optional properties
+    updateProperty( "trak.udta.name.value", reinterpret_cast<MP4Property**>( &userDataName ));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+TrackModifier::Properties::updateProperty( const char* name, MP4Property** pp )
+{
+    *pp = NULL;
+    _trackModifier._track.FindProperty( name, pp );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
diff --git a/mp4v2/libutil/TrackModifier.h b/mp4v2/libutil/TrackModifier.h
new file mode 100644
index 0000000..798a061
--- /dev/null
+++ b/mp4v2/libutil/TrackModifier.h
@@ -0,0 +1,160 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef MP4V2_UTIL_TRACKMODIFIER_H
+#define MP4V2_UTIL_TRACKMODIFIER_H
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+class MP4V2_EXPORT TrackModifier
+{
+private:
+    class Properties
+    {
+    private:
+        TrackModifier& _trackModifier;
+
+    public:
+        Properties( TrackModifier& );
+
+        void update();
+
+        MP4Integer24Property&    flags;
+        MP4Integer16Property&    layer;
+        MP4Integer16Property&    alternateGroup;
+        MP4Float32Property&      volume;
+        MP4Float32Property&      width;
+        MP4Float32Property&      height;
+        MP4LanguageCodeProperty& language;
+        MP4StringProperty&       handlerType;
+        MP4StringProperty&       handlerName;
+        MP4BytesProperty*        userDataName;
+
+    private:
+        MP4Property& refProperty( const char* );
+        MP4Property* findProperty( const char* );
+        void updateProperty( const char*, MP4Property** );
+    };
+
+    friend class Properties;
+
+private:
+    static MP4Atom& refTrackAtom( MP4File&, uint16_t );
+
+private:
+    MP4Atom&   _track;
+    Properties _props;
+
+    // Track Header
+    bool     _enabled;
+    bool     _inMovie;
+    bool     _inPreview;
+    uint16_t _layer;
+    uint16_t _alternateGroup;
+    float    _volume;
+    float    _width;
+    float    _height;
+
+    // Media Header
+    bmff::LanguageCode _language;
+
+    // Handler Reference
+    string _handlerType;
+    string _handlerName;
+
+    // User Data name
+    string _userDataName;
+
+public:
+    MP4File&         file;
+    const uint16_t   trackIndex;
+    const MP4TrackId trackId;
+
+    const bool&     enabled;
+    const bool&     inMovie;
+    const bool&     inPreview;
+    const uint16_t& layer;
+    const uint16_t& alternateGroup;
+    const float&    volume;
+    const float&    width;
+    const float&    height;
+
+    const bmff::LanguageCode& language;
+
+    const string& handlerType;
+    const string& handlerName;
+
+    const string& userDataName;
+
+public:
+    TrackModifier( MP4FileHandle, uint16_t );
+    ~TrackModifier();
+
+    void setEnabled        ( bool );
+    void setInMovie        ( bool );
+    void setInPreview      ( bool );
+    void setLayer          ( uint16_t );
+    void setAlternateGroup ( uint16_t );
+    void setVolume         ( float );
+    void setWidth          ( float );
+    void setHeight         ( float );
+    void setLanguage       ( bmff::LanguageCode );
+    void setHandlerName    ( const string& );
+    void setUserDataName   ( const string& );
+
+    // set by string
+    void setEnabled        ( const string& );
+    void setInMovie        ( const string& );
+    void setInPreview      ( const string& );
+    void setLayer          ( const string& );
+    void setAlternateGroup ( const string& );
+    void setVolume         ( const string& );
+    void setWidth          ( const string& );
+    void setHeight         ( const string& );
+    void setLanguage       ( const string& );
+
+    bool hasUserDataName() const;
+    void removeUserDataName();
+
+    void dump( ostream&, const string& );
+
+private:
+    void fetch();
+
+    static string toString( bool );
+    static string toString( float, uint8_t, uint8_t );
+
+    static bool&     fromString( const string&, bool& );
+    static float&    fromString( const string&, float& );
+    static uint16_t& fromString( const string&, uint16_t& );
+
+    static string toStringTrackType( const string& );
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+#endif // MP4V2_UTIL_TRACKMODIFIER_H
diff --git a/mp4v2/libutil/Utility.cpp b/mp4v2/libutil/Utility.cpp
new file mode 100644
index 0000000..dc9e968
--- /dev/null
+++ b/mp4v2/libutil/Utility.cpp
@@ -0,0 +1,755 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "libutil/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::Utility( const string& name_, int argc_, char** argv_ )
+    : _commandLine      (argc_, argv_)
+    , _longOptions      ( NULL )
+    , _name             ( name_ )
+    , _optimize         ( false )
+    , _dryrun           ( false )
+    , _keepgoing        ( false )
+    , _overwrite        ( false )
+    , _force            ( false )
+    , _debug            ( 0 )
+    , _verbosity        ( 1 )
+    , _jobCount         ( 0 )
+    , _jobTotal         ( 0 )
+    , _debugImplicits   ( false )
+    , _group            ( "OPTIONS" )
+
+,STD_OPTIMIZE( 'z', false, "optimize", false, LC_NONE, "optimize mp4 file after modification" )
+,STD_DRYRUN( 'y', false, "dryrun", false, LC_NONE, "do not actually create or modify any files" )
+,STD_KEEPGOING( 'k', false, "keepgoing", false, LC_NONE, "continue batch processing even after errors" )
+,STD_OVERWRITE( 'o', false, "overwrite", false, LC_NONE, "overwrite existing files when creating" )
+,STD_FORCE( 'f', false, "force", false, LC_NONE, "force overwrite even if file is read-only" )
+,STD_QUIET( 'q', false, "quiet", false, LC_NONE, "equivalent to --verbose 0" )
+,STD_DEBUG( 'd', false, "debug", true, LC_DEBUG, "increase debug or long-option to set NUM", "NUM",
+    // 79-cols, inclusive, max desired width
+    // |----------------------------------------------------------------------------|
+    "\nDEBUG LEVELS (for raw mp4 file I/O)"
+    "\n  0  supressed"
+    "\n  1  add warnings and errors (default)"
+    "\n  2  add table details"
+    "\n  3  add implicits"
+    "\n  4  everything" )
+,STD_VERBOSE( 'v', false, "verbose", true, LC_VERBOSE, "increase verbosity or long-option to set NUM", "NUM",
+    // 79-cols, inclusive, max desired width
+    // |----------------------------------------------------------------------------|
+    "\nVERBOSE LEVELS"
+    "\n  0  warnings and errors"
+    "\n  1  normal informative messages (default)"
+    "\n  2  more informative messages"
+    "\n  3  everything" )
+,STD_HELP( 'h', false, "help", false, LC_HELP, "print brief help or long-option for extended help" )
+,STD_VERSION( 0, false, "version", false, LC_VERSION, "print version information and exit" )
+,STD_VERSIONX( 0, false, "versionx", false, LC_VERSIONX, "print extended version information", "ARG", "", true )
+
+{
+    debugUpdate( 1 );
+
+    _usage = "<UNDEFINED>";
+    _description = "<UNDEFINED>";
+    _groups.push_back( &_group );
+    _commandLine.get(&_argc, &_argv);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::~Utility()
+{
+    delete[] _longOptions;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::batch( int argi )
+{
+    _jobCount = 0;
+    _jobTotal = _argc - argi;
+
+    // nothing to be done
+    if( !_jobTotal )
+        return SUCCESS;
+
+    bool batchResult = FAILURE;
+    for( int i = argi; i < _argc; i++ ) {
+        bool subResult = FAILURE;
+        try {
+            if( !job( _argv[i] )) {
+                batchResult = SUCCESS;
+                subResult = SUCCESS;
+            }
+        }
+        catch( Exception* x ) {
+            mp4v2::impl::log.errorf(*x);
+            delete x;
+        }
+ 
+        if( !_keepgoing && subResult == FAILURE )
+            return FAILURE;
+    }
+    
+    return batchResult;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::debugUpdate( uint32_t debug )
+{
+    MP4LogLevel level;
+
+    _debug = debug;
+    verbose2f( "debug level: %u\n", _debug );
+
+    switch( _debug ) {
+        case 0:
+            level = MP4_LOG_NONE;
+            _debugImplicits = false;
+            break;
+
+        case 1:
+            level = MP4_LOG_ERROR;
+            _debugImplicits = false;
+            break;
+
+        case 2:
+            level = MP4_LOG_VERBOSE2;
+            _debugImplicits = false;
+            break;
+
+        case 3:
+            level = MP4_LOG_VERBOSE2;
+            _debugImplicits = true;
+            break;
+
+        case 4:
+        default:
+            level = MP4_LOG_VERBOSE4;
+            _debugImplicits = true;
+            break;
+    }
+
+    MP4LogSetLevel(level);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::dryrunAbort()
+{
+    if( !_dryrun )
+        return false;
+
+    verbose2f( "skipping: dry-run mode enabled\n" );
+    return true;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::errf( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+    vfprintf( stderr, format, ap );
+    va_end( ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::formatGroups()
+{
+    // determine longest long-option [+space +argname]
+    int longMax = 0;
+    list<Group*>::reverse_iterator ie = _groups.rend();
+    for( list<Group*>::reverse_iterator it = _groups.rbegin(); it != ie; ++it ) {
+        Group& group = **it;
+        const Group::List::const_iterator ieo = group.options.end();
+        for( Group::List::const_iterator ito = group.options.begin(); ito != ieo; ++ito ) {
+            const Option& option = **ito;
+            if( option.hidden )
+                continue;
+
+            int len = (int)option.lname.length();
+            if( option.lhasarg )
+                len += 1 + (int)option.argname.length();
+            if( len > longMax )
+                longMax = len;
+        }
+    }
+
+    // format help output (no line-wrapping yet)
+    ostringstream oss;
+
+    int groupCount = 0;
+    int optionCount = 0;
+    ie = _groups.rend();
+    for( list<Group*>::reverse_iterator it = _groups.rbegin(); it != ie; ++it, groupCount++ ) {
+        if( groupCount )
+            oss << '\n';
+        Group& group = **it;
+        oss << '\n' << group.name;
+        const Group::List::const_iterator ieo = group.options.end();
+        for( Group::List::const_iterator ito = group.options.begin(); ito != ieo; ++ito, optionCount++ ) {
+            const Option& option = **ito;
+            if( option.hidden )
+                continue;
+
+            oss << "\n ";
+
+            if( option.scode == 0 )
+                oss << "    --";
+            else
+                oss << '-' << option.scode << ", --";
+
+            if( option.lhasarg ) {
+                oss << option.lname << ' ' << option.argname;
+                oss << setw( longMax - option.lname.length() - 1 - option.argname.length() ) << "";
+            }
+            else {
+                oss << setw( longMax ) << left << option.lname;
+            }
+
+            oss << "  ";
+
+            const string::size_type imax = option.descr.length();
+            for( string::size_type i = 0; i < imax; i++ )
+                oss << option.descr[i];
+        }
+    }
+
+    _help = oss.str();
+
+    // allocate and populate C-style options
+    delete[] _longOptions;
+    _longOptions = new prog::Option[optionCount + 1];
+
+    // fill EOL marker
+    _longOptions[optionCount].name = NULL;
+    _longOptions[optionCount].type = prog::Option::NO_ARG;
+    _longOptions[optionCount].flag = 0;
+    _longOptions[optionCount].val  = 0;
+
+    _shortOptions.clear();
+
+    int optionIndex = 0;
+    ie = _groups.rend();
+    for( list<Group*>::reverse_iterator it = _groups.rbegin(); it != ie; ++it ) {
+        Group& group = **it;
+        const Group::List::const_iterator ieo = group.options.end();
+        for( Group::List::const_iterator ito = group.options.begin(); ito != ieo; ++ito, optionIndex++ ) {
+            const Option& a = **ito;
+            prog::Option& b = _longOptions[optionIndex];
+
+            b.name = const_cast<char*>(a.lname.c_str());
+            b.type = a.lhasarg ? prog::Option::REQUIRED_ARG : prog::Option::NO_ARG;
+            b.flag = 0;
+            b.val  = (a.lcode == LC_NONE) ? a.scode : a.lcode;
+
+            if( a.scode != 0 ) {
+                _shortOptions += a.scode;
+                if( a.shasarg )
+                    _shortOptions += ':';
+            }
+        }
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::job( const string& arg )
+{
+    verbose2f( "job begin: %s\n", arg.c_str() );
+
+    // perform job
+    JobContext job( arg );
+    bool result = FAILURE;
+    try {
+        result = utility_job( job );
+    }
+    catch( Exception* x ) {
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+
+    // close file handle flagged with job
+    if( job.fileHandle != MP4_INVALID_FILE_HANDLE ) {
+        verbose2f( "closing %s\n", job.file.c_str() );
+        MP4Close( job.fileHandle );
+
+        // invoke optimize if flagged
+        if( _optimize && job.optimizeApplicable ) {
+            verbose1f( "optimizing %s\n", job.file.c_str() );
+            if( !MP4Optimize( job.file.c_str(), NULL ))
+                hwarnf( "optimize failed: %s\n", job.file.c_str() );
+        }
+    }
+
+    // free data flagged with job
+    list<void*>::iterator ie = job.tofree.end();
+    for( list<void*>::iterator it = job.tofree.begin(); it != ie; ++it )
+        free( *it );
+
+
+    verbose2f( "job end\n" );
+    _jobCount++;
+    return result;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::herrf( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+
+    if( _keepgoing ) {
+        fprintf( stdout, "WARNING: " );
+        vfprintf( stdout, format, ap );
+    }
+    else {
+        fprintf( stderr, "ERROR: " );
+        vfprintf( stderr, format, ap );
+    }
+
+    va_end( ap );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::hwarnf( const char* format, ... )
+{
+    fprintf( stdout, "WARNING: " );
+    va_list ap;
+    va_start( ap, format );
+    vfprintf( stdout, format, ap );
+    va_end( ap );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::outf( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+    vfprintf( stdout, format, ap );
+    va_end( ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::printHelp( bool extended, bool toerr )
+{
+    ostringstream oss;
+    oss << "Usage: " << _name << " " << _usage << '\n' << _description << '\n' << _help;
+
+    if( extended ) {
+        const list<Group*>::reverse_iterator ie = _groups.rend();
+        for( list<Group*>::reverse_iterator it = _groups.rbegin(); it != ie; ++it ) {
+            Group& group = **it;
+            const Group::List::const_iterator ieo = group.options.end();
+            for( Group::List::const_iterator ito = group.options.begin(); ito != ieo; ++ito ) {
+                const Option& option = **ito;
+                if( option.help.empty() )
+                    continue;
+
+                oss << '\n' << option.help;
+            }
+        }
+    }
+
+    if( toerr )
+        errf( "%s\n\n", oss.str().c_str() );
+    else
+        outf( "%s\n\n", oss.str().c_str() );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::printUsage( bool toerr )
+{
+    ostringstream oss;
+    oss <<   "Usage: " << _name << " " << _usage
+        << "\nTry -h for brief help or --help for extended help";
+ 
+    if( toerr )
+        errf( "%s\n", oss.str().c_str() );
+    else
+        outf( "%s\n", oss.str().c_str() );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::printVersion( bool extended )
+{
+    ostringstream oss;
+    oss << left;
+
+    if( extended ) {
+        oss <<         setw(13) << "utility:" << _name
+            << '\n' << setw(13) << "product:" << MP4V2_PROJECT_name
+            << '\n' << setw(13) << "version:" << MP4V2_PROJECT_version
+            << '\n' << setw(13) << "build date:" << MP4V2_PROJECT_build
+            << '\n'
+            << '\n' << setw(18) << "repository URL:" << MP4V2_PROJECT_repo_url;
+    }
+    else {
+        oss << _name << " - " << MP4V2_PROJECT_name_formal;
+    }
+
+    outf( "%s\n", oss.str().c_str() );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::process()
+{
+    bool rv = true;
+
+    try {
+        rv = process_impl();
+    }
+    catch( Exception* x ) {
+        _keepgoing = false;
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+
+    return rv;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::process_impl()
+{
+    formatGroups();
+
+    // populate code lookup set
+    set<int> codes;
+    const Group::List::const_iterator ie = _group.options.end();
+    for( Group::List::const_iterator it = _group.options.begin(); it != ie; ++it ) {
+        const Option& option = **it;
+        if( option.scode != 0 )
+            codes.insert( option.scode );
+        if( option.lcode != LC_NONE )
+            codes.insert( option.lcode );
+    }
+
+    for( ;; ) {
+        const int code = prog::getOption( _argc, _argv, _shortOptions.c_str(), _longOptions, NULL );
+        if( code == -1 )
+            break;
+
+        bool handled = false;
+        if( utility_option( code, handled ))
+            return FAILURE;
+        if( handled )
+            continue;
+
+        if( codes.find( code ) == codes.end() )
+            continue;
+
+        switch( code ) {
+            case 'z':
+                _optimize = true;
+                break;
+
+            case 'y':
+                _dryrun = true;
+                break;
+
+            case 'k':
+                _keepgoing = true;
+                break;
+
+            case 'o':
+                _overwrite = true;
+                break;
+
+            case 'f':
+                _overwrite = true;
+                _force = true;
+                break;
+
+            case 'q':
+                _verbosity = 0;
+                debugUpdate( 0 );
+                break;
+
+            case 'v':
+                _verbosity++;
+                break;
+
+            case 'd':
+                debugUpdate( _debug + 1 );
+                break;
+
+            case 'h':
+                printHelp( false, false );
+                return SUCCESS;
+
+            case LC_DEBUG:
+                debugUpdate( std::strtoul( prog::optarg, NULL, 0 ) );
+                break;
+
+            case LC_VERBOSE:
+            {
+                const uint32_t level = std::strtoul( prog::optarg, NULL, 0 );
+                _verbosity = ( level < 4 ) ? level : 3;
+                break;
+            }
+
+            case LC_HELP:
+                printHelp( true, false );
+                return SUCCESS;
+
+            case LC_VERSION:
+                printVersion( false );
+                return SUCCESS;
+
+            case LC_VERSIONX:
+                printVersion( true );
+                return SUCCESS;
+
+            default:
+                printUsage( true );
+                return FAILURE;
+        }
+    }
+
+    if( !(prog::optind < _argc) ) {
+        printUsage( true );
+        return FAILURE;
+    }
+
+    const bool result = batch( prog::optind );
+    verbose2f( "exit code %d\n", result );
+    return result;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+Utility::openFileForWriting( io::File& file )
+{
+    // simple case is file does not exist
+    if( !io::FileSystem::exists( file.name )) {
+        if( file.open() )
+            return herrf( "unable to open %s for write: %s\n", file.name.c_str(), sys::getLastErrorStr() );
+        return SUCCESS;
+    }
+
+    // fail if overwrite is not enabled
+    if( !_overwrite )
+        return herrf( "file already exists: %s\n", file.name.c_str() );
+
+    // only overwrite if it is a file
+    if( !io::FileSystem::isFile( file.name ))
+        return herrf( "cannot overwrite non-file: %s\n", file.name.c_str() );
+
+    // first attemp to re-open/truncate so as to keep any file perms
+    if( !file.open() )
+        return SUCCESS;
+
+    // fail if force is not enabled
+    if( !_force )
+        return herrf( "unable to overwrite file: %s\n", file.name.c_str() );
+
+    // first attempt to open, truncating file
+    if( !file.open() )
+        return SUCCESS;
+
+    // nuke file
+    if( ::remove( file.name.c_str() ))
+        return herrf( "unable to remove %s: %s\n", file.name.c_str(), sys::getLastErrorStr() );
+
+    // final effort
+    if( !file.open() )
+        return SUCCESS;
+
+    return herrf( "unable to open %s for write: %s\n", file.name.c_str(), sys::getLastErrorStr() );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::verbose( uint32_t level, const char* format, va_list ap )
+{
+    if( level > _verbosity )
+        return;
+    vfprintf( stdout, format, ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::verbose1f( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+    verbose( 1, format, ap );
+    va_end( ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::verbose2f( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+    verbose( 2, format, ap );
+    va_end( ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::verbose3f( const char* format, ... )
+{
+    va_list ap;
+    va_start( ap, format );
+    verbose( 3, format, ap );
+    va_end( ap );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+const bool Utility::SUCCESS = false;
+const bool Utility::FAILURE = true;
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::Group::Group( const string& name_ )
+    : name    ( name_ )
+    , options ( _options )
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::Group::~Group()
+{
+    const List::iterator ie = _optionsDelete.end();
+    for( List::iterator it = _optionsDelete.begin(); it != ie; ++it )
+        delete *it;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::Group::add( const Option& option )
+{
+    _options.push_back( &option );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::Group::add(
+    char          scode,
+    bool          shasarg,
+    const string& lname,
+    bool          lhasarg,
+    uint32_t      lcode,
+    const string& descr,
+    const string& argname,
+    const string& help,
+    bool          hidden )
+{
+    Option* o = new Option( scode, shasarg, lname, lhasarg, lcode, descr, argname, help, hidden );
+    _options.push_back( o );
+    _optionsDelete.push_back( o );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+void
+Utility::Group::add( 
+    const string& lname,
+    bool          lhasarg,
+    uint32_t      lcode,
+    const string& descr,
+    const string& argname,
+    const string& help,
+    bool          hidden )
+{
+    add( 0, false, lname, lhasarg, lcode, descr, argname, help, hidden );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::Option::Option(
+    char          scode_,
+    bool          shasarg_,
+    const string& lname_,
+    bool          lhasarg_,
+    uint32_t      lcode_,
+    const string& descr_,
+    const string& argname_,
+    const string& help_,
+    bool          hidden_ )
+        : scode   ( scode_ )
+        , shasarg ( shasarg_ )
+        , lname   ( lname_ )
+        , lhasarg ( lhasarg_ )
+        , lcode   ( lcode_ )
+        , descr   ( descr_ )
+        , argname ( argname_ )
+        , help    ( help_ )
+        , hidden  ( hidden_ )
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+Utility::JobContext::JobContext( const string& file_ )
+    : file               ( file_ )
+    , fileHandle         ( MP4_INVALID_FILE_HANDLE )
+    , optimizeApplicable ( false )
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
diff --git a/mp4v2/libutil/Utility.h b/mp4v2/libutil/Utility.h
new file mode 100644
index 0000000..0887416
--- /dev/null
+++ b/mp4v2/libutil/Utility.h
@@ -0,0 +1,206 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef MP4V2_UTIL_UTILITY_H
+#define MP4V2_UTIL_UTILITY_H
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+///
+/// Utility general program class.
+///
+/// This class provides a base implementation for a general utility which
+/// helps meet behavioral criteria for command-line executables.
+///
+/// Inherit batch processing ability is also provided and is used optionally
+/// by the concrete implementation.
+///
+/// Criteria and guidelines for utility behavior in MP4v2 are as follows:
+///     @li exit with 0 when the utility succeeds at its main task, 1 for failure.
+///     @li print brief-usage when no arguments are supplied and exit with 1.
+///     @li print brief-usage when too many arguments are supplied and exit with 1.
+///     @li issue brief-usage when invalid argument is supplied and exit with 1.
+///     @li support --help option and exit with 0.
+///     @li support --version option and exit with 0.
+///     @li utilities which <b>create</b> new output files should never
+///         over-write an existing file unless given the project's universal
+///         '-o' or '--overwrite' option.
+///
+///////////////////////////////////////////////////////////////////////////////
+class MP4V2_EXPORT Utility
+{
+protected:
+    enum LongCode {
+        LC_NONE = 0x00010000, // safe (cannot conflict with char values)
+        LC_DEBUG,
+        LC_VERBOSE,
+        LC_HELP,
+        LC_VERSION,
+        LC_VERSIONX,
+        _LC_MAX // will be used to seeed derived-class long-codes enum
+    };
+
+    class MP4V2_EXPORT Option {
+    public:
+        Option( char, bool, const string&, bool, uint32_t, const string&, const string & = "ARG", const string & = "", bool = false );
+
+        const char     scode;
+        const bool     shasarg;
+        const string   lname;
+        const bool     lhasarg;
+        const uint32_t lcode;
+        const string   descr;
+        const string   argname;
+        const string   help;
+        const bool     hidden;
+    };
+
+    class MP4V2_EXPORT Group {
+    public:
+        explicit Group( const string& );
+        ~Group();
+
+        void add( const Option& ); // options added this way will not be deleted
+        void add( char, bool, const string&, bool, uint32_t, const string&, const string & = "ARG", const string & = "", bool = false );
+        void add( const string&, bool, uint32_t, const string&, const string & = "ARG", const string & = "", bool = false );
+
+        const string name;
+
+    public:
+        typedef list<const Option*> List;
+
+    private:
+        List _options;
+        List _optionsDelete;
+
+    public:
+        const List& options;
+    };
+
+    //! structure passed as argument to each job during batch processing
+    class MP4V2_EXPORT JobContext
+    {
+    public:
+        JobContext( const string& file_ );
+
+        const string  file;               //!< file job is working on
+        MP4FileHandle fileHandle;         //!< handle of file, if applicable to job
+        bool          optimizeApplicable; //!< indicate file optimization is applicable
+        list<void*>   tofree;             //!< memory to free at end of job
+    };
+
+public:
+    virtual ~Utility();
+
+    bool process();
+
+protected:
+    Utility( const string&, int, char** );
+
+    void printUsage   ( bool );       //!< print usage
+    void printHelp    ( bool, bool ); //!< print help
+    void printVersion ( bool );       //!< print utility version
+
+    void errf ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3); //!< print to stderr
+    void outf ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3); //!< print to stdout
+
+    bool herrf  ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3); //!< print to stderr indicating error
+    bool hwarnf ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3); //!< print to stderr indicating warning
+
+    void verbose1f ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3);
+    void verbose2f ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3);
+    void verbose3f ( const char*, ... ) MP4V2_WFORMAT_PRINTF(2,3);
+
+    bool batch ( int );           //!< process all remaining arguments (jobs)
+    bool job   ( const string& ); //!< process next argument
+
+    //! open file in consideration of overwrite/force options
+    bool openFileForWriting( io::File& );
+
+    bool dryrunAbort();
+
+    // delegates
+    virtual bool utility_option( int, bool& ) = 0; //!< process command-line option
+    virtual bool utility_job( JobContext& )   = 0; //!< process positional argument
+
+private:
+    void formatGroups();
+    void debugUpdate( uint32_t );
+    void verbose( uint32_t, const char*, va_list );
+    bool process_impl();
+
+private:
+    string _help;
+
+    prog::CommandLine _commandLine;
+    prog::Option* _longOptions;
+    string        _shortOptions;
+
+protected:
+    const string       _name; //!< executable basename
+    int                _argc; //!< arg count
+    char**             _argv; //!< arg vector
+
+    // common options state
+    bool     _optimize;  //!< optimize mp4 file after modification
+    bool     _dryrun;    //!< dry-run, no writing is actually performed
+    bool     _keepgoing; //!< contine batch processing even after error
+    bool     _overwrite; //!< overwrite file if already exists
+    bool     _force;     //!< force overwriting a file even if read-only
+    uint32_t _debug;     //!< mp4 file I/O verbosity
+    uint32_t _verbosity; //!< verbosity level, default=1
+
+    uint32_t          _jobCount;
+    uint32_t          _jobTotal;
+    bool              _debugImplicits;
+
+    Group         _group; // group to which standard options are added
+    string        _usage;
+    string        _description;
+    list<Group*>  _groups;
+
+protected:
+    // standard options for concrete utilities to add to _group in constructor
+    const Option STD_OPTIMIZE;
+    const Option STD_DRYRUN;
+    const Option STD_KEEPGOING;
+    const Option STD_OVERWRITE;
+    const Option STD_FORCE;
+    const Option STD_QUIET;
+    const Option STD_DEBUG;
+    const Option STD_VERBOSE;
+    const Option STD_HELP;
+    const Option STD_VERSION;
+    const Option STD_VERSIONX;
+
+public:
+    static const bool SUCCESS;
+    static const bool FAILURE;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+#endif // MP4V2_UTIL_UTILITY_H
diff --git a/mp4v2/libutil/crc.cpp b/mp4v2/libutil/crc.cpp
new file mode 100644
index 0000000..18d1147
--- /dev/null
+++ b/mp4v2/libutil/crc.cpp
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 1988, 1992, 1993
+ *  The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "libutil/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+uint32_t
+crc32( const unsigned char* data, uint32_t size )
+{
+    static const uint32_t __crctab[256] = {
+        0x0,
+        0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+        0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
+        0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
+        0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
+        0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
+        0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
+        0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
+        0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
+        0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
+        0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+        0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
+        0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
+        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
+        0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
+        0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
+        0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
+        0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
+        0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
+        0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
+        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
+        0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+        0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
+        0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
+        0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
+        0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
+        0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
+        0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
+        0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
+        0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
+        0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+        0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
+        0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
+        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
+        0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
+        0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
+        0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
+        0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
+        0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
+        0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
+        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
+        0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+        0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
+        0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4,
+    };
+
+#define COMPUTE(var,ch) (var) = (var) << 8 ^ __crctab[(var) >> 24 ^ (ch)]
+
+    uint32_t crc = 0;
+    const unsigned char* const max = data + size;
+
+    for (const unsigned char* p = data; p < max; p++)
+        COMPUTE( crc, *p );
+
+    for( ; size != 0; size >>= 8 )
+        COMPUTE( crc, size & 0xff );
+
+    return ~crc;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
diff --git a/mp4v2/libutil/crc.h b/mp4v2/libutil/crc.h
new file mode 100644
index 0000000..4d1299e
--- /dev/null
+++ b/mp4v2/libutil/crc.h
@@ -0,0 +1,37 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef MP4V2_UTIL_CRC_H
+#define MP4V2_UTIL_CRC_H
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+uint32_t crc32( const unsigned char*, uint32_t ); // ISO/IEC 8802-3:1989
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+#endif // MP4V2_UTIL_CRC_H
diff --git a/mp4v2/libutil/impl.h b/mp4v2/libutil/impl.h
new file mode 100644
index 0000000..3824a14
--- /dev/null
+++ b/mp4v2/libutil/impl.h
@@ -0,0 +1,10 @@
+#ifndef MP4V2_UTIL_IMPL_H
+#define MP4V2_UTIL_IMPL_H
+
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util.h"
+
+///////////////////////////////////////////////////////////////////////////////
+
+#endif // MP4V2_UTIL_IMPL_H
diff --git a/mp4v2/libutil/other.cpp b/mp4v2/libutil/other.cpp
new file mode 100644
index 0000000..f46e8d6
--- /dev/null
+++ b/mp4v2/libutil/other.cpp
@@ -0,0 +1,106 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "libutil/impl.h"
+
+namespace mp4v2 { namespace util {
+    using namespace mp4v2::impl;
+
+///////////////////////////////////////////////////////////////////////////////
+
+// search atom recursively for any 64-bit characteristics.
+// nlargsize indicates number of atoms which use largesize extension.
+// nversion1 indicates number of atoms which use version==1 extension.
+// nspecial indicates number of special 64-bit atoms;
+//   eg: stbl may container one of { stco || co64 } for chunkoffsets.
+
+void
+searchFor64bit( MP4Atom& atom, FileSummaryInfo& info )
+{
+    const uint32_t max = atom.GetNumberOfChildAtoms();
+    for( uint32_t i = 0; i < max; i++ ) {
+        MP4Atom& child = *atom.GetChildAtom( i );
+
+        if( child.GetLargesizeMode() )
+            info.nlargesize++;
+
+        MP4Integer8Property* version;
+        if( child.FindProperty( "version", (MP4Property**)&version ) && version->GetValue() == 1 )
+            info.nversion1++;
+
+        if( strequal( child.GetType(), "co64" ))
+            info.nspecial++;
+
+        searchFor64bit( child, info );
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+fileFetchSummaryInfo( MP4FileHandle file, FileSummaryInfo& info )
+{
+    if( file == MP4_INVALID_FILE_HANDLE )
+        return true;
+    MP4File& mp4 = *((MP4File*)file);
+
+    MP4Atom* root = mp4.FindAtom( "" );
+    if( !root )
+        return true;
+
+    MP4FtypAtom* ftyp = (MP4FtypAtom*)root->FindAtom( "ftyp" );
+    if( !ftyp )
+        return true;
+
+    info.major_brand   = ftyp->majorBrand.GetValue();
+    info.minor_version = ftyp->minorVersion.GetValue();
+
+    const uint32_t cbmax = ftyp->compatibleBrands.GetCount();
+    for( uint32_t i = 0; i < cbmax; i++ ) {
+        string s = ftyp->compatibleBrands.GetValue( i );
+
+        // remove spaces so brand set is presentable
+        string stripped;
+        const string::size_type max = s.length();
+        for( string::size_type pos = 0; pos < max; pos++ ) {
+            if( s[pos] != ' ' )
+                stripped += s[pos];
+        }
+
+        if( stripped.empty() )
+            continue;
+
+        info.compatible_brands.insert( stripped );
+    }
+
+    info.nlargesize = 0;
+    info.nversion1  = 0;
+    info.nspecial   = 0;
+    searchFor64bit( *root, info );
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
diff --git a/mp4v2/libutil/other.h b/mp4v2/libutil/other.h
new file mode 100644
index 0000000..83d5411
--- /dev/null
+++ b/mp4v2/libutil/other.h
@@ -0,0 +1,40 @@
+#ifndef MP4V2_UTIL_OTHER_H
+#define MP4V2_UTIL_OTHER_H
+
+///////////////////////////////////////////////////////////////////////////////
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+struct MP4V2_EXPORT FileSummaryInfo {
+    typedef set<string>  BrandSet;
+
+    // standard ftyp box attributes
+    string   major_brand;
+    uint32_t minor_version;
+    BrandSet compatible_brands;
+
+    uint32_t nlargesize;
+    uint32_t nversion1;
+    uint32_t nspecial;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+///
+/// Fetch mp4 file summary information.
+///
+/// This function fetches summary information for <b>file</b> and information
+/// is stored in <b>info</b>.
+///
+/// @return On success <b>true</b>.
+///     On failure <b>false</b>, and contents of <b>info</b> are undefined.
+///
+MP4V2_EXPORT
+bool fileFetchSummaryInfo( MP4FileHandle file, FileSummaryInfo& info );
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+#endif // MP4V2_UTIL_OTHER_H
diff --git a/mp4v2/libutil/util.h b/mp4v2/libutil/util.h
new file mode 100644
index 0000000..669ba3f
--- /dev/null
+++ b/mp4v2/libutil/util.h
@@ -0,0 +1,33 @@
+#ifndef MP4V2_UTIL_UTIL_H
+#define MP4V2_UTIL_UTIL_H
+
+///////////////////////////////////////////////////////////////////////////////
+
+#include "src/src.h"
+
+///////////////////////////////////////////////////////////////////////////////
+
+/// @namespace mp4v2::util (private) Command-line utility support.
+/// <b>WARNING: THIS IS A PRIVATE NAMESPACE. NOT FOR PUBLIC CONSUMPTION.</b>
+///
+/// This namespace is used for command-line utilities. Some symbols from this
+/// namespace are exported from libmp4v2 in order to support new functionality
+/// which may or may not make it into some form of public API, at which time
+/// it will be moved out of this namespace.
+///
+namespace mp4v2 { namespace util {
+    using namespace std;
+    using namespace mp4v2::impl;
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+#include "Timecode.h"
+#include "TrackModifier.h"
+#include "Utility.h"
+#include "crc.h"
+#include "other.h"
+
+///////////////////////////////////////////////////////////////////////////////
+
+#endif // MP4V2_UTIL_UTIL_H
diff --git a/mp4v2/make_configure b/mp4v2/make_configure
deleted file mode 100755
index f4de079..0000000
--- a/mp4v2/make_configure
+++ /dev/null
@@ -1,16 +0,0 @@
-#!/bin/sh -e
-
-CA=configure.ac
-AM=GNUmakefile.am
-
-(rm -f $CA && sed '/^m4_define..SVNINFO/ s/svn info/cat svninfo/' > $CA) < $CA
-
-grep platform_win32.cpp $AM > /dev/null 2>&1 || \
-(rm -f $AM && sed '/libplatform.io.FileSystem_win32.cpp/ a \
-	libplatform/platform_win32.cpp    \\
-' >$AM) < $AM
-
-echo "Running autoreconf..."
-autoreconf -ivf "$@"
-
-echo "Now run ./configure and then make to build MP4v2"
diff --git a/mp4v2/mp4v2.pc.in b/mp4v2/mp4v2.pc.in
new file mode 100644
index 0000000..f258e4f
--- /dev/null
+++ b/mp4v2/mp4v2.pc.in
@@ -0,0 +1,13 @@
+# libmp4v2 pkg-config file
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: mp4v2
+Description: A library for manipulating MP4 container files
+Version: @VERSION@
+
+Libs: -L${libdir} -lmp4v2
+Cflags: -I${includedir}
diff --git a/mp4v2/project/project.m4.in b/mp4v2/project/project.m4.in
index dc96a41..9ffc9ae 100644
--- a/mp4v2/project/project.m4.in
+++ b/mp4v2/project/project.m4.in
@@ -5,20 +5,14 @@ define(<<__PROJECT_name_formal>>,     <<@PROJECT_name_formal@>>)dnl
 define(<<__PROJECT_url_website>>,     <<@PROJECT_url_website@>>)dnl
 define(<<__PROJECT_url_downloads>>,   <<@PROJECT_url_downloads@>>)dnl
 define(<<__PROJECT_url_discussion>>,  <<@PROJECT_url_discussion@>>)dnl
-define(<<__PROJECT_irc>>,             <<@PROJECT_irc@>>)dnl
-define(<<__PROJECT_bugreport>>,       <<@PROJECT_bugreport@>>)dnl
+define(<<__PROJECT_url_bugreport>>,   <<@PROJECT_url_bugreport@>>)dnl
+define(<<__PROJECT_support>>,         <<@PROJECT_support@>>)dnl
 define(<<__PROJECT_version>>,         <<@PROJECT_version@>>)dnl
 define(<<__PROJECT_version_hex>>,     <<@PROJECT_version_hex@>>)dnl
 define(<<__PROJECT_version_major>>,   <<@PROJECT_version_major@>>)dnl
 define(<<__PROJECT_version_minor>>,   <<@PROJECT_version_minor@>>)dnl
 define(<<__PROJECT_version_point>>,   <<@PROJECT_version_point@>>)dnl
 define(<<__PROJECT_repo_url>>,        <<@PROJECT_repo_url@>>)dnl
-define(<<__PROJECT_repo_branch>>,     <<@PROJECT_repo_branch@>>)dnl
-define(<<__PROJECT_repo_root>>,       <<@PROJECT_repo_root@>>)dnl
-define(<<__PROJECT_repo_uuid>>,       <<@PROJECT_repo_uuid@>>)dnl
-define(<<__PROJECT_repo_rev>>,        <<@PROJECT_repo_rev@>>)dnl
-define(<<__PROJECT_repo_date>>,       <<@PROJECT_repo_date@>>)dnl
-define(<<__PROJECT_repo_type>>,       <<@PROJECT_repo_type@>>)dnl
 define(<<__PROJECT_build>>,           <<@PROJECT_build@>>)dnl
 dnl
 define(<<__MAKE_ABS_TOP_BUILDDIR>>,  <<@abs_top_builddir@>>)dnl
diff --git a/mp4v2/project/project.m4sugar b/mp4v2/project/project.m4sugar
index 6e91f04..d71071e 100644
--- a/mp4v2/project/project.m4sugar
+++ b/mp4v2/project/project.m4sugar
@@ -5,11 +5,12 @@ dnl
 define([PRJ_name],           [MP4v2])
 define([PRJ_name_lower],     [mp4v2])
 define([PRJ_name_upper],     [MP4V2])
-define([PRJ_url_website],    [http://code.google.com/p/mp4v2])
-define([PRJ_url_downloads],  [http://code.google.com/p/mp4v2/downloads/list])
-define([PRJ_url_discussion], [http://groups.google.com/group/mp4v2])
-define([PRJ_irc],            [irc://irc.freenode.net/handbrake])
-define([PRJ_bugreport],      [kidjan@gmail.com])
+define([PRJ_url_website],    [https://mp4v2.org])
+define([PRJ_url_downloads],  [https://github.com/enzo1982/releases])
+define([PRJ_url_discussion], [https://github.com/enzo1982/discussions])
+define([PRJ_url_bugreport],  [https://github.com/enzo1982/issues])
+define([PRJ_support],        [support@mp4v2.org])
 define([PRJ_version_major],  [2])
 define([PRJ_version_minor],  [1])
-define([PRJ_version_point],  [0])
+define([PRJ_version_point],  [2])
+define([PRJ_repo_url],       [git@github.com:enzo1982/mp4v2.git])
diff --git a/mp4v2/src/3gp.cpp b/mp4v2/src/3gp.cpp
index f6ec12e..87b0e6e 100644
--- a/mp4v2/src/3gp.cpp
+++ b/mp4v2/src/3gp.cpp
@@ -41,7 +41,7 @@ void MP4File::Make3GPCompliant(const char* fileName,  char* majorBrand, uint32_t
 
     if (majorBrand) {
         if (!supportedBrands || !supportedBrandsCount) {
-            throw new Exception("Invalid parameters",  __FILE__, __LINE__, __FUNCTION__);
+            throw new EXCEPTION("Invalid parameters");
         }
     }
 
diff --git a/mp4v2/src/atom_elst.cpp b/mp4v2/src/atom_elst.cpp
index c1f531a..84e3915 100644
--- a/mp4v2/src/atom_elst.cpp
+++ b/mp4v2/src/atom_elst.cpp
@@ -90,11 +90,14 @@ void MP4ElstAtom::BeginWrite()
     MP4Integer6432Property* p1 =
         (MP4Integer6432Property*)pTable->GetProperty(1);
 
-    if (p0->GetValue() > 0xffffffff || p1->GetValue() > 0xffffffff)
-    {
+    if (p0->GetValue() > 0xffffffff || p1->GetValue() > 0xffffffff) {
         SetVersion(1);
         p0->Use64Bit(true);
         p1->Use64Bit(true);
+    } else {
+        SetVersion(0);
+        p0->Use64Bit(false);
+        p1->Use64Bit(false);
     }
     MP4Atom::BeginWrite();
 }
diff --git a/mp4v2/src/atom_free.cpp b/mp4v2/src/atom_free.cpp
index 350de0b..ab6ec7b 100644
--- a/mp4v2/src/atom_free.cpp
+++ b/mp4v2/src/atom_free.cpp
@@ -38,15 +38,11 @@ void MP4FreeAtom::Read()
 
 void MP4FreeAtom::Write()
 {
-    bool use64 = (GetSize() > (0xFFFFFFFF - 8));
     BeginWrite();
-#if 1
-    for (uint64_t ix = 0; ix < GetSize(); ix++) {
-        m_File.WriteUInt8(0);
+    static uint8_t freebuf[1024];
+    for (uint64_t ix = 0; ix < GetSize(); ix += sizeof(freebuf)) {
+        m_File.WriteBytes(freebuf, min(GetSize() - ix, (uint64_t)sizeof(freebuf)));
     }
-#else
-    m_File.SetPosition(m_File.GetPosition() + GetSize());
-#endif
     FinishWrite();
 }
 
diff --git a/mp4v2/src/atom_ftyp.cpp b/mp4v2/src/atom_ftyp.cpp
index 92b47d6..cc04ca2 100644
--- a/mp4v2/src/atom_ftyp.cpp
+++ b/mp4v2/src/atom_ftyp.cpp
@@ -53,6 +53,9 @@ void MP4FtypAtom::Generate()
 
 void MP4FtypAtom::Read()
 {
+    if ( m_size < 8 )
+        throw new EXCEPTION("Invalid ftyp atom size");
+
     compatibleBrands.SetCount( (m_size - 8) / 4 ); // brands array fills rest of atom
     MP4Atom::Read();
 }
diff --git a/mp4v2/src/atom_hdlr.cpp b/mp4v2/src/atom_hdlr.cpp
index db33e7e..0876bbd 100644
--- a/mp4v2/src/atom_hdlr.cpp
+++ b/mp4v2/src/atom_hdlr.cpp
@@ -82,7 +82,7 @@ void MP4HdlrAtom::Read()
             if( m_File.GetPosition() - GetEnd() == 1 )
                 delete x;
             else
-                throw x;
+                throw;
         }
     }
 
diff --git a/mp4v2/src/atom_mdhd.cpp b/mp4v2/src/atom_mdhd.cpp
index 48792fa..0040ca4 100644
--- a/mp4v2/src/atom_mdhd.cpp
+++ b/mp4v2/src/atom_mdhd.cpp
@@ -91,6 +91,13 @@ void MP4MdhdAtom::BeginWrite()
         ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(true);
         ((MP4Integer6432Property*)m_pProperties[5])->Use64Bit(true);
     }
+    else
+    {
+        SetVersion(0);
+        ((MP4Integer6432Property*)m_pProperties[2])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[5])->Use64Bit(false);
+    }
     MP4Atom::BeginWrite();
 }
 
diff --git a/mp4v2/src/atom_mvhd.cpp b/mp4v2/src/atom_mvhd.cpp
index 6121b8d..7ea760e 100644
--- a/mp4v2/src/atom_mvhd.cpp
+++ b/mp4v2/src/atom_mvhd.cpp
@@ -138,6 +138,13 @@ void MP4MvhdAtom::BeginWrite()
         ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(true);
         ((MP4Integer6432Property*)m_pProperties[5])->Use64Bit(true);
     }
+    else
+    {
+        SetVersion(0);
+        ((MP4Integer6432Property*)m_pProperties[2])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[5])->Use64Bit(false);
+    }
     MP4Atom::BeginWrite();
 }
 
diff --git a/mp4v2/src/atom_root.cpp b/mp4v2/src/atom_root.cpp
index 5ae23c7..0d4b389 100644
--- a/mp4v2/src/atom_root.cpp
+++ b/mp4v2/src/atom_root.cpp
@@ -82,8 +82,16 @@ void MP4RootAtom::FinishWrite()
     }
 
     // finish writing last mdat atom
-    const uint32_t mdatIndex = GetLastMdatIndex();
-    m_pChildAtoms[mdatIndex]->FinishWrite();
+    uint32_t mdatIndex = GetLastMdatIndex();
+    MP4Atom* pLastMdat = m_pChildAtoms[mdatIndex];
+    pLastMdat->FinishWrite();
+    // remove mdat atom if empty
+    if (pLastMdat->GetSize() == 0) {
+        m_File.SetPosition(pLastMdat->GetStart());
+        DeleteChildAtom(pLastMdat);
+        delete pLastMdat;
+        mdatIndex--;
+    }
 
     // write all atoms after last mdat
     const uint32_t size = m_pChildAtoms.Size();
@@ -108,9 +116,9 @@ void MP4RootAtom::BeginOptimalWrite()
         MP4TrackId id = m_File.FindTrackId(i);
         MP4Atom *stco = m_File.FindTrackAtom(id, "mdia.minf.stbl.stco");
         if (stco) {
-            MP4Property *prop;
-            stco->FindProperty("stco.entryCount", &prop);
-            uint32_t cnt = dynamic_cast<MP4IntegerProperty*>(prop)->GetValue();
+            MP4IntegerProperty *prop;
+            stco->FindProperty("stco.entryCount", (MP4Property**)&prop);
+            uint32_t cnt = prop->GetValue();
             room_size += cnt * 4;
         }
     }
@@ -150,7 +158,7 @@ void MP4RootAtom::FinishOptimalWrite()
 uint32_t MP4RootAtom::GetLastMdatIndex()
 {
     for (int32_t i = m_pChildAtoms.Size() - 1; i >= 0; i--) {
-        if (!strcmp("mdat", m_pChildAtoms[i]->GetType())) {
+        if (strequal("mdat", m_pChildAtoms[i]->GetType())) {
             return i;
         }
     }
@@ -163,7 +171,7 @@ void MP4RootAtom::WriteAtomType(const char* type, bool onlyOne)
     uint32_t size = m_pChildAtoms.Size();
 
     for (uint32_t i = 0; i < size; i++) {
-        if (!strcmp(type, m_pChildAtoms[i]->GetType())) {
+        if (strequal(type, m_pChildAtoms[i]->GetType())) {
             m_pChildAtoms[i]->Write();
             if (onlyOne) {
                 break;
diff --git a/mp4v2/src/atom_rtp.cpp b/mp4v2/src/atom_rtp.cpp
index af459ed..b292e2b 100644
--- a/mp4v2/src/atom_rtp.cpp
+++ b/mp4v2/src/atom_rtp.cpp
@@ -69,10 +69,10 @@ void MP4RtpAtom::AddPropertiesHntiType()
 void MP4RtpAtom::Generate()
 {
     ASSERT(m_pParentAtom);
-    if (!strcmp(m_pParentAtom->GetType(), "stsd")) {
+    if (strequal(m_pParentAtom->GetType(), "stsd")) {
         AddPropertiesStsdType();
         GenerateStsdType();
-    } else if (!strcmp(m_pParentAtom->GetType(), "hnti")) {
+    } else if (strequal(m_pParentAtom->GetType(), "hnti")) {
         AddPropertiesHntiType();
         GenerateHntiType();
     } else {
@@ -101,10 +101,10 @@ void MP4RtpAtom::GenerateHntiType()
 void MP4RtpAtom::Read()
 {
     ASSERT(m_pParentAtom);
-    if (!strcmp(m_pParentAtom->GetType(), "stsd")) {
+    if (strequal(m_pParentAtom->GetType(), "stsd")) {
         AddPropertiesStsdType();
         ReadStsdType();
-    } else if (!strcmp(m_pParentAtom->GetType(), "hnti")) {
+    } else if (strequal(m_pParentAtom->GetType(), "hnti")) {
         AddPropertiesHntiType();
         ReadHntiType();
     } else {
@@ -135,7 +135,7 @@ void MP4RtpAtom::ReadHntiType()
 
 void MP4RtpAtom::Write()
 {
-    if (!strcmp(m_pParentAtom->GetType(), "hnti")) {
+    if (strequal(m_pParentAtom->GetType(), "hnti")) {
         WriteHntiType();
     } else {
         MP4Atom::Write();
diff --git a/mp4v2/src/atom_sound.cpp b/mp4v2/src/atom_sound.cpp
index 368f431..a844565 100644
--- a/mp4v2/src/atom_sound.cpp
+++ b/mp4v2/src/atom_sound.cpp
@@ -37,29 +37,32 @@ MP4SoundAtom::MP4SoundAtom(MP4File &file, const char *atomid)
         new MP4Integer16Property(*this, "soundVersion"));
     AddReserved( *this, "reserved2", 6); /* 3 */
 
-    AddProperty( /* 4 */
-        new MP4Integer16Property(*this, "channels"));
-    AddProperty( /* 5 */
-        new MP4Integer16Property(*this, "sampleSize"));
-    AddProperty( /* 6 */
-        new MP4Integer16Property(*this, "compressionId"));
-    AddProperty( /* 7 */
-        new MP4Integer16Property(*this, "packetSize"));
-    AddProperty( /* 8 */
-        new MP4Integer32Property(*this, "timeScale"));
-
     if (ATOMID(atomid) == ATOMID("mp4a")) {
         ExpectChildAtom("esds", Required, OnlyOne);
         ExpectChildAtom("wave", Optional, OnlyOne);
     } else if (ATOMID(atomid) == ATOMID("alac")) {
         ExpectChildAtom("alac", Optional, Optional);
         //AddProperty( new MP4BytesProperty(*this, "alacInfo", 36));
+    } else if (ATOMID(atomid) == ATOMID("fLaC")) {
+        ExpectChildAtom("dfLa", Optional, Optional);
     }
 }
 
 void MP4SoundAtom::AddProperties (uint8_t version)
 {
-    if (version > 0) {
+    if (version < 2) {
+        AddProperty( /* 4 */
+            new MP4Integer16Property(*this, "channels"));
+        AddProperty( /* 5 */
+            new MP4Integer16Property(*this, "sampleSize"));
+        AddProperty( /* 6 */
+            new MP4Integer16Property(*this, "compressionId"));
+        AddProperty( /* 7 */
+            new MP4Integer16Property(*this, "packetSize"));
+        AddProperty( /* 8 */
+            new MP4Integer32Property(*this, "timeScale"));
+    }
+    if (version == 1) {
         AddProperty( /* 9 */
             new MP4Integer32Property(*this, "samplesPerPacket"));
         AddProperty( /* 10 */
@@ -70,15 +73,44 @@ void MP4SoundAtom::AddProperties (uint8_t version)
             new MP4Integer32Property(*this, "bytesPerSample"));
     }
     if (version == 2) {
-        AddReserved(*this, "reserved4", 20);
+        AddProperty( /* 4 */
+            new MP4Integer16Property(*this, "always3"));
+        AddProperty( /* 5 */
+            new MP4Integer16Property(*this, "always16"));
+        AddProperty( /* 6 */
+            new MP4Integer16Property(*this, "alwaysMinus2"));
+        AddProperty( /* 7 */
+            new MP4Integer16Property(*this, "always0"));
+        AddProperty( /* 8 */
+            new MP4Integer32Property(*this, "always65536"));
+        AddProperty( /* 9 */
+            new MP4Integer32Property(*this, "sizeOfStructOnly"));
+        AddProperty( /* 10 */
+            new MP4Float64Property(*this, "timeScale"));
+        AddProperty( /* 11 */
+            new MP4Integer32Property(*this, "channels")); //numAudioChannels
+        AddProperty( /* 12 */
+            new MP4Integer32Property(*this, "always7F000000"));
+        AddProperty( /* 13 */
+            new MP4Integer32Property(*this, "constBitsPerChannel"));
+        AddProperty( /* 14 */
+            new MP4Integer32Property(*this, "formatSpecificFlags"));
+        AddProperty( /* 15 */
+            new MP4Integer32Property(*this, "constBytesPerAudioPacket"));
+        AddProperty( /* 16 */
+            new MP4Integer32Property(*this, "constLPCMFramesPerAudioPacket"));
     }
 }
 void MP4SoundAtom::Generate()
 {
+    const uint8_t Version = ATOMID(GetType()) == ATOMID("lpcm") ? 2 : 0;
+
     MP4Atom::Generate();
 
     ((MP4Integer16Property*)m_pProperties[1])->SetValue(1);
-    ((MP4Integer16Property*)m_pProperties[2])->SetValue(0);
+    ((MP4Integer16Property*)m_pProperties[2])->SetValue(Version);
+
+    AddProperties(Version);
 
     // property reserved2 has non-zero fixed values
     static const uint8_t reserved2[6] = {
@@ -86,13 +118,24 @@ void MP4SoundAtom::Generate()
         0x00, 0x00,
     };
     m_pProperties[3]->SetReadOnly(false);
-    ((MP4BytesProperty*)m_pProperties[3])->
-    SetValue(reserved2, sizeof(reserved2));
+    ((MP4BytesProperty*)m_pProperties[3])->SetValue(reserved2,
+                                                    sizeof(reserved2));
     m_pProperties[3]->SetReadOnly(true);
-    ((MP4Integer16Property*)m_pProperties[4])->SetValue(2);
-    ((MP4Integer16Property*)m_pProperties[5])->SetValue(0x0010);
-    ((MP4Integer16Property*)m_pProperties[6])->SetValue(0);
 
+    if (Version < 2) {
+        ((MP4Integer16Property*)m_pProperties[4])->SetValue(2);
+        ((MP4Integer16Property*)m_pProperties[5])->SetValue(0x0010);
+        ((MP4Integer16Property*)m_pProperties[6])->SetValue(0);
+    } else {
+        ((MP4Integer16Property*)m_pProperties[4])->SetValue(3);
+        ((MP4Integer16Property*)m_pProperties[5])->SetValue(16);
+        ((MP4Integer16Property*)m_pProperties[6])->SetValue(0xFFFE);
+        ((MP4Integer16Property*)m_pProperties[7])->SetValue(0);
+        ((MP4Integer32Property*)m_pProperties[8])->SetValue(65536);
+        ((MP4Integer32Property*)m_pProperties[9])->SetValue(72);
+        ((MP4Integer32Property*)m_pProperties[12])->SetValue(0x7F000000);
+        ((MP4Integer32Property*)m_pProperties[16])->SetValue(1);
+    }
 }
 
 void MP4SoundAtom::Read()
@@ -102,18 +145,12 @@ void MP4SoundAtom::Read()
         // Quicktime has an interesting thing - they'll put an mp4a atom
         // which is blank inside a wave atom, which is inside an mp4a atom
         // we have a mp4a inside an wave inside an mp4a - delete all properties
-        for(int i = 0; i < 9; ++ i)
+        MP4ArrayIndex propCnt = m_pProperties.Size();
+        for(MP4ArrayIndex i = 0; i < propCnt; ++i)
             delete m_pProperties[i];	// make sure we delete the properties themselves, then remove from  m_pProperties
 
-        m_pProperties.Delete(8);
-        m_pProperties.Delete(7);
-        m_pProperties.Delete(6);
-        m_pProperties.Delete(5);
-        m_pProperties.Delete(4);
-        m_pProperties.Delete(3);
-        m_pProperties.Delete(2);
-        m_pProperties.Delete(1);
-        m_pProperties.Delete(0);
+        while (propCnt--)
+            m_pProperties.Delete(propCnt);
 
         if (ATOMID(GetType()) == ATOMID("alac")) {
             AddProperty(new MP4BytesProperty(*this, "decoderConfig", m_size));
diff --git a/mp4v2/src/atom_stsd.cpp b/mp4v2/src/atom_stsd.cpp
index bf995d8..391ee0e 100644
--- a/mp4v2/src/atom_stsd.cpp
+++ b/mp4v2/src/atom_stsd.cpp
@@ -50,13 +50,19 @@ MP4StsdAtom::MP4StsdAtom(MP4File &file)
     ExpectChildAtom("mp4v", Optional, Many);
     ExpectChildAtom("encv", Optional, Many);
     ExpectChildAtom("rtp ", Optional, Many);
+    ExpectChildAtom("ipcm", Optional, Many);
+    ExpectChildAtom("lpcm", Optional, Many);
+    ExpectChildAtom("alaw", Optional, Many);
+    ExpectChildAtom("ulaw", Optional, Many);
     ExpectChildAtom("samr", Optional, Many); // For AMR-NB
     ExpectChildAtom("sawb", Optional, Many); // For AMR-WB
     ExpectChildAtom("s263", Optional, Many); // For H.263
     ExpectChildAtom("avc1", Optional, Many);
     ExpectChildAtom("alac", Optional, Many);
     ExpectChildAtom("text", Optional, Many);
+    ExpectChildAtom("tx3g", Optional, Many);
     ExpectChildAtom("ac-3", Optional, Many);
+    ExpectChildAtom("fLaC", Optional, Many);
 }
 
 void MP4StsdAtom::Read()
diff --git a/mp4v2/src/atom_tkhd.cpp b/mp4v2/src/atom_tkhd.cpp
index 989274b..405fcb1 100644
--- a/mp4v2/src/atom_tkhd.cpp
+++ b/mp4v2/src/atom_tkhd.cpp
@@ -138,6 +138,13 @@ void MP4TkhdAtom::BeginWrite()
         ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(true);
         ((MP4Integer6432Property*)m_pProperties[6])->Use64Bit(true);
     }
+    else
+    {
+        SetVersion(0);
+        ((MP4Integer6432Property*)m_pProperties[2])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[3])->Use64Bit(false);
+        ((MP4Integer6432Property*)m_pProperties[6])->Use64Bit(false);
+    }
     MP4Atom::BeginWrite();
 }
 
diff --git a/mp4v2/src/bmff/bmff.h b/mp4v2/src/bmff/bmff.h
index 8fa3020..87a51bf 100644
--- a/mp4v2/src/bmff/bmff.h
+++ b/mp4v2/src/bmff/bmff.h
@@ -31,12 +31,12 @@
 /// ISO base media file format, ISO/IEC 14496-12:2005(E).
 ///
 namespace mp4v2 { namespace impl { namespace bmff {
-    ;
+
 }}}
 
 ///////////////////////////////////////////////////////////////////////////////
 
-//#include "type.h"
+#include "typebmff.h"
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/src/bmff/typebmff.h b/mp4v2/src/bmff/typebmff.h
index 4b69b7e..120a17f 100644
--- a/mp4v2/src/bmff/typebmff.h
+++ b/mp4v2/src/bmff/typebmff.h
@@ -515,7 +515,7 @@ enum LanguageCode {
     ILC_ZUL,
     ILC_ZUN,
     ILC_ZXX,
-    ILC_ZZA,
+    ILC_ZZA
 };
 
 typedef Enum<LanguageCode,ILC_UNDEFINED> EnumLanguageCode;
diff --git a/mp4v2/src/cmeta.cpp b/mp4v2/src/cmeta.cpp
index b6a7d57..7478706 100644
--- a/mp4v2/src/cmeta.cpp
+++ b/mp4v2/src/cmeta.cpp
@@ -69,7 +69,7 @@ MP4TagsAlloc()
         m->c_alloc( result );
         return result;
     }
-    catch( std::bad_alloc ) {
+    catch( const std::bad_alloc& ) {
         // This could be a failure to allocate itmf::Tags or
         // a failure to allocate inside c_alloc.
         mp4v2::impl::log.errorf("%s: memory allocation error", __FUNCTION__);
diff --git a/mp4v2/src/enum.tcc b/mp4v2/src/enum.tcc
index 1f3395a..57bd1be 100644
--- a/mp4v2/src/enum.tcc
+++ b/mp4v2/src/enum.tcc
@@ -103,7 +103,7 @@ Enum<T,UNDEFINED>::toType( const string& value ) const
     T matched = static_cast<T>( 0 );
 
     const typename MapToType::const_iterator ie = _mapToType.end();
-    for( typename MapToType::const_iterator it = _mapToType.begin(); it != ie; it++ ) {
+    for( typename MapToType::const_iterator it = _mapToType.begin(); it != ie; ++it ) {
         const Entry& entry = *(it->second);
         if( entry.compact.find( value ) == 0 ) {
             matches++;
diff --git a/mp4v2/src/exception.cpp b/mp4v2/src/exception.cpp
index ddc60d7..e0a6cec 100644
--- a/mp4v2/src/exception.cpp
+++ b/mp4v2/src/exception.cpp
@@ -29,6 +29,14 @@ namespace mp4v2 { namespace impl {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+Exception::Exception( const string& what_ )
+    : what(what_)
+    , line(0)
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
 Exception::Exception( const string&     what_,
                       const char        *file_,
                       int               line_,
@@ -55,13 +63,28 @@ Exception::msg() const
 {
     ostringstream retval;
 
-    retval << function << ": " << what << " (" << file << "," << line << ")";
+    if( !function.empty() )
+        retval << function << ": ";
+
+    retval << what;
+    
+    if( !file.empty() )
+        retval << " (" << file << "," << line << ")";
 
     return retval.str();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 
+PlatformException::PlatformException( const string& what_,
+                                      int           errno_ )
+    : Exception(what_)
+    , m_errno(errno_)
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
 PlatformException::PlatformException( const string&     what_,
                                       int               errno_,
                                       const char        *file_,
@@ -85,8 +108,13 @@ PlatformException::msg() const
 {
     ostringstream retval;
 
-    retval << function << ": " << what << ": errno: " << m_errno << " (" <<
-        file << "," << line << ")";
+    if( !function.empty() )
+        retval << function << ": ";
+
+    retval << what << ": errno: " << m_errno;
+    
+    if( !file.empty() )
+        retval << " (" << file << "," << line << ")";
 
     return retval.str();
 }
diff --git a/mp4v2/src/exception.h b/mp4v2/src/exception.h
index f0e2e4e..bad7372 100644
--- a/mp4v2/src/exception.h
+++ b/mp4v2/src/exception.h
@@ -29,9 +29,18 @@ namespace mp4v2 { namespace impl {
 
 ///////////////////////////////////////////////////////////////////////////////
 
-class MP4V2_EXPORT Exception
+#ifdef NDEBUG
+#   define EXCEPTION(message) mp4v2::impl::Exception(message)
+#   define PLATFORM_EXCEPTION(message, errno) mp4v2::impl::PlatformException(message, errno)
+#else
+#   define EXCEPTION(message) mp4v2::impl::Exception(message, __FILE__, __LINE__, __FUNCTION__)
+#   define PLATFORM_EXCEPTION(message, errno) mp4v2::impl::PlatformException(message, errno, __FILE__, __LINE__, __FUNCTION__)
+#endif
+
+class Exception
 {
 public:
+    explicit Exception( const string&   what_ );
     explicit Exception( const string&   what_,
                         const char      *file_,
                         int             line_,
@@ -47,9 +56,11 @@ public:
     const string        function;
 };
 
-class MP4V2_EXPORT PlatformException : public Exception
+class PlatformException : public Exception
 {
 public:
+    explicit PlatformException( const string&   what_,
+                                int             errno_ );
     explicit PlatformException( const string&   what_,
                                 int             errno_,
                                 const char      *file_,
diff --git a/mp4v2/src/isma.cpp b/mp4v2/src/isma.cpp
index 007455d..7d8467a 100644
--- a/mp4v2/src/isma.cpp
+++ b/mp4v2/src/isma.cpp
@@ -40,7 +40,9 @@ static const uint8_t BifsV2Config[3] = {
 
 void MP4File::MakeIsmaCompliant(bool addIsmaComplianceSdp)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    if( !IsWriteMode() ) {
+        throw new EXCEPTION("operation not permitted in read mode");
+    }
 
     if (m_useIsma) {
         // already done
diff --git a/mp4v2/src/itmf/Tags.cpp b/mp4v2/src/itmf/Tags.cpp
index e8ca481..5f0c458 100644
--- a/mp4v2/src/itmf/Tags.cpp
+++ b/mp4v2/src/itmf/Tags.cpp
@@ -419,7 +419,7 @@ Tags::fetchGenre( const CodeItemMap& cim, uint16_t& cpp, const uint16_t*& c )
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
     if( NULL == data.value )
         return;
 
@@ -442,7 +442,7 @@ Tags::fetchDisk( const CodeItemMap& cim, MP4TagDisk& cpp, const MP4TagDisk*& c )
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
@@ -469,7 +469,7 @@ Tags::fetchTrack( const CodeItemMap& cim, MP4TagTrack& cpp, const MP4TagTrack*&
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
@@ -495,7 +495,7 @@ Tags::fetchInteger( const CodeItemMap& cim, const string& code, uint8_t& cpp, co
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
     if( NULL == data.value )
         return;
 
@@ -515,7 +515,7 @@ Tags::fetchInteger( const CodeItemMap& cim, const string& code, uint16_t& cpp, c
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
@@ -538,7 +538,7 @@ Tags::fetchInteger( const CodeItemMap& cim, const string& code, uint32_t& cpp, c
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
@@ -563,7 +563,7 @@ Tags::fetchInteger( const CodeItemMap& cim, const string& code, uint64_t& cpp, c
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
@@ -592,7 +592,7 @@ Tags::fetchString( const CodeItemMap& cim, const string& code, string& cpp, cons
     if( f == cim.end() || 0 == f->second->dataList.size )
         return;
 
-    MP4ItmfData& data = f->second->dataList.elements[0];
+    const MP4ItmfData& data = f->second->dataList.elements[0];
 
     if( NULL == data.value )
         return;
diff --git a/mp4v2/src/itmf/itmf.h b/mp4v2/src/itmf/itmf.h
index cad38ed..c801862 100644
--- a/mp4v2/src/itmf/itmf.h
+++ b/mp4v2/src/itmf/itmf.h
@@ -31,7 +31,7 @@
 /// iTunes Metadata Format Specification, revision 2008-04-16.
 ///
 namespace mp4v2 { namespace impl { namespace itmf {
-    ;
+
 }}}
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/mp4v2/src/itmf/type.cpp b/mp4v2/src/itmf/type.cpp
index 75cc3f6..edf1df5 100644
--- a/mp4v2/src/itmf/type.cpp
+++ b/mp4v2/src/itmf/type.cpp
@@ -65,14 +65,14 @@ const itmf::EnumGenreType::Entry itmf::EnumGenreType::data[] = {
     { mp4v2::impl::itmf::GENRE_DISCO,             "disco",             "Disco" },
     { mp4v2::impl::itmf::GENRE_FUNK,              "funk",              "Funk" },
     { mp4v2::impl::itmf::GENRE_GRUNGE,            "grunge",            "Grunge" },
-    { mp4v2::impl::itmf::GENRE_HIP_HOP,           "hiphop",            "Hop-Hop" },
+    { mp4v2::impl::itmf::GENRE_HIP_HOP,           "hiphop",            "Hip-Hop" },
     { mp4v2::impl::itmf::GENRE_JAZZ,              "jazz",              "Jazz" },
     { mp4v2::impl::itmf::GENRE_METAL,             "metal",             "Metal" },
     { mp4v2::impl::itmf::GENRE_NEW_AGE,           "newage",            "New Age" },
     { mp4v2::impl::itmf::GENRE_OLDIES,            "oldies",            "Oldies" },
     { mp4v2::impl::itmf::GENRE_OTHER,             "other",             "Other" },
     { mp4v2::impl::itmf::GENRE_POP,               "pop",               "Pop" },
-    { mp4v2::impl::itmf::GENRE_R_AND_B,           "rand_b",            "R&B" },
+    { mp4v2::impl::itmf::GENRE_R_AND_B,           "rnb",               "R&B" },
     { mp4v2::impl::itmf::GENRE_RAP,               "rap",               "Rap" },
     { mp4v2::impl::itmf::GENRE_REGGAE,            "reggae",            "Reggae" },
     { mp4v2::impl::itmf::GENRE_ROCK,              "rock",              "Rock" },
@@ -98,7 +98,7 @@ const itmf::EnumGenreType::Entry itmf::EnumGenreType::data[] = {
     { mp4v2::impl::itmf::GENRE_SOUND_CLIP,        "soundclip",         "Sound Clip" },
     { mp4v2::impl::itmf::GENRE_GOSPEL,            "gospel",            "Gospel" },
     { mp4v2::impl::itmf::GENRE_NOISE,             "noise",             "Noise" },
-    { mp4v2::impl::itmf::GENRE_ALTERNROCK,        "alternrock",        "AlternRock" },
+    { mp4v2::impl::itmf::GENRE_ALTERNROCK,        "alternativerock",   "Alternative Rock" },
     { mp4v2::impl::itmf::GENRE_BASS,              "bass",              "Bass" },
     { mp4v2::impl::itmf::GENRE_SOUL,              "soul",              "Soul" },
     { mp4v2::impl::itmf::GENRE_PUNK,              "punk",              "Punk" },
@@ -136,7 +136,7 @@ const itmf::EnumGenreType::Entry itmf::EnumGenreType::data[] = {
     { mp4v2::impl::itmf::GENRE_POLKA,             "polka",             "Polka" },
     { mp4v2::impl::itmf::GENRE_RETRO,             "retro",             "Retro" },
     { mp4v2::impl::itmf::GENRE_MUSICAL,           "musical",           "Musical" },
-    { mp4v2::impl::itmf::GENRE_ROCK_AND_ROLL,     "rockand_roll",      "Rock & Roll" },
+    { mp4v2::impl::itmf::GENRE_ROCK_AND_ROLL,     "rocknroll",         "Rock & Roll" },
 
     { mp4v2::impl::itmf::GENRE_HARD_ROCK,         "hardrock",          "Hard Rock" },
     { mp4v2::impl::itmf::GENRE_FOLK,              "folk",              "Folk" },
@@ -151,17 +151,17 @@ const itmf::EnumGenreType::Entry itmf::EnumGenreType::data[] = {
     { mp4v2::impl::itmf::GENRE_BLUEGRASS,         "bluegrass",         "Bluegrass" },
     { mp4v2::impl::itmf::GENRE_AVANTGARDE,        "avantgarde",        "Avantgarde" },
     { mp4v2::impl::itmf::GENRE_GOTHIC_ROCK,       "gothicrock",        "Gothic Rock" },
-    { mp4v2::impl::itmf::GENRE_PROGRESSIVE_ROCK,  "progressiverock",   "Progresive Rock" },
+    { mp4v2::impl::itmf::GENRE_PROGRESSIVE_ROCK,  "progressiverock",   "Progressive Rock" },
     { mp4v2::impl::itmf::GENRE_PSYCHEDELIC_ROCK,  "psychedelicrock",   "Psychedelic Rock" },
-    { mp4v2::impl::itmf::GENRE_SYMPHONIC_ROCK,    "symphonicrock",     "SYMPHONIC_ROCK" },
+    { mp4v2::impl::itmf::GENRE_SYMPHONIC_ROCK,    "symphonicrock",     "Symphonic Rock" },
     { mp4v2::impl::itmf::GENRE_SLOW_ROCK,         "slowrock",          "Slow Rock" },
     { mp4v2::impl::itmf::GENRE_BIG_BAND,          "bigband",           "Big Band" },
     { mp4v2::impl::itmf::GENRE_CHORUS,            "chorus",            "Chorus" },
     { mp4v2::impl::itmf::GENRE_EASY_LISTENING,    "easylistening",     "Easy Listening" },
     { mp4v2::impl::itmf::GENRE_ACOUSTIC,          "acoustic",          "Acoustic" },
-    { mp4v2::impl::itmf::GENRE_HUMOUR,            "humour",            "Humor" },
+    { mp4v2::impl::itmf::GENRE_HUMOUR,            "humour",            "Humour" },
     { mp4v2::impl::itmf::GENRE_SPEECH,            "speech",            "Speech" },
-    { mp4v2::impl::itmf::GENRE_CHANSON,           "chanson",           "Chason" },
+    { mp4v2::impl::itmf::GENRE_CHANSON,           "chanson",           "Chanson" },
     { mp4v2::impl::itmf::GENRE_OPERA,             "opera",             "Opera" },
     { mp4v2::impl::itmf::GENRE_CHAMBER_MUSIC,     "chambermusic",      "Chamber Music" },
     { mp4v2::impl::itmf::GENRE_SONATA,            "sonata",            "Sonata" },
@@ -250,9 +250,10 @@ const itmf::EnumCountryCode::Entry itmf::EnumCountryCode::data[] = {
 
 template <>
 const itmf::EnumContentRating::Entry itmf::EnumContentRating::data[] = {
-    { mp4v2::impl::itmf::CR_NONE,      "none",       "None" },
-    { mp4v2::impl::itmf::CR_CLEAN,     "clean",      "Clean" },
-    { mp4v2::impl::itmf::CR_EXPLICIT,  "explicit",   "Explicit" },
+    { mp4v2::impl::itmf::CR_NONE,         "none",       "None" },
+    { mp4v2::impl::itmf::CR_EXPLICIT,     "explicit",   "Explicit" },
+    { mp4v2::impl::itmf::CR_CLEAN,        "clean",      "Clean" },
+    { mp4v2::impl::itmf::CR_EXPLICIT_OLD, "explicit",   "Explicit" },
 
     { mp4v2::impl::itmf::CR_UNDEFINED } // must be last
 };
diff --git a/mp4v2/src/itmf/type.h b/mp4v2/src/itmf/type.h
index 484c241..5f59490 100644
--- a/mp4v2/src/itmf/type.h
+++ b/mp4v2/src/itmf/type.h
@@ -46,7 +46,7 @@ enum BasicType {
     BT_URL       = 15,  ///< absolute, in UTF-8 characters
     BT_DURATION  = 16,  ///< in milliseconds, 32-bit integer
     BT_DATETIME  = 17,  ///< in UTC, counting seconds since midnight, January 1, 1904; 32 or 64-bits
-    BT_GENRES    = 18,  ///< a list of enumerated values, see #Genre
+    BT_GENRES    = 18,  ///< a list of enumerated values, see #GenreType
     BT_INTEGER   = 21,  ///< a signed big-endian integer with length one of { 1,2,3,4,8 } bytes
     BT_RIAA_PA   = 24,  ///< RIAA parental advisory; { -1=no, 1=yes, 0=unspecified }, 8-bit ingteger
     BT_UPC       = 25,  ///< Universal Product Code, in text UTF-8 format (valid as an ID)
@@ -274,11 +274,12 @@ MP4V2_EXPORT extern const EnumCountryCode enumCountryCode;
 /// enumerated 8-bit Content Rating used by iTunes.
 /// Note values are not formally defined in any specification.
 enum ContentRating {   
-    CR_NONE      = 0,
-    CR_CLEAN     = 2,
-    CR_EXPLICIT  = 4,
+    CR_NONE         = 0,
+    CR_EXPLICIT     = 1,
+    CR_CLEAN        = 2,
+    CR_EXPLICIT_OLD = 4,
 
-    CR_UNDEFINED = 255
+    CR_UNDEFINED    = 255
 };
 
 typedef Enum<ContentRating,CR_UNDEFINED> EnumContentRating;
diff --git a/mp4v2/src/mp4.cpp b/mp4v2/src/mp4.cpp
index 1016f79..2b37da6 100644
--- a/mp4v2/src/mp4.cpp
+++ b/mp4v2/src/mp4.cpp
@@ -46,7 +46,7 @@ static MP4File  *ConstructMP4File ( void )
     try {
         pFile = new MP4File();
     }
-    catch( std::bad_alloc ) {
+    catch( const std::bad_alloc& ) {
         mp4v2::impl::log.errorf("%s: unable to allocate MP4File", __FUNCTION__);
     }
     catch( Exception* x ) {
@@ -88,6 +88,11 @@ const char* MP4GetFilename( MP4FileHandle hFile )
 ///////////////////////////////////////////////////////////////////////////////
 
 MP4FileHandle MP4Read( const char* fileName )
+{
+    return MP4ReadProvider( fileName, NULL );
+}
+
+MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* fileProvider )
 {
     if (!fileName)
         return MP4_INVALID_FILE_HANDLE;
@@ -96,10 +101,8 @@ MP4FileHandle MP4Read( const char* fileName )
     if (!pFile)
         return MP4_INVALID_FILE_HANDLE;
 
-    try
-    {
-        ASSERT(pFile);
-        pFile->Read( fileName, NULL );
+    try {
+        pFile->Read( fileName, fileProvider, NULL, NULL );
         return (MP4FileHandle)pFile;
     }
     catch( Exception* x ) {
@@ -111,14 +114,13 @@ MP4FileHandle MP4Read( const char* fileName )
                                 fileName );
     }
 
-    if (pFile)
-        delete pFile;
+    delete pFile;
     return MP4_INVALID_FILE_HANDLE;
 }
 
-MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* fileProvider )
+MP4FileHandle MP4ReadCallbacks( const MP4IOCallbacks* callbacks, void* handle )
 {
-    if (!fileName)
+    if (!callbacks)
         return MP4_INVALID_FILE_HANDLE;
 
     MP4File *pFile = ConstructMP4File();
@@ -126,7 +128,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
         return MP4_INVALID_FILE_HANDLE;
 
     try {
-        pFile->Read( fileName, fileProvider );
+        pFile->Read( NULL, NULL, callbacks, handle );
         return (MP4FileHandle)pFile;
     }
     catch( Exception* x ) {
@@ -134,117 +136,165 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
         delete x;
     }
     catch( ... ) {
-        mp4v2::impl::log.errorf("%s: \"%s\": failed", __FUNCTION__,
-                                fileName );
+        mp4v2::impl::log.errorf("%s: failed", __FUNCTION__ );
     }
 
-    if (pFile)
-        delete pFile;
+    delete pFile;
     return MP4_INVALID_FILE_HANDLE;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 
-    MP4FileHandle MP4Create (const char* fileName,
-                             uint32_t flags)
-    {
-        return MP4CreateProviderEx(fileName, flags);
-    }
+MP4FileHandle MP4Create (const char* fileName,
+                         uint32_t flags)
+{
+    return MP4CreateEx(fileName, flags);
+}
 
-    MP4FileHandle MP4CreateEx (const char* fileName,
-                               uint32_t  flags,
-                               int add_ftyp,
-                               int add_iods,
-                               char* majorBrand,
-                               uint32_t minorVersion,
-                               char** supportedBrands,
-                               uint32_t supportedBrandsCount)
-    {
-        return MP4CreateProviderEx(fileName, flags, NULL,
-                                   add_ftyp, add_iods,
-                                   majorBrand, minorVersion,
-                                   supportedBrands, supportedBrandsCount);
-    }
+MP4FileHandle MP4CreateEx (const char* fileName,
+                           uint32_t flags,
+                           int add_ftyp,
+                           int add_iods,
+                           char* majorBrand,
+                           uint32_t minorVersion,
+                           char** supportedBrands,
+                           uint32_t supportedBrandsCount)
+{
+    if (!fileName)
+        return MP4_INVALID_FILE_HANDLE;
 
-    MP4FileHandle MP4CreateProvider (const char* fileName,
-                                     uint32_t flags,
-                                     const MP4FileProvider* fileProvider)
-    {
-        return MP4CreateProviderEx(fileName, flags, fileProvider);
+    MP4File* pFile = ConstructMP4File();
+    if (!pFile)
+        return MP4_INVALID_FILE_HANDLE;
+
+    try {
+        // LATER useExtensibleFormat, moov first, then mvex's
+        pFile->Create(fileName, NULL,
+                      NULL, flags,
+                      add_ftyp, add_iods,
+                      majorBrand, minorVersion,
+                      supportedBrands, supportedBrandsCount);
+        return (MP4FileHandle)pFile;
+    }
+    catch( Exception* x ) {
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+    catch( ... ) {
+        mp4v2::impl::log.errorf("%s: \"%s\": failed", __FUNCTION__,
+                                fileName );
     }
 
-    MP4FileHandle MP4CreateProviderEx (const char* fileName,
-                                       uint32_t flags,
-                                       const MP4FileProvider* fileProvider,
-                                       int add_ftyp,
-                                       int add_iods,
-                                       char* majorBrand,
-                                       uint32_t minorVersion,
-                                       char** supportedBrands,
-                                       uint32_t supportedBrandsCount)
-    {
-        if (!fileName)
-            return MP4_INVALID_FILE_HANDLE;
+    delete pFile;
+    return MP4_INVALID_FILE_HANDLE;
+}
 
-        MP4File* pFile = ConstructMP4File();
-        if (!pFile)
-            return MP4_INVALID_FILE_HANDLE;
+MP4FileHandle MP4CreateCallbacks (const MP4IOCallbacks* callbacks,
+                                  void* handle,
+                                  uint32_t flags)
+{
+    return MP4CreateCallbacksEx(callbacks, handle, flags);
+}
 
-        try {
-            ASSERT(pFile);
-            // LATER useExtensibleFormat, moov first, then mvex's
-            pFile->Create(fileName, flags, fileProvider,
-                          add_ftyp, add_iods,
-                          majorBrand, minorVersion,
-                          supportedBrands, supportedBrandsCount);
-            return (MP4FileHandle)pFile;
-        }
-        catch( Exception* x ) {
-            mp4v2::impl::log.errorf(*x);
-            delete x;
-        }
-        catch( ... ) {
-            mp4v2::impl::log.errorf("%s: \"%s\": failed", __FUNCTION__,
-                                    fileName );
-        }
+MP4FileHandle MP4CreateCallbacksEx (const MP4IOCallbacks* callbacks,
+                                    void* handle,
+                                    uint32_t flags,
+                                    int add_ftyp,
+                                    int add_iods,
+                                    char* majorBrand,
+                                    uint32_t minorVersion,
+                                    char** supportedBrands,
+                                    uint32_t supportedBrandsCount)
+{
+    if (!callbacks)
+        return MP4_INVALID_FILE_HANDLE;
 
-        if (pFile)
-            delete pFile;
+    MP4File* pFile = ConstructMP4File();
+    if (!pFile)
         return MP4_INVALID_FILE_HANDLE;
+
+    try {
+        // LATER useExtensibleFormat, moov first, then mvex's
+        pFile->Create(NULL, callbacks,
+                      handle, flags,
+                      add_ftyp, add_iods,
+                      majorBrand, minorVersion,
+                      supportedBrands, supportedBrandsCount);
+        return (MP4FileHandle)pFile;
+    }
+    catch( Exception* x ) {
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+    catch( ... ) {
+        mp4v2::impl::log.errorf("%s: failed", __FUNCTION__ );
     }
 
+    delete pFile;
+    return MP4_INVALID_FILE_HANDLE;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 
-    MP4FileHandle MP4Modify(const char* fileName,
-                            uint32_t flags)
-    {
-        if (!fileName)
-            return MP4_INVALID_FILE_HANDLE;
+MP4FileHandle MP4Modify(const char* fileName,
+                        uint32_t flags)
+{
+    if (!fileName)
+        return MP4_INVALID_FILE_HANDLE;
 
-        MP4File* pFile = ConstructMP4File();
-        if (!pFile)
-            return MP4_INVALID_FILE_HANDLE;
+    MP4File* pFile = ConstructMP4File();
+    if (!pFile)
+        return MP4_INVALID_FILE_HANDLE;
 
-        try {
-            ASSERT(pFile);
-            // LATER useExtensibleFormat, moov first, then mvex's
-            if (pFile->Modify(fileName))
-                return (MP4FileHandle)pFile;
-        }
-        catch( Exception* x ) {
-            mp4v2::impl::log.errorf(*x);
-            delete x;
-        }
-        catch( ... ) {
-            mp4v2::impl::log.errorf("%s: \"%s\": failed", __FUNCTION__,
-                                    fileName );
-        }
+    try {
+        ASSERT(pFile);
+        // LATER useExtensibleFormat, moov first, then mvex's
+        if (pFile->Modify(fileName, NULL, NULL))
+            return (MP4FileHandle)pFile;
+    }
+    catch( Exception* x ) {
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+    catch( ... ) {
+        mp4v2::impl::log.errorf("%s: \"%s\": failed", __FUNCTION__,
+                                fileName );
+    }
 
-        if (pFile)
-            delete pFile;
+    delete pFile;
+    return MP4_INVALID_FILE_HANDLE;
+}
+
+MP4FileHandle MP4ModifyCallbacks(const MP4IOCallbacks* callbacks,
+                                 void* handle,
+                                 uint32_t flags)
+{
+    if (!callbacks)
+        return MP4_INVALID_FILE_HANDLE;
+
+    MP4File* pFile = ConstructMP4File();
+    if (!pFile)
         return MP4_INVALID_FILE_HANDLE;
+
+    try {
+        ASSERT(pFile);
+        // LATER useExtensibleFormat, moov first, then mvex's
+        if (pFile->Modify(NULL, callbacks,
+                          handle))
+            return (MP4FileHandle)pFile;
+    }
+    catch( Exception* x ) {
+        mp4v2::impl::log.errorf(*x);
+        delete x;
+    }
+    catch( ... ) {
+        mp4v2::impl::log.errorf("%s: failed", __FUNCTION__ );
     }
 
+    delete pFile;
+    return MP4_INVALID_FILE_HANDLE;
+}
+
     bool MP4Optimize(const char* fileName,
                      const char* newFileName)
     {
@@ -272,8 +322,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
                                     fileName, newFileName );
         }
 
-        if (pFile)
-            delete pFile;
+        delete pFile;
         return false;
     }
 
@@ -896,7 +945,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
         }
 
         catch (...) {
-            return MP4_INVALID_TRACK_ID;
+            return NULL;
         }
     }
 
@@ -2651,13 +2700,39 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
         MP4FileHandle hFile, MP4TrackId trackId)
     {
         if (MP4_IS_VALID_FILE_HANDLE(hFile)) {
+            // H.264 MP4s will typically have width & height stored in
+            // the mdia.minf.stbl.stsd.avc1 atom. For MOVs, it varies.
+            // For H.264 MOVs from Apple devices, it is the same as H.264
+            // MP4. For PNG MOVs, mdia.minf.stbl.stsd.png contain the
+            // width and height. For ProRes MOVs, there are various atoms
+            // that I don't think are publicly documented,
+            // mdia.minf.stbl.stsd.apcn for example. So when we don't
+            // find the width/height where we expect, we'll just go with
+            // what's in the tkhd atom.
             try {
                 return ((MP4File*)hFile)->GetTrackIntegerProperty(trackId,
                         "mdia.minf.stbl.stsd.*.width");
             }
             catch( Exception* x ) {
                 mp4v2::impl::log.errorf(*x);
-                delete x;
+                bool missingProperty = ( x->what.substr( 0, 16 ) == "no such property" );
+                delete x;
+                if ( missingProperty )
+                {
+                   try
+                   {
+                      return ( (MP4File*)hFile )->GetTrackFloatProperty( trackId, "tkhd.width" );
+                   }
+                   catch ( Exception *xx )
+                   {
+                      mp4v2::impl::log.errorf( *xx );
+                      delete xx;
+                   }
+                   catch ( ... )
+                   {
+                      mp4v2::impl::log.errorf( "%s: failed", __FUNCTION__ );
+                   }
+                }
             }
             catch( ... ) {
                 mp4v2::impl::log.errorf( "%s: failed", __FUNCTION__ );
@@ -2676,7 +2751,26 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
             }
             catch( Exception* x ) {
                 mp4v2::impl::log.errorf(*x);
+                bool missingProperty = ( x->what.substr( 0, 16 ) == "no such property" );
                 delete x;
+
+                // See notes above in MP4GetTrackVideoWidth()
+                if ( missingProperty )
+                {
+                   try
+                   {
+                      return ( (MP4File*)hFile )->GetTrackFloatProperty( trackId, "tkhd.height" );
+                   }
+                   catch ( Exception *xx )
+                   {
+                      mp4v2::impl::log.errorf( *xx );
+                      delete xx;
+                   }
+                   catch ( ... )
+                   {
+                      mp4v2::impl::log.errorf( "%s: failed", __FUNCTION__ );
+                   }
+                }
             }
             catch( ... ) {
                 mp4v2::impl::log.errorf( "%s: failed", __FUNCTION__ );
@@ -3950,7 +4044,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
 
         try {
             ASSERT(pFile);
-            pFile->Modify(fileName);
+            pFile->Modify(fileName, NULL, NULL);
             pFile->Make3GPCompliant(fileName, majorBrand, minorVersion, supportedBrands, supportedBrandsCount, deleteIodsAtom);
             pFile->Close();
             delete pFile;
@@ -3964,8 +4058,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
             mp4v2::impl::log.errorf("%s: failed", __FUNCTION__ );
         }
 
-        if (pFile)
-            delete pFile;
+        delete pFile;
         return false;
     }
 
@@ -3984,7 +4077,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
 
         try {
             ASSERT(pFile);
-            pFile->Modify(fileName);
+            pFile->Modify(fileName, NULL, NULL);
             pFile->MakeIsmaCompliant(addIsmaComplianceSdp);
             pFile->Close();
             delete pFile;
@@ -3999,8 +4092,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
                                     fileName );
         }
 
-        if (pFile)
-            delete pFile;
+        delete pFile;
         return false;
     }
 
@@ -4059,8 +4151,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
             mp4v2::impl::log.errorf("%s: failed", __FUNCTION__ );
         }
 
-        if (pFile)
-            delete pFile;
+        delete pFile;
         return NULL;
     }
 
@@ -4421,7 +4512,7 @@ MP4FileHandle MP4ReadProvider( const char* fileName, const MP4FileProvider* file
         {
             ipod_uuid = new IPodUUIDAtom(*(MP4File*)hFile);
         }
-        catch( std::bad_alloc ) {
+        catch( const std::bad_alloc& ) {
             mp4v2::impl::log.errorf("%s: unable to allocate IPodUUIDAtom", __FUNCTION__);
         }
         catch( Exception* x ) {
diff --git a/mp4v2/src/mp4array.h b/mp4v2/src/mp4array.h
index c49d59b..274beb6 100644
--- a/mp4v2/src/mp4array.h
+++ b/mp4v2/src/mp4array.h
@@ -29,13 +29,18 @@ namespace impl {
 
 typedef uint32_t MP4ArrayIndex;
 
-class MP4Array {
+template<class type> class MP4Array {
 public:
     MP4Array() {
+        m_elements = NULL;
         m_numElements = 0;
         m_maxNumElements = 0;
     }
 
+    ~MP4Array() {
+        MP4Free(m_elements);
+    }
+
     inline bool ValidIndex(MP4ArrayIndex index) {
         return (index < m_numElements);
     }
@@ -48,94 +53,73 @@ public:
         return m_maxNumElements;
     }
 
+    inline void Add(type newElement) {
+        Insert(newElement, m_numElements);
+    }
+
+    void Insert(type newElement, MP4ArrayIndex newIndex) {
+        if (newIndex > m_numElements) {
+            throw new PLATFORM_EXCEPTION("illegal array index", ERANGE);
+        }
+        if (m_numElements == m_maxNumElements) {
+            MP4ArrayIndex newSize = max(m_maxNumElements, (MP4ArrayIndex)1) * 2;
+            m_elements = (type*)MP4Realloc(m_elements,
+                newSize * sizeof(type));
+            m_maxNumElements = newSize;
+        }
+        memmove(&m_elements[newIndex + 1], &m_elements[newIndex],
+            (m_numElements - newIndex) * sizeof(type));
+        m_elements[newIndex] = newElement;
+        m_numElements++;
+    }
+
+    void Delete(MP4ArrayIndex index) {
+        if (!ValidIndex(index)) {
+            ostringstream msg;
+            msg << "illegal array index: " << index << " of " << m_numElements;
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE);
+        }
+        m_numElements--;
+        if (index < m_numElements) {
+            memmove(&m_elements[index], &m_elements[index + 1],
+                (m_numElements - index) * sizeof(type));
+        }
+    }
+
+    void Resize(MP4ArrayIndex newSize) {
+        if ( (uint64_t) newSize * sizeof(type) > 0xFFFFFFFF )
+            throw new PLATFORM_EXCEPTION("requested array size exceeds 4GB", ERANGE); /* prevent overflow */
+        m_elements = (type*)MP4Realloc(m_elements,
+        newSize * sizeof(type));
+        m_numElements = newSize;
+        m_maxNumElements = newSize;
+    }
+
+    type& operator[](MP4ArrayIndex index) {
+        if (ValidIndex(index)) {
+            return m_elements[index];
+        }
+        else {
+            ostringstream msg;
+            msg << "illegal array index: " << index << " of " << m_numElements;
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE);
+        }
+    }
+
 protected:
+    type*           m_elements;
     MP4ArrayIndex   m_numElements;
     MP4ArrayIndex   m_maxNumElements;
 };
 
-// macro to generate subclasses
-// we use this as an alternative to templates
-// due to the excessive compile time price of extensive template usage
-
-#define MP4ARRAY_DECL(name, type) \
-    class name##Array : public MP4Array { \
-    public: \
-        name##Array() { \
-            m_elements = NULL; \
-        } \
-        \
-        ~name##Array() { \
-            MP4Free(m_elements); \
-        } \
-        \
-        inline void Add(type newElement) { \
-            Insert(newElement, m_numElements); \
-        } \
-        \
-        void Insert(type newElement, MP4ArrayIndex newIndex) { \
-            if (newIndex > m_numElements) { \
-                  throw new PlatformException("illegal array index", ERANGE, __FILE__, __LINE__, __FUNCTION__); \
-            } \
-            if (m_numElements == m_maxNumElements) { \
-                m_maxNumElements = max(m_maxNumElements, (MP4ArrayIndex)1) * 2; \
-                m_elements = (type*)MP4Realloc(m_elements, \
-                    m_maxNumElements * sizeof(type)); \
-            } \
-            memmove(&m_elements[newIndex + 1], &m_elements[newIndex], \
-                (m_numElements - newIndex) * sizeof(type)); \
-            m_elements[newIndex] = newElement; \
-            m_numElements++; \
-        } \
-        \
-        void Delete(MP4ArrayIndex index) { \
-            if (!ValidIndex(index)) { \
-                ostringstream msg; \
-                msg << "illegal array index: " << index << " of " << m_numElements; \
-                throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__); \
-            } \
-            m_numElements--; \
-            if (index < m_numElements) { \
-              memmove(&m_elements[index], &m_elements[index + 1], \
-                  (m_numElements - index) * sizeof(type)); \
-            } \
-        } \
-        void Resize(MP4ArrayIndex newSize) { \
-            m_numElements = newSize; \
-            m_maxNumElements = newSize; \
-            m_elements = (type*)MP4Realloc(m_elements, \
-                m_maxNumElements * sizeof(type)); \
-        } \
-        \
-        type& operator[](MP4ArrayIndex index) { \
-            if (ValidIndex(index)) { \
-                return m_elements[index]; \
-            } \
-            else { \
-                ostringstream msg; \
-                msg << "illegal array index: " << index << " of " << m_numElements; \
-                throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__ ); \
-            } \
-        } \
-        \
-    protected: \
-        type*   m_elements; \
-    };
-
-MP4ARRAY_DECL(MP4Integer8, uint8_t)
-
-MP4ARRAY_DECL(MP4Integer16, uint16_t)
-
-MP4ARRAY_DECL(MP4Integer32, uint32_t)
-
-MP4ARRAY_DECL(MP4Integer64, uint64_t)
-
-MP4ARRAY_DECL(MP4Float32, float)
-
-MP4ARRAY_DECL(MP4Float64, double)
-
-MP4ARRAY_DECL(MP4String, char*)
-
-MP4ARRAY_DECL(MP4Bytes, uint8_t*)
+typedef MP4Array<uint8_t> MP4Integer8Array;
+typedef MP4Array<uint16_t> MP4Integer16Array;
+typedef MP4Array<uint32_t> MP4Integer32Array;
+typedef MP4Array<uint64_t> MP4Integer64Array;
+typedef MP4Array<float> MP4Float32Array;
+typedef MP4Array<double> MP4Float64Array;
+typedef MP4Array<char*> MP4StringArray;
+typedef MP4Array<uint8_t*> MP4BytesArray;
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/src/mp4atom.cpp b/mp4v2/src/mp4atom.cpp
index b53fa39..a3f79ae 100644
--- a/mp4v2/src/mp4atom.cpp
+++ b/mp4v2/src/mp4atom.cpp
@@ -142,6 +142,13 @@ MP4Atom* MP4Atom::ReadAtom(MP4File& file, MP4Atom* pParentAtom)
         dataSize = file.GetSize() - pos;
     }
 
+    // Prevent integer underflow due to incorrect atom size read from file
+    if ( dataSize < hdrSize ) {
+       ostringstream oss;
+       oss << "Invalid atom size in '" << type << "' atom, dataSize = " << dataSize << " cannot be less than hdrSize = " << static_cast<unsigned>( hdrSize );
+       log.errorf( "%s: \"%s\": %s", __FUNCTION__, file.GetFilename().c_str(), oss.str().c_str() );
+       throw new EXCEPTION(oss.str().c_str());
+    }
     dataSize -= hdrSize;
 
     log.verbose1f("\"%s\": type = \"%s\" data-size = %" PRIu64 " (0x%" PRIx64 ") hdr %u",
@@ -190,15 +197,14 @@ MP4Atom* MP4Atom::ReadAtom(MP4File& file, MP4Atom* pParentAtom)
 
     pAtom->SetParentAtom(pParentAtom);
 
-	try {
-		pAtom->Read();
-	}
-	catch (Exception* x) {
-		// delete atom and rethrow so we don't leak memory.
-		delete pAtom;	
-		throw x;
-	}
-
+    try {
+        pAtom->Read();
+    }
+    catch (Exception*) {
+        // delete atom and rethrow so we don't leak memory.
+        delete pAtom;
+        throw;
+    }
 
     return pAtom;
 }
@@ -297,7 +303,7 @@ bool MP4Atom::IsMe(const char* name)
     }
 
     // root atom always matches
-    if (!strcmp(m_type, "")) {
+    if (strequal(m_type, "")) {
         return true;
     }
 
@@ -382,7 +388,7 @@ void MP4Atom::ReadProperties(uint32_t startIndex, uint32_t count)
 
             ostringstream oss;
             oss << "atom '" << GetType() << "' is too small; overrun at property: " << m_pProperties[i]->GetName();
-            throw new Exception( oss.str().c_str(), __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION(oss.str().c_str());
         }
 
         MP4LogLevel thisVerbosity =
@@ -603,7 +609,7 @@ void MP4Atom::ExpectChildAtom(const char* name, bool mandatory, bool onlyOne)
 
 uint8_t MP4Atom::GetVersion()
 {
-    if (strcmp("version", m_pProperties[0]->GetName())) {
+    if (!strequal("version", m_pProperties[0]->GetName())) {
         return 0;
     }
     return ((MP4Integer8Property*)m_pProperties[0])->GetValue();
@@ -611,7 +617,7 @@ uint8_t MP4Atom::GetVersion()
 
 void MP4Atom::SetVersion(uint8_t version)
 {
-    if (strcmp("version", m_pProperties[0]->GetName())) {
+    if (!strequal("version", m_pProperties[0]->GetName())) {
         return;
     }
     ((MP4Integer8Property*)m_pProperties[0])->SetValue(version);
@@ -619,7 +625,7 @@ void MP4Atom::SetVersion(uint8_t version)
 
 uint32_t MP4Atom::GetFlags()
 {
-    if (strcmp("flags", m_pProperties[1]->GetName())) {
+    if (!strequal("flags", m_pProperties[1]->GetName())) {
         return 0;
     }
     return ((MP4Integer24Property*)m_pProperties[1])->GetValue();
@@ -627,7 +633,7 @@ uint32_t MP4Atom::GetFlags()
 
 void MP4Atom::SetFlags(uint32_t flags)
 {
-    if (strcmp("flags", m_pProperties[1]->GetName())) {
+    if (!strequal("flags", m_pProperties[1]->GetName())) {
         return;
     }
     ((MP4Integer24Property*)m_pProperties[1])->SetValue(flags);
@@ -647,12 +653,13 @@ void MP4Atom::Dump(uint8_t indent, bool dumpImplicits)
         // create contextual atom-name
         string can;
         const list<string>::iterator ie = tlist.end();
-        for( list<string>::iterator it = tlist.begin(); it != ie; it++ )
+        for( list<string>::iterator it = tlist.begin(); it != ie; ++it )
             can += *it + '.';
         if( can.length() )
             can.resize( can.length() - 1 );
 
-        log.dump(indent, MP4_LOG_VERBOSE1, "type %s (%s)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": type %s (%s)",
+                 GetFile().GetFilename().c_str(),
                  m_type, can.c_str() );
     }
 
@@ -666,7 +673,8 @@ void MP4Atom::Dump(uint8_t indent, bool dumpImplicits)
         /* skip details of tables unless we're told to be verbose */
         if (m_pProperties[i]->GetType() == TableProperty
                 && (log.verbosity < MP4_LOG_VERBOSE2)) {
-            log.dump(indent + 1, MP4_LOG_VERBOSE1, "<table entries suppressed>" );
+            log.dump(indent + 1, MP4_LOG_VERBOSE1, "\"%s\": <table entries suppressed>",
+                     GetFile().GetFilename().c_str() );
             continue;
         }
 
@@ -779,8 +787,10 @@ MP4Atom::factory( MP4File &file, MP4Atom* parent, const char* type )
         const char* const ptype = parent->GetType();
 
         if( descendsFrom( parent, "ilst" )) {
-            if( ATOMID( ptype ) == ATOMID( "ilst" ))
-                return new MP4ItemAtom( file, type );
+            if( ATOMID( ptype ) == ATOMID( "ilst" )) {
+               ASSERT( ATOMID( type ) != ATOMID( "ilst" ));  // don't allow ilst to be a child of ilst
+               return new MP4ItemAtom( file, type );
+            }
 
             if( ATOMID( type ) == ATOMID( "data" ))
                 return new MP4DataAtom(file);
@@ -802,7 +812,7 @@ MP4Atom::factory( MP4File &file, MP4Atom* parent, const char* type )
             if( ATOMID( type ) == ATOMID( "hinf" ))
                 return new MP4HinfAtom(file);
             for( const char* const* p = UDTA_ELEMENTS; *p; p++ )
-                if( !strcmp( type, *p ))
+                if( strequal( type, *p ))
                     return new MP4UdtaElementAtom( file, type );
         }
     }
@@ -869,6 +879,8 @@ MP4Atom::factory( MP4File &file, MP4Atom* parent, const char* type )
                 return new MP4FtypAtom(file);
             if( ATOMID(type) == ATOMID("ftab") )
                 return new MP4FtabAtom(file);
+            if( ATOMID(type) == ATOMID("fLaC") )
+                return new MP4SoundAtom(file, type);
             break;
 
         case 'g':
@@ -892,6 +904,8 @@ MP4Atom::factory( MP4File &file, MP4Atom* parent, const char* type )
                 return new MP4TrefTypeAtom( file, type );
             if( ATOMID(type) == ATOMID("ima4") )
                 return new MP4SoundAtom( file, type );
+            if( ATOMID(type) == ATOMID("ipcm") )
+                return new MP4SoundAtom( file, type );
             break;
 
         case 'j':
@@ -899,6 +913,11 @@ MP4Atom::factory( MP4File &file, MP4Atom* parent, const char* type )
                 return new MP4VideoAtom(file, "jpeg");
             break;
 
+        case 'l':
+            if( ATOMID(type) == ATOMID("lpcm") )
+                return new MP4SoundAtom( file, type );
+            break;
+
         case 'm':
             if( ATOMID(type) == ATOMID("mdhd") )
                 return new MP4MdhdAtom(file);
diff --git a/mp4v2/src/mp4atom.h b/mp4v2/src/mp4atom.h
index 09d314b..6408497 100644
--- a/mp4v2/src/mp4atom.h
+++ b/mp4v2/src/mp4atom.h
@@ -34,7 +34,7 @@ namespace mp4v2 { namespace impl {
 ///////////////////////////////////////////////////////////////////////////////
 
 class MP4Atom;
-MP4ARRAY_DECL(MP4Atom, MP4Atom*);
+typedef MP4Array<MP4Atom*> MP4AtomArray;
 
 #define Required    true
 #define Optional    false
@@ -47,6 +47,9 @@ class MP4AtomInfo {
 public:
     MP4AtomInfo() {
         m_name = NULL;
+        m_mandatory = Optional;
+        m_onlyOne = OnlyOne;
+        m_count = 0;
     }
     MP4AtomInfo(const char* name, bool mandatory, bool onlyOne);
 
@@ -56,7 +59,7 @@ public:
     uint32_t m_count;
 };
 
-MP4ARRAY_DECL(MP4AtomInfo, MP4AtomInfo*);
+typedef MP4Array<MP4AtomInfo*> MP4AtomInfoArray;
 
 class MP4Atom
 {
diff --git a/mp4v2/src/mp4container.cpp b/mp4v2/src/mp4container.cpp
index 1278cbb..7093260 100644
--- a/mp4v2/src/mp4container.cpp
+++ b/mp4v2/src/mp4container.cpp
@@ -60,7 +60,7 @@ void MP4Container::FindIntegerProperty(const char* name,
                                        MP4Property** ppProperty, uint32_t* pIndex)
 {
     if (!FindProperty(name, ppProperty, pIndex)) {
-        throw new Exception("no such property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no such property");
     }
 
     switch ((*ppProperty)->GetType()) {
@@ -72,7 +72,7 @@ void MP4Container::FindIntegerProperty(const char* name,
     case Integer6432Property:
         break;
     default:
-        throw new Exception("type mismatch", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("type mismatch");
     }
 }
 
@@ -100,10 +100,10 @@ void MP4Container::FindFloatProperty(const char* name,
                                      MP4Property** ppProperty, uint32_t* pIndex)
 {
     if (!FindProperty(name, ppProperty, pIndex)) {
-        throw new Exception("no such property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no such property");
     }
     if ((*ppProperty)->GetType() != Float32Property) {
-        throw new Exception("type mismatch", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("type mismatch");
     }
 }
 
@@ -131,10 +131,10 @@ void MP4Container::FindStringProperty(const char* name,
                                       MP4Property** ppProperty, uint32_t* pIndex)
 {
     if (!FindProperty(name, ppProperty, pIndex)) {
-        throw new Exception("no such property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no such property");
     }
     if ((*ppProperty)->GetType() != StringProperty) {
-        throw new Exception("type mismatch", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("type mismatch");
     }
 }
 
@@ -162,10 +162,10 @@ void MP4Container::FindBytesProperty(const char* name,
                                      MP4Property** ppProperty, uint32_t* pIndex)
 {
     if (!FindProperty(name, ppProperty, pIndex)) {
-        throw new Exception("no such property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no such property");
     }
     if ((*ppProperty)->GetType() != BytesProperty) {
-        throw new Exception("type mismatch", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("type mismatch");
     }
 }
 
diff --git a/mp4v2/src/mp4descriptor.cpp b/mp4v2/src/mp4descriptor.cpp
index 202deb1..38c08d4 100644
--- a/mp4v2/src/mp4descriptor.cpp
+++ b/mp4v2/src/mp4descriptor.cpp
@@ -137,7 +137,7 @@ void MP4Descriptor::ReadProperties(MP4File& file,
             } else {
                 log.errorf("%s: \"%s\": Overran descriptor, tag %u data size %u property %u",
                            __FUNCTION__, file.GetFilename().c_str(), m_tag, m_size, i);
-                throw new Exception("overran descriptor",__FILE__, __LINE__, __FUNCTION__);
+                throw new EXCEPTION("overran descriptor");
             }
         }
     }
diff --git a/mp4v2/src/mp4file.cpp b/mp4v2/src/mp4file.cpp
index b5f434d..ea9e43f 100644
--- a/mp4v2/src/mp4file.cpp
+++ b/mp4v2/src/mp4file.cpp
@@ -34,6 +34,11 @@ namespace mp4v2 { namespace impl {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+#define PROTECT_WRITE_OPERATION() \
+    if( !IsWriteMode() ) {\
+        throw new EXCEPTION("operation not permitted in read mode"); \
+    }
+
 MP4File::MP4File( ) :
     m_file             ( NULL )
     , m_fileOriginalSize ( 0 )
@@ -64,8 +69,9 @@ void MP4File::Init()
     m_bufReadBits = 0;
     m_numWriteBits = 0;
     m_bufWriteBits = 0;
-    m_editName = NULL;
-    m_trakName[0] = '\0';
+
+    m_editName[0] = 0;
+    m_trakName[0] = 0;
 }
 
 MP4File::~MP4File()
@@ -74,7 +80,6 @@ MP4File::~MP4File()
     for( uint32_t i = 0; i < m_pTracks.Size(); i++ )
         delete m_pTracks[i];
     MP4Free( m_memoryBuffer ); // just in case
-    CHECK_AND_FREE( m_editName );
     delete m_file;
 }
 
@@ -90,25 +95,26 @@ MP4File::GetFilename() const
     return m_file->name;
 }
 
-void MP4File::Read( const char* name, const MP4FileProvider* provider )
+void MP4File::Read( const char* fileName, const MP4FileProvider* provider, const MP4IOCallbacks* callbacks, void* handle )
 {
-    Open( name, File::MODE_READ, provider );
+    Open( fileName, File::MODE_READ, provider, callbacks, handle );
     ReadFromFile();
     CacheProperties();
 }
 
-void MP4File::Create( const char*            fileName,
-                      uint32_t               flags,
-                      const MP4FileProvider* provider,
-                      int                    add_ftyp,
-                      int                    add_iods,
-                      char*                  majorBrand,
-                      uint32_t               minorVersion,
-                      char**                 supportedBrands,
-                      uint32_t               supportedBrandsCount )
+void MP4File::Create( const char*           fileName,
+                      const MP4IOCallbacks* callbacks,
+                      void*                 handle,
+                      uint32_t              flags,
+                      int                   add_ftyp,
+                      int                   add_iods,
+                      char*                 majorBrand,
+                      uint32_t              minorVersion,
+                      char**                supportedBrands,
+                      uint32_t              supportedBrandsCount )
 {
     m_createFlags = flags;
-    Open( fileName, File::MODE_CREATE, provider );
+    Open( fileName, File::MODE_CREATE, NULL, callbacks, handle );
 
     // generate a skeletal atom tree
     m_pRootAtom = MP4Atom::CreateAtom(*this, NULL, NULL);
@@ -132,9 +138,11 @@ void MP4File::Create( const char*            fileName,
     }
 }
 
-bool MP4File::Modify( const char* fileName )
+bool MP4File::Modify( const char*           fileName,
+                      const MP4IOCallbacks* callbacks,
+                      void*                 handle )
 {
-    Open( fileName, File::MODE_MODIFY, NULL );
+    Open( fileName, File::MODE_MODIFY, NULL, callbacks, handle );
     ReadFromFile();
 
     // find the moov atom
@@ -160,12 +168,12 @@ bool MP4File::Modify( const char* fileName )
             const char* type = pAtom->GetType();
 
             // get rid of any trailing free or skips
-            if (!strcmp(type, "free") || !strcmp(type, "skip")) {
+            if (strequal(type, "free") || strequal(type, "skip")) {
                 m_pRootAtom->DeleteChildAtom(pAtom);
                 continue;
             }
 
-            if (strcmp(type, "moov")) {
+            if (!strequal(type, "moov")) {
                 if (pLastAtom == NULL) {
                     pLastAtom = pAtom;
                     lastAtomIsMoov = false;
@@ -177,9 +185,7 @@ bool MP4File::Modify( const char* fileName )
 
             // multiple moov atoms?!?
             if (pAtom != pMoovAtom) {
-                throw new Exception(
-                    "Badly formed mp4 file, multiple moov atoms",
-                    __FILE__,__LINE__,__FUNCTION__);
+                throw new EXCEPTION("Badly formed mp4 file, multiple moov atoms");
             }
 
             if (lastAtomIsMoov) {
@@ -215,11 +221,20 @@ bool MP4File::Modify( const char* fileName )
 
     numAtoms = m_pRootAtom->GetNumberOfChildAtoms();
 
-    // insert another mdat prior to moov atom (the last atom)
-    MP4Atom* pMdatAtom = InsertChildAtom(m_pRootAtom, "mdat", numAtoms - 1);
+    // unless there already is an empty mdat atom,
+    // insert another one prior to moov atom (the last atom)
+    if (numAtoms > 1)
+    {
+        MP4Atom* pPreviousAtom = m_pRootAtom->GetChildAtom(numAtoms - 2);
+        if (!strequal(pPreviousAtom->GetType(), "mdat") || pPreviousAtom->GetSize() > 0)
+        {
+            MP4Atom* pMdatAtom = InsertChildAtom(m_pRootAtom, "mdat", numAtoms - 1);
+
+            // start writing new mdat
+            pMdatAtom->BeginWrite();
+        }
+    }
 
-    // start writing new mdat
-    pMdatAtom->BeginWrite();
     return true;
 }
 
@@ -251,7 +266,7 @@ void MP4File::Optimize( const char* srcFileName, const char* dstFileName )
 
     try {
         // file source to optimize
-        Open( srcFileName, File::MODE_READ, NULL );
+        Open( srcFileName, File::MODE_READ );
         ReadFromFile();
         CacheProperties(); // of moov atom
 
@@ -259,7 +274,7 @@ void MP4File::Optimize( const char* srcFileName, const char* dstFileName )
         m_file = NULL;
 
         // optimized file destination
-        Open( dname.c_str(), File::MODE_CREATE, NULL );
+        Open( dname.c_str(), File::MODE_CREATE );
         dst = m_file;
 
         SetIntegerProperty( "moov.mvhd.modificationTime", MP4GetAbsTimestamp() );
@@ -327,7 +342,7 @@ void MP4File::RewriteMdat( File& src, File& dst )
                 continue;
 
             // prefer hint tracks to media tracks if times are equal
-            if( nextChunkTimes[i] == nextTime && strcmp( m_pTracks[i]->GetType(), MP4_HINT_TRACK_TYPE ))
+            if( nextChunkTimes[i] == nextTime && !strequal( m_pTracks[i]->GetType(), MP4_HINT_TRACK_TYPE ))
                 continue;
 
             // this is our current choice of tracks
@@ -360,15 +375,28 @@ void MP4File::RewriteMdat( File& src, File& dst )
     delete [] nextChunkTimes;
 }
 
-void MP4File::Open( const char* name, File::Mode mode, const MP4FileProvider* provider )
+void MP4File::Open( const char*            fileName,
+                    File::Mode             mode,
+                    const MP4FileProvider* fileProvider,
+                    const MP4IOCallbacks*  callbacks,
+                    void*                  handle )
 {
     ASSERT( !m_file );
 
-    m_file = new File( name, mode, provider ? new io::CustomFileProvider( *provider ) : NULL );
+    const char* name = fileName;
+    io::FileProvider* provider = NULL;
+    if (fileProvider)
+        provider = new io::CustomFileProvider( *fileProvider );
+    else if (callbacks) {
+        name = "<callbacks>";
+        provider = new io::CallbacksFileProvider( *callbacks, handle );
+    }
+
+    m_file = new File( name, mode, provider );
     if( m_file->open() ) {
         ostringstream msg;
         msg << "open(" << name << ") failed";
-        throw new Exception( msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 
     switch( mode ) {
@@ -440,7 +468,7 @@ void MP4File::GenerateTracks()
 
             MP4Track* pTrack = NULL;
             try {
-                if (!strcmp(pTypeProperty->GetValue(), MP4_HINT_TRACK_TYPE)) {
+                if (strequal(pTypeProperty->GetValue(), MP4_HINT_TRACK_TYPE)) {
                     pTrack = new MP4RtpHintTrack(*this, *pTrakAtom);
                 } else {
                     pTrack = new MP4Track(*this, *pTrakAtom);
@@ -453,7 +481,7 @@ void MP4File::GenerateTracks()
             }
 
             // remember when we encounter the OD track
-            if (pTrack && !strcmp(pTrack->GetType(), MP4_OD_TRACK_TYPE)) {
+            if (pTrack && strequal(pTrack->GetType(), MP4_OD_TRACK_TYPE)) {
                 if (m_odTrackId == MP4_INVALID_TRACK_ID) {
                     m_odTrackId = pTrackIdProperty->GetValue();
                 } else {
@@ -489,55 +517,43 @@ void MP4File::BeginWrite()
 void MP4File::FinishWrite(uint32_t options)
 {
     // remove empty moov.udta.meta.ilst
-    {
-        MP4Atom* ilst = FindAtom( "moov.udta.meta.ilst" );
-        if( ilst ) {
-            if( ilst->GetNumberOfChildAtoms() == 0 ) {
-                ilst->GetParentAtom()->DeleteChildAtom( ilst );
-                delete ilst;
-            }
+    if( MP4Atom* ilst = FindAtom( "moov.udta.meta.ilst" ) ) {
+        if( ilst->GetNumberOfChildAtoms() == 0 ) {
+            ilst->GetParentAtom()->DeleteChildAtom( ilst );
+            delete ilst;
         }
     }
 
     // remove empty moov.udta.meta
-    {
-        MP4Atom* meta = FindAtom( "moov.udta.meta" );
-        if( meta ) {
-            if( meta->GetNumberOfChildAtoms() == 0 ) {
+    if( MP4Atom* meta = FindAtom( "moov.udta.meta" ) ) {
+        if( meta->GetNumberOfChildAtoms() == 0 ) {
+            meta->GetParentAtom()->DeleteChildAtom( meta );
+            delete meta;
+        }
+        else if( meta->GetNumberOfChildAtoms() == 1 ) {
+            if( ATOMID( meta->GetChildAtom( 0 )->GetType() ) == ATOMID( "hdlr" )) {
                 meta->GetParentAtom()->DeleteChildAtom( meta );
                 delete meta;
             }
-            else if( meta->GetNumberOfChildAtoms() == 1 ) {
-                if( ATOMID( meta->GetChildAtom( 0 )->GetType() ) == ATOMID( "hdlr" )) {
-                    meta->GetParentAtom()->DeleteChildAtom( meta );
-                    delete meta;
-                }
-            }
         }
     }
 
     // remove empty moov.udta.name
-    {
-        MP4Atom* name = FindAtom( "moov.udta.name" );
-        if( name ) {
-            unsigned char *val = NULL;
-            uint32_t valSize = 0;
-            GetBytesProperty("moov.udta.name.value", (uint8_t**)&val, &valSize);
-            if( valSize == 0 ) {
-                name->GetParentAtom()->DeleteChildAtom( name );
-                delete name;
-            }
+    if( MP4Atom* name = FindAtom( "moov.udta.name" ) ) {
+        unsigned char *val = NULL;
+        uint32_t valSize = 0;
+        GetBytesProperty("moov.udta.name.value", (uint8_t**)&val, &valSize);
+        if( valSize == 0 ) {
+            name->GetParentAtom()->DeleteChildAtom( name );
+            delete name;
         }
     }
 
     // remove empty moov.udta
-    {
-        MP4Atom* udta = FindAtom( "moov.udta" );
-        if( udta ) {
-            if( udta->GetNumberOfChildAtoms() == 0 ) {
-                udta->GetParentAtom()->DeleteChildAtom( udta );
-                delete udta;
-            }
+    if( MP4Atom* udta = FindAtom( "moov.udta" ) ) {
+        if( udta->GetNumberOfChildAtoms() == 0 ) {
+            udta->GetParentAtom()->DeleteChildAtom( udta );
+            delete udta;
         }
     }
 
@@ -550,9 +566,14 @@ void MP4File::FinishWrite(uint32_t options)
     // ask root atom to write
     m_pRootAtom->FinishWrite();
 
-    // finished all writes, if position < size then file has shrunk and
-    // we mark remaining bytes as free atom; otherwise trailing garbage remains.
-    if( GetPosition() < GetSize() ) {
+    // check if we can move the moov atom to the front
+    MoveMoovAtomToFront();
+
+    // finished all writes, if position < size then the file has
+    // shrunk and we first mark the remaining bytes with a free
+    // atom, then attempt to truncate
+    uint64_t endPosition = GetPosition();
+    if( endPosition < GetSize() ) {
         MP4RootAtom* root = (MP4RootAtom*)FindAtom( "" );
         ASSERT( root );
 
@@ -568,6 +589,78 @@ void MP4File::FinishWrite(uint32_t options)
         freeAtom->SetSize( size );
         root->AddChildAtom( freeAtom );
         freeAtom->Write();
+
+        // now attempt to truncate the file at the previous end position
+        // this is done after marking the area as free, because if truncate
+        // fails it may leave the file inaccessible, preventing us from
+        // inserting the free atom afterwards
+        m_file->truncate(endPosition);
+    }
+}
+
+void MP4File::MoveMoovAtomToFront()
+{
+    // makes sense only if there is a moov atom and at least one mdat atom
+    MP4Atom* moov = FindAtom("moov");
+    if (!moov || !FindAtom("mdat"))
+        return;
+
+    uint32_t numAtoms = m_pRootAtom->GetNumberOfChildAtoms();
+    for (uint32_t i = 0; i < numAtoms; i++) {
+        MP4Atom* atom = m_pRootAtom->GetChildAtom(i);
+        const char* type = atom->GetType();
+
+        // abort upon reaching a moov or mdat atom
+        if (strequal(type, "moov") || strequal(type, "mdat"))
+            break;
+
+        // check if this is a free atom and it's not 64 bit (extremely unlikely, so we don't handle that case)
+        if (!strequal(type, "free") || atom->GetLargesizeMode() || atom->GetSize() > (0xFFFFFFFF - 8))
+            continue;
+
+        uint32_t moovSize = moov->GetSize();
+        uint32_t freeSize = atom->GetSize();
+        uint64_t freeStart = atom->GetStart();
+
+        if (freeSize == moovSize) {
+            m_pRootAtom->DeleteChildAtom(atom);
+            m_pRootAtom->DeleteChildAtom(moov);
+            m_pRootAtom->InsertChildAtom(moov, i);
+
+            delete atom;
+
+            m_file->seek(freeStart);
+
+            moov->Write();
+        }
+        else if (freeSize >= moovSize + 8) {
+            m_pRootAtom->DeleteChildAtom(moov);
+            m_pRootAtom->InsertChildAtom(moov, i);
+
+            atom->SetSize(freeSize - moovSize - 8);
+
+            m_file->seek(freeStart);
+
+            moov->Write();
+            atom->Write();
+        }
+        else
+            continue;
+
+        // position file pointer after last mdat atom
+        numAtoms = m_pRootAtom->GetNumberOfChildAtoms();
+        for (int j = numAtoms - 1; j >= 0; j--) {
+            MP4Atom* atom = m_pRootAtom->GetChildAtom(j);
+            if (!strequal(atom->GetType(), "mdat"))
+                continue;
+
+            m_file->seek(atom->GetEnd());
+            break;
+        }
+
+        // write atoms after last mdat again
+        m_pRootAtom->FinishWrite();
+        break;
     }
 }
 
@@ -599,15 +692,7 @@ void MP4File::Close(uint32_t options)
 void MP4File::Rename(const char* oldFileName, const char* newFileName)
 {
     if( FileSystem::rename( oldFileName, newFileName ))
-        throw new PlatformException( sys::getLastErrorStr(), sys::getLastError(), __FILE__, __LINE__, __FUNCTION__ );
-}
-
-void MP4File::ProtectWriteOperation(const char* file,
-                                    int         line,
-                                    const char* func )
-{
-    if( !IsWriteMode() )
-        throw new Exception( "operation not permitted in read mode", file, line, func );
+        throw new PLATFORM_EXCEPTION(sys::getLastErrorStr(), sys::getLastError());
 }
 
 MP4Track* MP4File::GetTrack(MP4TrackId trackId)
@@ -618,7 +703,7 @@ MP4Track* MP4File::GetTrack(MP4TrackId trackId)
 MP4Atom* MP4File::FindAtom(const char* name)
 {
     MP4Atom* pAtom = NULL;
-    if (!name || !strcmp(name, "")) {
+    if (!name || strequal(name, "")) {
         pAtom = m_pRootAtom;
     } else {
         pAtom = m_pRootAtom->FindAtom(name);
@@ -716,7 +801,7 @@ void MP4File::FindIntegerProperty(const char* name,
     if (!FindProperty(name, ppProperty, pIndex)) {
         ostringstream msg;
         msg << "no such property - " << name;
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 
     switch ((*ppProperty)->GetType()) {
@@ -730,7 +815,7 @@ void MP4File::FindIntegerProperty(const char* name,
     default:
         ostringstream msg;
         msg << "type mismatch - property " << name << " type " << (*ppProperty)->GetType();
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 }
 
@@ -746,7 +831,7 @@ uint64_t MP4File::GetIntegerProperty(const char* name)
 
 void MP4File::SetIntegerProperty(const char* name, uint64_t value)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Property* pProperty = NULL;
     uint32_t index = 0;
@@ -762,12 +847,27 @@ void MP4File::FindFloatProperty(const char* name,
     if (!FindProperty(name, ppProperty, pIndex)) {
         ostringstream msg;
         msg << "no such property - " << name;
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
     if ((*ppProperty)->GetType() != Float32Property) {
         ostringstream msg;
         msg << "type mismatch - property " << name << " type " << (*ppProperty)->GetType();
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
+    }
+}
+
+void MP4File::FindDoubleProperty(const char* name,
+                                 MP4Property** ppProperty, uint32_t* pIndex)
+{
+    if (!FindProperty(name, ppProperty, pIndex)) {
+        ostringstream msg;
+        msg << "no such property - " << name;
+        throw new EXCEPTION(msg.str());
+    }
+    if ((*ppProperty)->GetType() != Float64Property) {
+        ostringstream msg;
+        msg << "type mismatch - property " << name << " type " << (*ppProperty)->GetType();
+        throw new EXCEPTION(msg.str());
     }
 }
 
@@ -781,9 +881,19 @@ float MP4File::GetFloatProperty(const char* name)
     return ((MP4Float32Property*)pProperty)->GetValue(index);
 }
 
+double MP4File::GetDoubleProperty(const char* name)
+{
+    MP4Property* pProperty;
+    uint32_t index;
+
+    FindDoubleProperty(name, &pProperty, &index);
+
+    return ((MP4Float64Property*)pProperty)->GetValue(index);
+}
+
 void MP4File::SetFloatProperty(const char* name, float value)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Property* pProperty;
     uint32_t index;
@@ -793,18 +903,30 @@ void MP4File::SetFloatProperty(const char* name, float value)
     ((MP4Float32Property*)pProperty)->SetValue(value, index);
 }
 
+void MP4File::SetDoubleProperty(const char* name, double value)
+{
+    PROTECT_WRITE_OPERATION();
+
+    MP4Property* pProperty;
+    uint32_t index;
+
+    FindDoubleProperty(name, &pProperty, &index);
+
+    ((MP4Float64Property*)pProperty)->SetValue(value, index);
+}
+
 void MP4File::FindStringProperty(const char* name,
                                  MP4Property** ppProperty, uint32_t* pIndex)
 {
     if (!FindProperty(name, ppProperty, pIndex)) {
         ostringstream msg;
         msg << "no such property - " << name;
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
     if ((*ppProperty)->GetType() != StringProperty) {
         ostringstream msg;
         msg << "type mismatch - property " << name << " type " << (*ppProperty)->GetType();
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 }
 
@@ -820,7 +942,7 @@ const char* MP4File::GetStringProperty(const char* name)
 
 void MP4File::SetStringProperty(const char* name, const char* value)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Property* pProperty;
     uint32_t index;
@@ -836,12 +958,12 @@ void MP4File::FindBytesProperty(const char* name,
     if (!FindProperty(name, ppProperty, pIndex)) {
         ostringstream msg;
         msg << "no such property " << name;
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
     if ((*ppProperty)->GetType() != BytesProperty) {
         ostringstream msg;
         msg << "type mismatch - property " << name << " - type " <<  (*ppProperty)->GetType();
-        throw new Exception(msg.str(), __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION(msg.str());
     }
 }
 
@@ -859,7 +981,7 @@ void MP4File::GetBytesProperty(const char* name,
 void MP4File::SetBytesProperty(const char* name,
                                const uint8_t* pValue, uint32_t valueSize)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Property* pProperty;
     uint32_t index;
@@ -874,7 +996,7 @@ void MP4File::SetBytesProperty(const char* name,
 
 MP4TrackId MP4File::AddTrack(const char* type, uint32_t timeScale)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     // create and add new trak atom
     MP4Atom* pTrakAtom = AddChildAtom("moov", "trak");
@@ -917,7 +1039,7 @@ MP4TrackId MP4File::AddTrack(const char* type, uint32_t timeScale)
 
     // now have enough to create MP4Track object
     MP4Track* pTrack = NULL;
-    if (!strcmp(normType, MP4_HINT_TRACK_TYPE)) {
+    if (strequal(normType, MP4_HINT_TRACK_TYPE)) {
         pTrack = new MP4RtpHintTrack(*this, *pTrakAtom);
     } else {
         pTrack = new MP4Track(*this, *pTrakAtom);
@@ -925,7 +1047,7 @@ MP4TrackId MP4File::AddTrack(const char* type, uint32_t timeScale)
     m_pTracks.Add(pTrack);
 
     // mark non-hint tracks as enabled
-    if (strcmp(normType, MP4_HINT_TRACK_TYPE)) {
+    if (!strequal(normType, MP4_HINT_TRACK_TYPE)) {
         SetTrackIntegerProperty(trackId, "tkhd.flags", 1);
     }
 
@@ -1138,7 +1260,7 @@ MP4TrackId MP4File::AddODTrack()
     // until a demonstrated need emerges
     // we limit ourselves to one object description track
     if (m_odTrackId != MP4_INVALID_TRACK_ID) {
-        throw new Exception("object description track already exists",__FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("object description track already exists");
     }
 
     m_odTrackId = AddSystemsTrack(MP4_OD_TRACK_TYPE);
@@ -1413,7 +1535,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
     if (pSampleRateProperty) {
         pSampleRateProperty->SetValue(samplingRate);
     } else {
-        throw new Exception("no ac-3.samplingRate property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no ac-3.samplingRate property");
     }
 
     MP4BitfieldProperty* pBitfieldProperty = NULL;
@@ -1424,7 +1546,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(fscod);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.fscod property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.fscod property");
     }
 
     FindProperty(MakeTrackName(trackId, "mdia.minf.stbl.stsd.ac-3.dac3.bsid"),
@@ -1433,7 +1555,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(bsid);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.bsid property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.bsid property");
     }
 
     FindProperty(MakeTrackName(trackId, "mdia.minf.stbl.stsd.ac-3.dac3.bsmod"),
@@ -1442,7 +1564,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(bsmod);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.bsmod property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.bsmod property");
     }
 
     FindProperty(MakeTrackName(trackId, "mdia.minf.stbl.stsd.ac-3.dac3.acmod"),
@@ -1451,7 +1573,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(acmod);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.acmod property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.acmod property");
     }
 
     FindProperty(MakeTrackName(trackId, "mdia.minf.stbl.stsd.ac-3.dac3.lfeon"),
@@ -1460,7 +1582,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(lfeon);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.lfeon property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.lfeon property");
     }
 
     FindProperty(MakeTrackName(trackId, "mdia.minf.stbl.stsd.ac-3.dac3.bit_rate_code"),
@@ -1469,7 +1591,7 @@ MP4TrackId MP4File::AddAC3AudioTrack(
         pBitfieldProperty->SetValue(bit_rate_code);
         pBitfieldProperty = NULL;
     } else {
-        throw new Exception("no dac3.bit_rate_code property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no dac3.bit_rate_code property");
     }
 
     AddDescendantAtoms(MakeTrackName(trackId, NULL), "udta.name");
@@ -1500,8 +1622,6 @@ MP4TrackId MP4File::AddEncAudioTrack(uint32_t timeScale,
                                      bool use_ismacryp
                                     )
 {
-    uint32_t original_fmt = 0;
-
     MP4TrackId trackId = AddTrack(MP4_AUDIO_TRACK_TYPE, timeScale);
 
     AddTrackToOd(trackId);
@@ -1523,7 +1643,7 @@ MP4TrackId MP4File::AddEncAudioTrack(uint32_t timeScale,
     /* set all the ismacryp-specific values */
     // original format is mp4a
     if (use_ismacryp) {
-        original_fmt = ATOMID("mp4a");
+        uint32_t original_fmt = ATOMID("mp4a");
         SetTrackIntegerProperty(trackId,
                                 "mdia.minf.stbl.stsd.enca.sinf.frma.data-format",
                                 original_fmt);
@@ -2296,7 +2416,7 @@ void MP4File::AddChapter(MP4TrackId chapterTrackId, MP4Duration chapterDuration,
 {
     if (MP4_INVALID_TRACK_ID == chapterTrackId)
     {
-        throw new Exception("No chapter track given",__FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("No chapter track given");
     }
 
     uint32_t sampleLength = 0;
@@ -2308,14 +2428,12 @@ void MP4File::AddChapter(MP4TrackId chapterTrackId, MP4Duration chapterDuration,
     {
         textLen = min((uint32_t)strlen(chapterTitle), (uint32_t)MP4V2_CHAPTER_TITLE_MAX);
         if (0 < textLen)
-        {
-            strncpy(text, chapterTitle, textLen);
-        }
+            strncpy(text, chapterTitle, MP4V2_CHAPTER_TITLE_MAX);
     }
     else
     {
         MP4Track * pChapterTrack = GetTrack(chapterTrackId);
-        snprintf( text, 1023, "Chapter %03d", pChapterTrack->GetNumberOfSamples() + 1 );
+        snprintf( text, 1023, "Chapter %03" PRIu32, pChapterTrack->GetNumberOfSamples() + 1 );
         textLen = (uint32_t)strlen(text);
     }
 
@@ -2359,25 +2477,19 @@ void MP4File::AddNeroChapter(MP4Timestamp chapterStart, const char * chapterTitl
     MP4Integer32Property * pCount = (MP4Integer32Property*)pChpl->GetProperty(3);
     pCount->IncrementValue();
 
-    char buffer[256];
+    char buffer[256] = { 0 };
 
     if (0 == chapterTitle)
-    {
-        snprintf( buffer, 255, "Chapter %03d", pCount->GetValue() );
-    }
+        snprintf( buffer, 255, "Chapter %03" PRIu32, pCount->GetValue() );
     else
-    {
-        int len = min((uint32_t)strlen(chapterTitle), (uint32_t)255);
-        strncpy( buffer, chapterTitle, len );
-        buffer[len] = 0;
-    }
+        strncpy( buffer, chapterTitle, 255 );
 
     MP4TableProperty * pTable;
     if (pChpl->FindProperty("chpl.chapters", (MP4Property **)&pTable))
     {
         MP4Integer64Property * pStartTime = (MP4Integer64Property *) pTable->GetProperty(0);
         MP4StringProperty * pName = (MP4StringProperty *) pTable->GetProperty(1);
-        if (pStartTime && pTable)
+        if (pStartTime && pName)
         {
             pStartTime->AddValue(chapterStart);
             pName->AddValue(buffer);
@@ -2398,9 +2510,8 @@ MP4TrackId MP4File::FindChapterReferenceTrack(MP4TrackId chapterTrackId, char *
             {
                 if( 0 != trackName )
                 {
-                    int nameLen = min((uint32_t)strlen(name), (uint32_t)trackNameSize);
-                    strncpy(trackName, name, nameLen);
-                    trackName[nameLen] = 0;
+                    strncpy(trackName, name, trackNameSize - 1);
+                    trackName[trackNameSize - 1] = 0;
                 }
 
                 return m_pTracks[i]->GetId();
@@ -2449,14 +2560,10 @@ MP4ChapterType MP4File::DeleteChapters(MP4ChapterType chapterType, MP4TrackId ch
 
         // no text track given, find a suitable
         if (MP4_INVALID_TRACK_ID == chapterTrackId)
-        {
-            chapterTrackId = FindChapterTrack(trackName, 127);
-        }
+            chapterTrackId = FindChapterTrack(trackName, 128);
 
         if (MP4_INVALID_TRACK_ID != chapterTrackId)
-        {
-            FindChapterReferenceTrack(chapterTrackId, trackName, 127);
-        }
+            FindChapterReferenceTrack(chapterTrackId, trackName, 128);
 
         if (MP4_INVALID_TRACK_ID != chapterTrackId && 0 != trackName[0])
         {
@@ -2607,9 +2714,8 @@ MP4ChapterType MP4File::GetChapters(MP4Chapter_t ** chapterList, uint32_t * chap
         for (i = 0, j = 1; i < counter; ++i, ++j)
         {
             // insert the chapter title
-            uint32_t len = min((uint32_t)strlen(name), (uint32_t)MP4V2_CHAPTER_TITLE_MAX);
-            strncpy(chapters[i].title, name, len);
-            chapters[i].title[len] = 0;
+            strncpy(chapters[i].title, name, MP4V2_CHAPTER_TITLE_MAX);
+            chapters[i].title[MP4V2_CHAPTER_TITLE_MAX] = 0;
 
             // calculate the duration
             MP4Duration duration = 0;
@@ -2766,7 +2872,7 @@ void MP4File::ChangeMovieTimeScale(uint32_t timescale)
 
 void MP4File::DeleteTrack(MP4TrackId trackId)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     uint32_t trakIndex = FindTrakAtomIndex(trackId);
     uint16_t trackIndex = FindTrackIndex(trackId);
@@ -2804,13 +2910,13 @@ uint32_t MP4File::GetNumberOfTracks(const char* type, uint8_t subType)
     const char* normType = MP4NormalizeTrackType(type);
 
     for (uint32_t i = 0; i < m_pTracks.Size(); i++) {
-        if (!strcmp(normType, m_pTracks[i]->GetType())) {
+        if (strequal(normType, m_pTracks[i]->GetType())) {
             if (subType) {
-                if (strcmp(normType, MP4_AUDIO_TRACK_TYPE) == 0) {
+                if (strequal(normType, MP4_AUDIO_TRACK_TYPE)) {
                     if (subType != GetTrackEsdsObjectTypeId(m_pTracks[i]->GetId())) {
                         continue;
                     }
-                } else if (strcmp(normType, MP4_VIDEO_TRACK_TYPE)) {
+                } else if (strequal(normType, MP4_VIDEO_TRACK_TYPE)) {
                     if (subType != GetTrackEsdsObjectTypeId(m_pTracks[i]->GetId())) {
                         continue;
                     }
@@ -2856,8 +2962,7 @@ MP4TrackId MP4File::AllocTrackId()
     }
 
     // extreme case where mp4 file has 2^16 tracks in it
-    throw new Exception("too many existing tracks", __FILE__, __LINE__, __FUNCTION__);
-    return MP4_INVALID_TRACK_ID;        // to keep MSVC happy
+    throw new EXCEPTION("too many existing tracks");
 }
 
 MP4TrackId MP4File::FindTrackId(uint16_t trackIndex,
@@ -2871,13 +2976,13 @@ MP4TrackId MP4File::FindTrackId(uint16_t trackIndex,
     const char* normType = MP4NormalizeTrackType(type);
 
     for (uint32_t i = 0; i < m_pTracks.Size(); i++) {
-        if (!strcmp(normType, m_pTracks[i]->GetType())) {
+        if (strequal(normType, m_pTracks[i]->GetType())) {
             if (subType) {
-                if (strcmp(normType, MP4_AUDIO_TRACK_TYPE) == 0) {
+                if (strequal(normType, MP4_AUDIO_TRACK_TYPE)) {
                     if (subType != GetTrackEsdsObjectTypeId(m_pTracks[i]->GetId())) {
                         continue;
                     }
-                } else if (strcmp(normType, MP4_VIDEO_TRACK_TYPE) == 0) {
+                } else if (strequal(normType, MP4_VIDEO_TRACK_TYPE)) {
                     if (subType != GetTrackEsdsObjectTypeId(m_pTracks[i]->GetId())) {
                         continue;
                     }
@@ -2895,8 +3000,7 @@ MP4TrackId MP4File::FindTrackId(uint16_t trackIndex,
 
     ostringstream msg;
     msg << "Track index doesn't exist - track " << trackIndex << " type " << type;
-    throw new Exception(msg.str(),__FILE__, __LINE__, __FUNCTION__);
-    return MP4_INVALID_TRACK_ID; // satisfy MS compiler
+    throw new EXCEPTION(msg.str());
 }
 
 uint16_t MP4File::FindTrackIndex(MP4TrackId trackId)
@@ -2909,8 +3013,7 @@ uint16_t MP4File::FindTrackIndex(MP4TrackId trackId)
 
     ostringstream msg;
     msg << "Track id " << trackId << " doesn't exist";
-    throw new Exception(msg.str(),__FILE__, __LINE__, __FUNCTION__);
-    return (uint16_t)-1; // satisfy MS compiler
+    throw new EXCEPTION(msg.str());
 }
 
 uint16_t MP4File::FindTrakAtomIndex(MP4TrackId trackId)
@@ -2925,8 +3028,7 @@ uint16_t MP4File::FindTrakAtomIndex(MP4TrackId trackId)
 
     ostringstream msg;
     msg << "Track id " << trackId << " doesn't exist";
-    throw new Exception(msg.str(),__FILE__, __LINE__, __FUNCTION__);
-    return (uint16_t)-1; // satisfy MS compiler
+    throw new EXCEPTION(msg.str());
 }
 
 uint32_t MP4File::GetSampleSize(MP4TrackId trackId, MP4SampleId sampleId)
@@ -3008,7 +3110,7 @@ void MP4File::WriteSample(
     MP4Duration    renderingOffset,
     bool           isSyncSample )
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     m_pTracks[FindTrackIndex(trackId)]->WriteSample(
         pBytes, numBytes, duration, renderingOffset, isSyncSample );
     m_pModificationProperty->SetValue( MP4GetAbsTimestamp() );
@@ -3023,7 +3125,7 @@ void MP4File::WriteSampleDependency(
     bool           isSyncSample,
     uint32_t       dependencyFlags )
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     m_pTracks[FindTrackIndex(trackId)]->WriteSampleDependency(
         pBytes, numBytes, duration, renderingOffset, isSyncSample, dependencyFlags );
     m_pModificationProperty->SetValue( MP4GetAbsTimestamp() );
@@ -3032,7 +3134,7 @@ void MP4File::WriteSampleDependency(
 void MP4File::SetSampleRenderingOffset(MP4TrackId trackId,
                                        MP4SampleId sampleId, MP4Duration renderingOffset)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     m_pTracks[FindTrackIndex(trackId)]->
     SetSampleRenderingOffset(sampleId, renderingOffset);
 
@@ -3065,12 +3167,13 @@ char* MP4File::MakeTrackName(MP4TrackId trackId, const char* name)
 {
     uint16_t trakIndex = FindTrakAtomIndex(trackId);
 
-    if (name == NULL || name[0] == '\0') {
+    if (name == NULL || name[0] == 0) {
         snprintf(m_trakName, sizeof(m_trakName),
                  "moov.trak[%u]", trakIndex);
     } else {
-        snprintf(m_trakName, sizeof(m_trakName),
-                 "moov.trak[%u].%s", trakIndex, name);
+        if (snprintf(m_trakName, sizeof(m_trakName),
+                     "moov.trak[%u].%s", trakIndex, name) >= (int) sizeof(m_trakName))
+            return NULL;
     }
     return m_trakName;
 }
@@ -3102,6 +3205,12 @@ void MP4File::SetTrackFloatProperty(MP4TrackId trackId, const char* name,
     SetFloatProperty(MakeTrackName(trackId, name), value);
 }
 
+void MP4File::SetTrackDoubleProperty(MP4TrackId trackId, const char* name,
+                                     double value)
+{
+    SetDoubleProperty(MakeTrackName(trackId, name), value);
+}
+
 const char* MP4File::GetTrackStringProperty(MP4TrackId trackId, const char* name)
 {
     return GetStringProperty(MakeTrackName(trackId, name));
@@ -3153,7 +3262,7 @@ bool MP4File::GetTrackLanguage( MP4TrackId trackId, char* code )
 
 bool MP4File::SetTrackLanguage( MP4TrackId trackId, const char* code )
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     ostringstream oss;
     oss << "moov.trak[" << FindTrakAtomIndex(trackId) << "].mdia.mdhd.language";
@@ -3202,7 +3311,7 @@ bool MP4File::GetTrackName( MP4TrackId trackId, char** name )
 
 bool MP4File::SetTrackName( MP4TrackId trackId, const char* name )
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     char atomstring[40];
     MP4Atom *pMetaAtom;
     MP4BytesProperty *pMetadataProperty = NULL;
@@ -3248,7 +3357,7 @@ uint32_t MP4File::GetTimeScale()
 void MP4File::SetTimeScale(uint32_t value)
 {
     if (value == 0) {
-        throw new Exception("invalid value", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("invalid value");
     }
     m_pTimeScaleProperty->SetValue(value);
 }
@@ -3389,6 +3498,9 @@ const char *MP4File::GetTrackMediaDataName (MP4TrackId trackId)
     MP4Atom *pAtom =
         FindAtom(MakeTrackName(trackId,
                                "mdia.minf.stbl.stsd"));
+    if ( pAtom == NULL )
+       return NULL;
+
     if (pAtom->GetNumberOfChildAtoms() != 1) {
         log.errorf("%s: \"%s\": track %d has more than 1 child atoms in stsd", 
                    __FUNCTION__, GetFilename().c_str(), trackId);
@@ -3407,7 +3519,7 @@ uint32_t MP4File::GetTrackTimeScale(MP4TrackId trackId)
 void MP4File::SetTrackTimeScale(MP4TrackId trackId, uint32_t value)
 {
     if (value == 0) {
-        throw new Exception("invalid value", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("invalid value");
     }
     SetTrackIntegerProperty(trackId, "mdia.mdhd.timeScale", value);
 }
@@ -3556,7 +3668,7 @@ void MP4File::SetTrackESConfiguration(MP4TrackId trackId,
                      (MP4Property**)&pConfigDescrProperty) == false ||
             pConfigDescrProperty == NULL) {
         // probably trackId refers to a hint track
-        throw new Exception("no such property", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no such property");
     }
 
     // lookup the property to store the configuration
@@ -3682,8 +3794,8 @@ void MP4File::SetHintTrackSdp(MP4TrackId hintTrackId, const char* sdpString)
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
 
     (void)AddDescendantAtoms(
@@ -3722,8 +3834,8 @@ void MP4File::GetHintTrackRtpPayload(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
 
     ((MP4RtpHintTrack*)pTrack)->GetPayload(
@@ -3738,8 +3850,8 @@ void MP4File::SetHintTrackRtpPayload(MP4TrackId hintTrackId,
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
 
     uint8_t payloadNumber;
@@ -3788,8 +3900,7 @@ uint8_t MP4File::AllocRtpPayloadNumber()
     }
 
     if (payload >= 128) {
-        throw new Exception("no more available rtp payload numbers",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no more available rtp payload numbers");
     }
 
     return payload;
@@ -3800,9 +3911,8 @@ MP4TrackId MP4File::GetHintTrackReferenceTrackId(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
 
     MP4Track* pRefTrack = ((MP4RtpHintTrack*)pTrack)->GetRefTrack();
@@ -3820,8 +3930,8 @@ void MP4File::ReadRtpHint(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->
     ReadHint(hintSampleId, pNumPackets);
@@ -3832,9 +3942,8 @@ uint16_t MP4File::GetRtpHintNumberOfPackets(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     return ((MP4RtpHintTrack*)pTrack)->GetHintNumberOfPackets();
 }
@@ -3845,9 +3954,8 @@ int8_t MP4File::GetRtpPacketBFrame(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     return ((MP4RtpHintTrack*)pTrack)->GetPacketBFrame(packetIndex);
 }
@@ -3858,9 +3966,8 @@ int32_t MP4File::GetRtpPacketTransmitOffset(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     return ((MP4RtpHintTrack*)pTrack)->GetPacketTransmitOffset(packetIndex);
 }
@@ -3876,8 +3983,8 @@ void MP4File::ReadRtpPacket(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->ReadPacket(
         packetIndex, ppBytes, pNumBytes,
@@ -3889,8 +3996,8 @@ MP4Timestamp MP4File::GetRtpTimestampStart(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     return ((MP4RtpHintTrack*)pTrack)->GetRtpTimestampStart();
 }
@@ -3901,9 +4008,8 @@ void MP4File::SetRtpTimestampStart(
 {
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->SetRtpTimestampStart(rtpStart);
 }
@@ -3911,12 +4017,12 @@ void MP4File::SetRtpTimestampStart(
 void MP4File::AddRtpHint(MP4TrackId hintTrackId,
                          bool isBframe, uint32_t timestampOffset)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->AddHint(isBframe, timestampOffset);
 }
@@ -3924,12 +4030,12 @@ void MP4File::AddRtpHint(MP4TrackId hintTrackId,
 void MP4File::AddRtpPacket(
     MP4TrackId hintTrackId, bool setMbit, int32_t transmitOffset)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track", __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->AddPacket(setMbit, transmitOffset);
 }
@@ -3937,13 +4043,12 @@ void MP4File::AddRtpPacket(
 void MP4File::AddRtpImmediateData(MP4TrackId hintTrackId,
                                   const uint8_t* pBytes, uint32_t numBytes)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->AddImmediateData(pBytes, numBytes);
 }
@@ -3951,13 +4056,12 @@ void MP4File::AddRtpImmediateData(MP4TrackId hintTrackId,
 void MP4File::AddRtpSampleData(MP4TrackId hintTrackId,
                                MP4SampleId sampleId, uint32_t dataOffset, uint32_t dataLength)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->AddSampleData(
         sampleId, dataOffset, dataLength);
@@ -3965,13 +4069,12 @@ void MP4File::AddRtpSampleData(MP4TrackId hintTrackId,
 
 void MP4File::AddRtpESConfigurationPacket(MP4TrackId hintTrackId)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->AddESConfigurationPacket();
 }
@@ -3979,13 +4082,12 @@ void MP4File::AddRtpESConfigurationPacket(MP4TrackId hintTrackId)
 void MP4File::WriteRtpHint(MP4TrackId hintTrackId,
                            MP4Duration duration, bool isSyncSample)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
 
     MP4Track* pTrack = m_pTracks[FindTrackIndex(hintTrackId)];
 
-    if (strcmp(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
-        throw new Exception("track is not a hint track",
-                            __FILE__, __LINE__, __FUNCTION__);
+    if (!strequal(pTrack->GetType(), MP4_HINT_TRACK_TYPE)) {
+        throw new EXCEPTION("track is not a hint track");
     }
     ((MP4RtpHintTrack*)pTrack)->WriteHint(duration, isSyncSample);
 }
@@ -4038,19 +4140,19 @@ uint8_t MP4File::ConvertTrackTypeToStreamType(const char* trackType)
 {
     uint8_t streamType;
 
-    if (!strcmp(trackType, MP4_OD_TRACK_TYPE)) {
+    if (strequal(trackType, MP4_OD_TRACK_TYPE)) {
         streamType = MP4ObjectDescriptionStreamType;
-    } else if (!strcmp(trackType, MP4_SCENE_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_SCENE_TRACK_TYPE)) {
         streamType = MP4SceneDescriptionStreamType;
-    } else if (!strcmp(trackType, MP4_CLOCK_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_CLOCK_TRACK_TYPE)) {
         streamType = MP4ClockReferenceStreamType;
-    } else if (!strcmp(trackType, MP4_MPEG7_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_MPEG7_TRACK_TYPE)) {
         streamType = MP4Mpeg7StreamType;
-    } else if (!strcmp(trackType, MP4_OCI_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_OCI_TRACK_TYPE)) {
         streamType = MP4OCIStreamType;
-    } else if (!strcmp(trackType, MP4_IPMP_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_IPMP_TRACK_TYPE)) {
         streamType = MP4IPMPStreamType;
-    } else if (!strcmp(trackType, MP4_MPEGJ_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_MPEGJ_TRACK_TYPE)) {
         streamType = MP4MPEGJStreamType;
     } else {
         streamType = MP4UserPrivateStreamType;
@@ -4068,13 +4170,11 @@ char* MP4File::MakeTrackEditName(
 {
     char* trakName = MakeTrackName(trackId, NULL);
 
-    if (m_editName == NULL) {
-        m_editName = (char *)malloc(1024);
-        if (m_editName == NULL) return NULL;
-    }
-    snprintf(m_editName, 1024,
-             "%s.edts.elst.entries[%u].%s",
-             trakName, editId - 1, name);
+    if (snprintf(m_editName, sizeof(m_editName),
+                 "%s.edts.elst.entries[%u].%s",
+                 trakName, editId - 1, name) >= (int) sizeof(m_editName))
+        return NULL;
+
     return m_editName;
 }
 
@@ -4082,7 +4182,7 @@ MP4EditId MP4File::AddTrackEdit(
     MP4TrackId trackId,
     MP4EditId editId)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     return m_pTracks[FindTrackIndex(trackId)]->AddEdit(editId);
 }
 
@@ -4090,7 +4190,7 @@ void MP4File::DeleteTrackEdit(
     MP4TrackId trackId,
     MP4EditId editId)
 {
-    ProtectWriteOperation(__FILE__, __LINE__, __FUNCTION__);
+    PROTECT_WRITE_OPERATION();
     m_pTracks[FindTrackIndex(trackId)]->DeleteEdit(editId);
 }
 
diff --git a/mp4v2/src/mp4file.h b/mp4v2/src/mp4file.h
index 5f0b2a5..d2a8eb0 100644
--- a/mp4v2/src/mp4file.h
+++ b/mp4v2/src/mp4file.h
@@ -74,19 +74,28 @@ public:
     // file ops
     ///////////////////////////////////////////////////////////////////////////
 
-    void Create( const char*            fileName,
-                 uint32_t               flags,
-                 const MP4FileProvider* provider = NULL,
-                 int                    add_ftyp = 1,
-                 int                    add_iods = 1,
-                 char*                  majorBrand = NULL,
-                 uint32_t               minorVersion = 0,
-                 char**                 supportedBrands = NULL,
-                 uint32_t               supportedBrandsCount = 0 );
-
     const std::string &GetFilename() const;
-    void Read( const char* name, const MP4FileProvider* provider );
-    bool Modify( const char* fileName );
+
+    void Read( const char*            fileName,
+               const MP4FileProvider* provider,
+               const MP4IOCallbacks*  callbacks,
+               void*                  handle );
+
+    void Create( const char*           fileName,
+                 const MP4IOCallbacks* callbacks,
+                 void*                 handle,
+                 uint32_t              flags,
+                 int                   add_ftyp = 1,
+                 int                   add_iods = 1,
+                 char*                 majorBrand = NULL,
+                 uint32_t              minorVersion = 0,
+                 char**                supportedBrands = NULL,
+                 uint32_t              supportedBrandsCount = 0 );
+
+    bool Modify( const char*           fileName,
+                 const MP4IOCallbacks* callbacks,
+                 void*                 handle );
+
     void Optimize( const char* srcFileName, const char* dstFileName = NULL );
     bool CopyClose( const string& copyFileName );
     void Dump( bool dumpImplicits = false );
@@ -96,12 +105,14 @@ public:
 
     uint64_t GetIntegerProperty(const char* name);
     float GetFloatProperty(const char* name);
+    double GetDoubleProperty(const char* name);
     const char* GetStringProperty(const char* name);
     void GetBytesProperty(const char* name,
                           uint8_t** ppValue, uint32_t* pValueSize);
 
     void SetIntegerProperty(const char* name, uint64_t value);
     void SetFloatProperty(const char* name, float value);
+    void SetDoubleProperty(const char* name, double value);
     void SetStringProperty(const char* name, const char* value);
     void SetBytesProperty(const char* name,
                           const uint8_t* pValue, uint32_t valueSize);
@@ -152,6 +163,8 @@ public:
         MP4TrackId trackId, const char* name);
     float GetTrackFloatProperty(
         MP4TrackId trackId, const char* name);
+    double GetTrackDoubleProperty(
+        MP4TrackId trackId, const char* name);
     const char* GetTrackStringProperty(
         MP4TrackId trackId, const char* name);
     void GetTrackBytesProperty(
@@ -162,6 +175,8 @@ public:
         MP4TrackId trackId, const char* name, int64_t value);
     void SetTrackFloatProperty(
         MP4TrackId trackId, const char* name, float value);
+    void SetTrackDoubleProperty(
+        MP4TrackId trackId, const char* name, double value);
     void SetTrackStringProperty(
         MP4TrackId trackId, const char* name, const char* value);
     void SetTrackBytesProperty(
@@ -769,32 +784,40 @@ public:
     void ReadBytes( uint8_t* buf, uint32_t bufsiz, File* file = NULL );
     void PeekBytes( uint8_t* buf, uint32_t bufsiz, File* file = NULL );
 
-    uint64_t ReadUInt(uint8_t size);
     uint8_t ReadUInt8();
     uint16_t ReadUInt16();
     uint32_t ReadUInt24();
     uint32_t ReadUInt32();
     uint64_t ReadUInt64();
+
+    template<class type, int size> type ReadUInt();
+
     float ReadFixed16();
     float ReadFixed32();
     float ReadFloat();
+    double ReadDouble();
     char* ReadString();
-    char* ReadCountedString(
-        uint8_t charSize = 1, bool allowExpandedCount = false, uint8_t fixedLength = 0);
+    char* ReadCountedString(uint8_t charSize = 1,
+                            bool allowExpandedCount = false,
+                            uint8_t fixedLength = 0);
     uint64_t ReadBits(uint8_t numBits);
     void FlushReadBits();
     uint32_t ReadMpegLength();
 
-
     void WriteBytes( uint8_t* buf, uint32_t bufsiz, File* file = NULL );
+
     void WriteUInt8(uint8_t value);
     void WriteUInt16(uint16_t value);
     void WriteUInt24(uint32_t value);
     void WriteUInt32(uint32_t value);
     void WriteUInt64(uint64_t value);
+
+    template<class type, int size> void WriteUInt(type value);
+
     void WriteFixed16(float value);
     void WriteFixed32(float value);
     void WriteFloat(float value);
+    void WriteDouble(double value);
     void WriteString(char* string);
     void WriteCountedString(char* string,
                             uint8_t charSize = 1,
@@ -846,7 +869,13 @@ public:
 
 protected:
     void Init();
-    void Open( const char* name, File::Mode mode, const MP4FileProvider* provider );
+
+    void Open( const char*            fileName,
+               File::Mode             mode,
+               const MP4FileProvider* provider = NULL,
+               const MP4IOCallbacks*  callbacks = NULL,
+               void*                  handle = NULL );
+
     void ReadFromFile();
     void GenerateTracks();
     void BeginWrite();
@@ -857,12 +886,12 @@ protected:
 
     void Rename(const char* existingFileName, const char* newFileName);
 
-    void ProtectWriteOperation(const char* file, int line, const char *func);
-
     void FindIntegerProperty(const char* name,
                              MP4Property** ppProperty, uint32_t* pIndex = NULL);
     void FindFloatProperty(const char* name,
                            MP4Property** ppProperty, uint32_t* pIndex = NULL);
+    void FindDoubleProperty(const char* name,
+                            MP4Property** ppProperty, uint32_t* pIndex = NULL);
     void FindStringProperty(const char* name,
                             MP4Property** ppProperty, uint32_t* pIndex = NULL);
     void FindBytesProperty(const char* name,
@@ -976,13 +1005,27 @@ protected:
     uint8_t m_bufWriteBits;
 
     char m_trakName[1024];
-    char *m_editName;
+    char m_editName[1024];
 
  private:
     MP4File ( const MP4File &src );
     MP4File &operator= ( const MP4File &src );
+
+    void MoveMoovAtomToFront();
 };
 
+template<> inline uint8_t MP4File::ReadUInt<uint8_t, 8> () { return ReadUInt8(); }
+template<> inline uint16_t MP4File::ReadUInt<uint16_t, 16> () { return ReadUInt16(); }
+template<> inline uint32_t MP4File::ReadUInt<uint32_t, 24> () { return ReadUInt24(); }
+template<> inline uint32_t MP4File::ReadUInt<uint32_t, 32> () { return ReadUInt32(); }
+template<> inline uint64_t MP4File::ReadUInt<uint64_t, 64> () { return ReadUInt64(); }
+
+template<> inline void MP4File::WriteUInt<uint8_t, 8> (uint8_t value) { WriteUInt8(value); }
+template<> inline void MP4File::WriteUInt<uint16_t, 16> (uint16_t value) { WriteUInt16(value); }
+template<> inline void MP4File::WriteUInt<uint32_t, 24> (uint32_t value) { WriteUInt24(value); }
+template<> inline void MP4File::WriteUInt<uint32_t, 32> (uint32_t value) { WriteUInt32(value); }
+template<> inline void MP4File::WriteUInt<uint64_t, 64> (uint64_t value) { WriteUInt64(value); }
+
 ///////////////////////////////////////////////////////////////////////////////
 
 }} // namespace mp4v2::impl
diff --git a/mp4v2/src/mp4file_io.cpp b/mp4v2/src/mp4file_io.cpp
index d16d87f..8216f9b 100644
--- a/mp4v2/src/mp4file_io.cpp
+++ b/mp4v2/src/mp4file_io.cpp
@@ -44,7 +44,7 @@ void MP4File::SetPosition( uint64_t pos, File* file )
 {
     if( m_memoryBuffer ) {
         if( pos >= m_memoryBufferSize )
-            throw new Exception( "position out of range", __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION("position out of range");
         m_memoryBufferPosition = pos;
         return;
     }
@@ -54,7 +54,7 @@ void MP4File::SetPosition( uint64_t pos, File* file )
 
     ASSERT( file );
     if( file->seek( pos ))
-        throw new PlatformException( "seek failed", sys::getLastError(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new PLATFORM_EXCEPTION("seek failed", sys::getLastError());
 }
 
 uint64_t MP4File::GetSize( File* file )
@@ -75,11 +75,13 @@ void MP4File::ReadBytes( uint8_t* buf, uint32_t bufsiz, File* file )
         return;
 
     ASSERT( buf );
-    WARNING( m_numReadBits > 0 );
+    if ( m_numReadBits > 0 ) {
+        WARNING( m_numReadBits > 0 );
+    }
 
     if( m_memoryBuffer ) {
         if( m_memoryBufferPosition + bufsiz > m_memoryBufferSize )
-            throw new Exception( "not enough bytes, reached end-of-memory", __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION("not enough bytes, reached end-of-memory");
         memcpy( buf, &m_memoryBuffer[m_memoryBufferPosition], bufsiz );
         m_memoryBufferPosition += bufsiz;
         return;
@@ -91,9 +93,9 @@ void MP4File::ReadBytes( uint8_t* buf, uint32_t bufsiz, File* file )
     ASSERT( file );
     File::Size nin;
     if( file->read( buf, bufsiz, nin ))
-        throw new PlatformException( "read failed", sys::getLastError(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new PLATFORM_EXCEPTION("read failed", sys::getLastError());
     if( nin != bufsiz )
-        throw new Exception( "not enough bytes, reached end-of-file", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("not enough bytes, reached end-of-file");
 }
 
 void MP4File::PeekBytes( uint8_t* buf, uint32_t bufsiz, File* file )
@@ -160,28 +162,9 @@ void MP4File::WriteBytes( uint8_t* buf, uint32_t bufsiz, File* file )
     ASSERT( file );
     File::Size nout;
     if( file->write( buf, bufsiz, nout ))
-        throw new PlatformException( "write failed", sys::getLastError(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new PLATFORM_EXCEPTION("write failed", sys::getLastError());
     if( nout != bufsiz )
-        throw new Exception( "not all bytes written", __FILE__, __LINE__, __FUNCTION__ );
-}
-
-uint64_t MP4File::ReadUInt(uint8_t size)
-{
-    switch (size) {
-    case 1:
-        return ReadUInt8();
-    case 2:
-        return ReadUInt16();
-    case 3:
-        return ReadUInt24();
-    case 4:
-        return ReadUInt32();
-    case 8:
-        return ReadUInt64();
-    default:
-        ASSERT(false);
-        return 0;
-    }
+        throw new EXCEPTION("not all bytes written");
 }
 
 uint8_t MP4File::ReadUInt8()
@@ -283,7 +266,7 @@ void MP4File::WriteFixed16(float value)
     if (value >= 0x100) {
         ostringstream msg;
         msg << value << " out of range";
-        throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__);
+        throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE);
     }
 
     uint8_t iPart = (uint8_t)value;
@@ -306,7 +289,7 @@ void MP4File::WriteFixed32(float value)
     if (value >= 0x10000) {
         ostringstream msg;
         msg << value << " out of range";
-        throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__);
+        throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE);
     }
 
     uint16_t iPart = (uint16_t)value;
@@ -327,6 +310,17 @@ float MP4File::ReadFloat()
     return u.f;
 }
 
+double MP4File::ReadDouble()
+{
+    union {
+        double f;
+        uint64_t i;
+    } u;
+
+    u.i = ReadUInt64();
+    return u.f;
+}
+
 void MP4File::WriteFloat(float value)
 {
     union {
@@ -338,6 +332,17 @@ void MP4File::WriteFloat(float value)
     WriteUInt32(u.i);
 }
 
+void MP4File::WriteDouble(double value)
+{
+    union {
+        double f;
+        uint64_t i;
+    } u;
+
+    u.f = value;
+    WriteUInt64(u.i);
+}
+
 char* MP4File::ReadString()
 {
     uint32_t length = 0;
@@ -380,24 +385,23 @@ char* MP4File::ReadCountedString(uint8_t charSize, bool allowExpandedCount, uint
             charLength += b;
             ix++;
             if (ix > 25)
-                throw new PlatformException("Counted string too long 25 * 255",ERANGE,
-                                            __FILE__, __LINE__, __FUNCTION__);
+                throw new PLATFORM_EXCEPTION("Counted string too long 25 * 255", ERANGE);
         } while (b == 255);
     } else {
         charLength = ReadUInt8();
     }
     
-    if (fixedLength && (charLength > fixedLength - 1)) {
+    if (fixedLength && (charLength >= fixedLength)) {
         /*
          * The counted length of this string is greater than the
-         * maxiumum fixed length, so truncate the string to the
+         * maximum fixed length, so truncate the string to the
          * maximum fixed length amount (take 1 byte away from the
          * fixedlength since we've already sacrificed one byte for
          * reading the counted length, and there has been a bug where
          * a non counted string has been used in the place of a
          * counted string).
          */  
-        WARNING(charLength > fixedLength - 1);
+        WARNING(charLength >= fixedLength);
         charLength = fixedLength - 1U;
     }
 
@@ -450,7 +454,7 @@ void MP4File::WriteCountedString(char* string,
         if (charLength > 255) {
             ostringstream msg;
             msg << "Length is " << charLength;
-            throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__);
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE);
         }
         // Write the count
         WriteUInt8(charLength);
@@ -545,7 +549,7 @@ void MP4File::WriteMpegLength(uint32_t value, bool compact)
     if (value > 0x0FFFFFFF) {
         ostringstream msg;
         msg << "out of range: " << value;
-        throw new PlatformException(msg.str().c_str(), ERANGE, __FILE__, __LINE__, __FUNCTION__ ); 
+        throw new PLATFORM_EXCEPTION(msg.str().c_str(), ERANGE); 
     }
 
     int8_t numBytes;
diff --git a/mp4v2/src/mp4info.cpp b/mp4v2/src/mp4info.cpp
index 676a5be..bee1d83 100644
--- a/mp4v2/src/mp4info.cpp
+++ b/mp4v2/src/mp4info.cpp
@@ -36,21 +36,22 @@ static char* PrintAudioInfo(
     MP4TrackId trackId)
 {
     static const char* mpeg4AudioNames[] = {
-        "MPEG-4 AAC main",
+        "MPEG-4 AAC Main",
         "MPEG-4 AAC LC",
         "MPEG-4 AAC SSR",
         "MPEG-4 AAC LTP",
-        "MPEG-4 AAC HE",
+        "MPEG-4 SBR",
         "MPEG-4 AAC Scalable",
         "MPEG-4 TwinVQ",
         "MPEG-4 CELP",
         "MPEG-4 HVXC",
-        NULL, NULL,
+        NULL,
+        NULL,
         "MPEG-4 TTSI",
         "MPEG-4 Main Synthetic",
-        "MPEG-4 Wavetable Syn",
+        "MPEG-4 Wavetable Synth",
         "MPEG-4 General MIDI",
-        "MPEG-4 Algo Syn and Audio FX",
+        "MPEG-4 Algo Synth and Audio FX",
         "MPEG-4 ER AAC LC",
         NULL,
         "MPEG-4 ER AAC LTP",
@@ -73,6 +74,12 @@ static char* PrintAudioInfo(
         "MPEG-4 Audio Lossless",
         "MPEG-4 SLS",
         "MPEG-4 SLS non-core",
+        "MPEG-4 ER AAC ELD",
+        "MPEG-4 SMR Simple",
+        "MPEG-4 SMR Main",
+        "MPEG-4 USAC",
+        "MPEG-4 SAOC",
+        "MPEG-4 MPEG Surround LD",
     };
 
     static const uint8_t mpegAudioTypes[] = {
@@ -376,7 +383,7 @@ static char* PrintVideoInfo(
                 snprintf(levelb, 20, "unknown level %x", level);
                 break;
             }
-            if (originalFormat != NULL && originalFormat[0] != '\0')
+            if (originalFormat[0] != 0)
                 snprintf(oformatbuffer, 32, "(%s) ", originalFormat);
             snprintf(typebuffer, sizeof(typebuffer), "H264 %s%s@%s",
                      oformatbuffer, profileb, levelb);
@@ -530,21 +537,21 @@ static char* PrintTrackInfo(
         MP4GetTrackType(mp4File, trackId);
     if (trackType == NULL) return NULL;
 
-    if (!strcmp(trackType, MP4_AUDIO_TRACK_TYPE)) {
+    if (strequal(trackType, MP4_AUDIO_TRACK_TYPE)) {
         trackInfo = PrintAudioInfo(mp4File, trackId);
-    } else if (!strcmp(trackType, MP4_VIDEO_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_VIDEO_TRACK_TYPE)) {
         trackInfo = PrintVideoInfo(mp4File, trackId);
-    } else if (!strcmp(trackType, MP4_HINT_TRACK_TYPE)) {
+    } else if (strequal(trackType, MP4_HINT_TRACK_TYPE)) {
         trackInfo = PrintHintInfo(mp4File, trackId);
-    } else if (strcmp(trackType, MP4_CNTL_TRACK_TYPE) == 0) {
+    } else if (strequal(trackType, MP4_CNTL_TRACK_TYPE)) {
         trackInfo = PrintCntlInfo(mp4File, trackId);
     } else {
         trackInfo = (char*)MP4Malloc(256);
-        if (!strcmp(trackType, MP4_OD_TRACK_TYPE)) {
+        if (strequal(trackType, MP4_OD_TRACK_TYPE)) {
             snprintf(trackInfo, 256,
                      "%u\tod\tObject Descriptors\n",
                      trackId);
-        } else if (!strcmp(trackType, MP4_SCENE_TRACK_TYPE)) {
+        } else if (strequal(trackType, MP4_SCENE_TRACK_TYPE)) {
             snprintf(trackInfo, 256,
                      "%u\tscene\tBIFS\n",
                      trackId);
diff --git a/mp4v2/src/mp4property.cpp b/mp4v2/src/mp4property.cpp
index a0767b0..0605c40 100644
--- a/mp4v2/src/mp4property.cpp
+++ b/mp4v2/src/mp4property.cpp
@@ -156,73 +156,83 @@ void MP4IntegerProperty::IncrementValue(int32_t increment, uint32_t index)
     SetValue(GetValue() + increment);
 }
 
-void MP4Integer8Property::Dump(uint8_t indent,
-                               bool dumpImplicits, uint32_t index)
+template<> void MP4Integer8Property::Dump(uint8_t indent,
+                                          bool dumpImplicits, uint32_t index)
 {
     if (m_implicit && !dumpImplicits) {
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %u (0x%02x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %u (0x%02x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %u (0x%02x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %u (0x%02x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], m_values[index]);
 }
 
-void MP4Integer16Property::Dump(uint8_t indent,
-                                bool dumpImplicits, uint32_t index)
+template<> void MP4Integer16Property::Dump(uint8_t indent,
+                                           bool dumpImplicits, uint32_t index)
 {
     if (m_implicit && !dumpImplicits) {
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %u (0x%04x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %u (0x%04x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %u (0x%04x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %u (0x%04x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], m_values[index]);
 }
 
-void MP4Integer24Property::Dump(uint8_t indent,
-                                bool dumpImplicits, uint32_t index)
+template<> void MP4Integer24Property::Dump(uint8_t indent,
+                                           bool dumpImplicits, uint32_t index)
 {
     if (m_implicit && !dumpImplicits) {
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %u (0x%06x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %u (0x%06x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %u (0x%06x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %u (0x%06x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], m_values[index]);
 }
 
-void MP4Integer32Property::Dump(uint8_t indent,
-                                bool dumpImplicits, uint32_t index)
+template<> void MP4Integer32Property::Dump(uint8_t indent,
+                                           bool dumpImplicits, uint32_t index)
 {
     if (m_implicit && !dumpImplicits) {
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %u (0x%08x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %u (0x%08x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %u (0x%08x)",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %u (0x%08x)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], m_values[index]);
 }
 
-void MP4Integer64Property::Dump(uint8_t indent,
-                                bool dumpImplicits, uint32_t index)
+template<> void MP4Integer64Property::Dump(uint8_t indent,
+                                           bool dumpImplicits, uint32_t index)
 {
     if (m_implicit && !dumpImplicits) {
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %" PRIu64 " (0x%016" PRIx64 ")",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %" PRIu64 " (0x%016" PRIx64 ")",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %" PRIu64 " (0x%016" PRIx64 ")",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %" PRIu64 " (0x%016" PRIx64 ")",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], m_values[index]);
 }
 
@@ -256,11 +266,13 @@ void MP4BitfieldProperty::Dump(uint8_t indent,
     }
     if (index != 0)
         log.dump(indent, MP4_LOG_VERBOSE1,
-                 "%s[%u] = %" PRIu64 " (0x%0*" PRIx64 ") <%u bits>",
+                 "\"%s\": %s[%u] = %" PRIu64 " (0x%0*" PRIx64 ") <%u bits>",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index], (int)hexWidth, m_values[index], m_numBits);
     else
         log.dump(indent, MP4_LOG_VERBOSE1,
-                 "%s = %" PRIu64 " (0x%0*" PRIx64 ") <%u bits>",
+                 "\"%s\": %s = %" PRIu64 " (0x%0*" PRIx64 ") <%u bits>",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index], (int)hexWidth, m_values[index], m_numBits);
 }
 
@@ -301,10 +313,48 @@ void MP4Float32Property::Dump(uint8_t indent,
         return;
     }
     if (index != 0)
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u] = %f",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %f",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
+                 m_name, index, m_values[index]);
+    else
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %f",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
+                 m_name, m_values[index]);
+}
+
+// MP4Float64Property
+
+void MP4Float64Property::Read(MP4File& file, uint32_t index)
+{
+    if (m_implicit) {
+        return;
+    }
+
+    m_values[index] = file.ReadDouble();
+}
+
+void MP4Float64Property::Write(MP4File& file, uint32_t index)
+{
+    if (m_implicit) {
+        return;
+    }
+
+    file.WriteDouble(m_values[index]);
+}
+
+void MP4Float64Property::Dump(uint8_t indent,
+                              bool dumpImplicits, uint32_t index)
+{
+    if (m_implicit && !dumpImplicits) {
+        return;
+    }
+    if (index != 0)
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u] = %f",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, index, m_values[index]);
     else
-        log.dump(indent, MP4_LOG_VERBOSE1, "%s = %f",
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %f",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, m_values[index]);
 }
 
@@ -352,7 +402,7 @@ void MP4StringProperty::SetValue(const char* value, uint32_t index)
     if (m_readOnly) {
         ostringstream msg;
         msg << "property " << m_name << "is read-only";
-        throw new PlatformException(msg.str().c_str(), EACCES, __FILE__, __LINE__, __FUNCTION__ );
+        throw new PLATFORM_EXCEPTION(msg.str().c_str(), EACCES);
     }
 
     MP4Free(m_values[index]);
@@ -388,8 +438,10 @@ void MP4StringProperty::Read( MP4File& file, uint32_t index )
         char*& value = m_values[i];
 
         // Generally a default atom setting, e.g. see atom_avc1.cpp, "JVT/AVC Coding"; we'll leak this string if
-        // we don't free.  Note that MP4Free checks for null.
-        MP4Free(value); 
+        // we don't free.  Note that this code checks for null before calling free and sets the pointer to null
+        // after freeing it, to prevent a double free in case an exception occurs before the value is reassigned.
+        MP4Free( value );
+        value = NULL;
 
         if( m_useCountedFormat ) {
             value = file.ReadCountedString( (m_useUnicode ? 2 : 1), m_useExpandedCount, m_fixedLength );
@@ -445,32 +497,38 @@ void MP4StringProperty::Dump( uint8_t indent, bool dumpImplicits, uint32_t index
             indexd[0] = '\0';
 
         if( m_useUnicode )
-            log.dump(indent, MP4_LOG_VERBOSE1, "%s%s = %ls",
+            log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s%s = %ls",
+                     m_parentAtom.GetFile().GetFilename().c_str(),
                      m_name, indexd, (wchar_t*)m_values[index] );
         else
-            log.dump(indent, MP4_LOG_VERBOSE1, "%s%s = %s",
+            log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s%s = %s",
+                     m_parentAtom.GetFile().GetFilename().c_str(),
                      m_name, indexd, m_values[index] );
     }
     else if( log.verbosity >= MP4_LOG_VERBOSE2 )
     {
         const uint32_t max = GetCount();
 
-        log.dump(indent, MP4_LOG_VERBOSE2, "%s (size=%u)",
+        log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s (size=%u)",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, max );
 
         for( uint32_t i = 0; i < max; i++ ) {
             char*& value = m_values[i];
 
             if( m_useUnicode )
-                log.dump(indent, MP4_LOG_VERBOSE2, "%s[%u] = %ls",
+                log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s[%u] = %ls",
+                         m_parentAtom.GetFile().GetFilename().c_str(),
                          m_name, i, (wchar_t*)value );
             else
-                log.dump(indent, MP4_LOG_VERBOSE2, "%s[%u] = %s",
+                log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s[%u] = %s",
+                         m_parentAtom.GetFile().GetFilename().c_str(),
                          m_name, i, value );
         }
     }
     else {
-        log.dump(indent, MP4_LOG_VERBOSE1, "<table entries suppressed>" );
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": <table entries suppressed>",
+                 m_parentAtom.GetFile().GetFilename().c_str() );
     }
 }
 
@@ -514,13 +572,13 @@ void MP4BytesProperty::SetValue(const uint8_t* pValue, uint32_t valueSize,
     if (m_readOnly) {
         ostringstream msg;
         msg << "property " << m_name << "is read-only";
-        throw new PlatformException(msg.str().c_str(), EACCES, __FILE__, __LINE__, __FUNCTION__ );
+        throw new PLATFORM_EXCEPTION(msg.str().c_str(), EACCES);
     }
     if (m_fixedValueSize) {
         if (valueSize > m_fixedValueSize) {
             ostringstream msg;
             msg << GetParentAtom().GetType() << "." << GetName() << " value size " << valueSize << " exceeds fixed value size " << m_fixedValueSize;
-            throw new Exception(msg.str().c_str(), __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION(msg.str().c_str());
         }
         if (m_values[index] == NULL) {
             m_values[index] = (uint8_t*)MP4Calloc(m_fixedValueSize);
@@ -545,8 +603,7 @@ void MP4BytesProperty::SetValue(const uint8_t* pValue, uint32_t valueSize,
 void MP4BytesProperty::SetValueSize(uint32_t valueSize, uint32_t index)
 {
     if (m_fixedValueSize) {
-        throw new Exception("can't change size of fixed sized property",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("can't change size of fixed sized property");
     }
     if (m_values[index] != NULL) {
         m_values[index] = (uint8_t*)MP4Realloc(m_values[index], valueSize);
@@ -591,7 +648,8 @@ void MP4BytesProperty::Dump(uint8_t indent,
     const uint8_t* const value = m_values[index];
 
     if( size == 0 ) {
-        log.dump(indent, MP4_LOG_VERBOSE2, "%s = <%u bytes>",
+        log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s = <%u bytes>",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, size );
         return;
     }
@@ -610,7 +668,8 @@ void MP4BytesProperty::Dump(uint8_t indent,
 
         oss << "  |" << text.str() << "|";
 
-        log.dump(indent, MP4_LOG_VERBOSE2, "%s = <%u bytes>%s",
+        log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s = <%u bytes>%s",
+                 m_parentAtom.GetFile().GetFilename().c_str(),
                  m_name, size, oss.str().c_str() );
         return;
     }
@@ -640,16 +699,16 @@ void MP4BytesProperty::Dump(uint8_t indent,
         supressed = true;
     }
 
-    ostringstream oss;
-    ostringstream text;
-
-    log.dump(indent, MP4_LOG_VERBOSE2, "%s = <%u bytes>",
+    log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s = <%u bytes>",
+             m_parentAtom.GetFile().GetFilename().c_str(),
              m_name, size );
-    log.hexDump(indent, MP4_LOG_VERBOSE2, value, adjsize, "%s",
+    log.hexDump(indent, MP4_LOG_VERBOSE2, value, adjsize, "\"%s\": %s",
+                m_parentAtom.GetFile().GetFilename().c_str(),
                 m_name);
 
     if( supressed ) {
-        log.dump(indent, MP4_LOG_VERBOSE1, "<remaining bytes supressed>" );
+        log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": <remaining bytes supressed>",
+                 m_parentAtom.GetFile().GetFilename().c_str() );
     }
 }
 
@@ -882,7 +941,7 @@ bool MP4DescriptorProperty::FindProperty(const char *name,
         MP4Property** ppProperty, uint32_t* pIndex)
 {
     // we're unnamed, so just check contained properties
-    if (m_name == NULL || !strcmp(m_name, "")) {
+    if (m_name == NULL || strequal(m_name, "")) {
         return FindContainedProperty(name, ppProperty, pIndex);
     }
 
@@ -959,7 +1018,7 @@ void MP4DescriptorProperty::Read(MP4File& file, uint32_t index)
                 delete x;
                 break;
             }
-            throw x;
+            throw;
         }
 
         // check if tag is in desired range
@@ -1007,10 +1066,12 @@ void MP4DescriptorProperty::Dump(uint8_t indent,
 
     if (m_name) {
         if (index != 0)
-            log.dump(indent, MP4_LOG_VERBOSE1, "%s[%u]",
+            log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s[%u]",
+                     m_parentAtom.GetFile().GetFilename().c_str(),
                      m_name, index);
         else
-            log.dump(indent, MP4_LOG_VERBOSE1, "%s",
+            log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s",
+                     m_parentAtom.GetFile().GetFilename().c_str(),
                      m_name);
         indent++;
     }
@@ -1047,7 +1108,8 @@ MP4LanguageCodeProperty::Dump( uint8_t indent, bool dumpImplicits, uint32_t inde
              | (((svalue[2] - 0x60) & 0x001f)      );
     }
 
-    log.dump(indent, MP4_LOG_VERBOSE2, "%s = %s (0x%04x)",
+    log.dump(indent, MP4_LOG_VERBOSE2, "\"%s\": %s = %s (0x%04x)",
+             m_parentAtom.GetFile().GetFilename().c_str(),
              m_name, bmff::enumLanguageCode.toString( _value, true ).c_str(), data );
 }
 
@@ -1121,7 +1183,8 @@ MP4BasicTypeProperty::MP4BasicTypeProperty( MP4Atom& parentAtom, const char* nam
 void
 MP4BasicTypeProperty::Dump( uint8_t indent, bool dumpImplicits, uint32_t index )
 {
-    log.dump(indent, MP4_LOG_VERBOSE1, "%s = %s (0x%02x)", m_name,
+    log.dump(indent, MP4_LOG_VERBOSE1, "\"%s\": %s = %s (0x%02x)",
+             m_parentAtom.GetFile().GetFilename().c_str(), m_name,
              itmf::enumBasicType.toString( _value, true ).c_str(), _value );
 }
 
diff --git a/mp4v2/src/mp4property.h b/mp4v2/src/mp4property.h
index da57fd0..a09fa5f 100644
--- a/mp4v2/src/mp4property.h
+++ b/mp4v2/src/mp4property.h
@@ -30,7 +30,7 @@ namespace mp4v2 { namespace impl {
 class MP4Atom;
 
 class MP4Descriptor;
-MP4ARRAY_DECL(MP4Descriptor, MP4Descriptor*);
+typedef MP4Array<MP4Descriptor*> MP4DescriptorArray;
 
 enum MP4PropertyType {
     Integer8Property,
@@ -40,12 +40,13 @@ enum MP4PropertyType {
     Integer64Property,
     Integer6432Property,
     Float32Property,
+    Float64Property,
     StringProperty,
     BytesProperty,
     TableProperty,
     DescriptorProperty,
     LanguageCodeProperty,
-    BasicTypeProperty,
+    BasicTypeProperty
 };
 
 class MP4Property {
@@ -105,7 +106,7 @@ private:
     MP4Property &operator= ( const MP4Property &src );
 };
 
-MP4ARRAY_DECL(MP4Property, MP4Property*);
+typedef MP4Array<MP4Property*> MP4PropertyArray;
 
 class MP4IntegerProperty : public MP4Property {
 protected:
@@ -129,82 +130,93 @@ private:
     MP4IntegerProperty &operator= ( const MP4IntegerProperty &src );
 };
 
-#define MP4INTEGER_PROPERTY_DECL2(isize, xsize) \
-    class MP4Integer##xsize##Property : public MP4IntegerProperty { \
-    public: \
-        MP4Integer##xsize##Property(MP4Atom& parentAtom, const char* name) \
-            : MP4IntegerProperty(parentAtom, name) { \
-            SetCount(1); \
-            m_values[0] = 0; \
-        } \
-        \
-        MP4PropertyType GetType() { \
-            return Integer##xsize##Property; \
-        } \
-        \
-        uint32_t GetCount() { \
-            return m_values.Size(); \
-        } \
-        void SetCount(uint32_t count) { \
-            m_values.Resize(count); \
-        } \
-        \
-        uint##isize##_t GetValue(uint32_t index = 0) { \
-            return m_values[index]; \
-        } \
-        \
-        void SetValue(uint##isize##_t value, uint32_t index = 0) { \
-            if (m_readOnly) { \
-                ostringstream msg; \
-                msg << "property is read-only: " << m_name; \
-                throw new PlatformException(msg.str().c_str(), EACCES, __FILE__, __LINE__, __FUNCTION__); \
-            } \
-            m_values[index] = value; \
-        } \
-        void AddValue(uint##isize##_t value) { \
-            m_values.Add(value); \
-        } \
-        void InsertValue(uint##isize##_t value, uint32_t index) { \
-            m_values.Insert(value, index); \
-        } \
-        void DeleteValue(uint32_t index) { \
-            m_values.Delete(index); \
-        } \
-        void IncrementValue(int32_t increment = 1, uint32_t index = 0) { \
-            m_values[index] += increment; \
-        } \
-        void Read(MP4File& file, uint32_t index = 0) { \
-            if (m_implicit) { \
-                return; \
-            } \
-            m_values[index] = file.ReadUInt##xsize(); \
-        } \
-        \
-        void Write(MP4File& file, uint32_t index = 0) { \
-            if (m_implicit) { \
-                return; \
-            } \
-            file.WriteUInt##xsize(m_values[index]); \
-        } \
-        void Dump(uint8_t indent, \
-            bool dumpImplicits, uint32_t index = 0); \
-    \
-    protected: \
-        MP4Integer##isize##Array m_values; \
-    private: \
-        MP4Integer##xsize##Property(); \
-        MP4Integer##xsize##Property ( const MP4Integer##xsize##Property &src ); \
-        MP4Integer##xsize##Property &operator= ( const MP4Integer##xsize##Property &src ); \
-    };
-
-#define MP4INTEGER_PROPERTY_DECL(size) \
-    MP4INTEGER_PROPERTY_DECL2(size, size)
-
-MP4INTEGER_PROPERTY_DECL(8);
-MP4INTEGER_PROPERTY_DECL(16);
-MP4INTEGER_PROPERTY_DECL2(32, 24);
-MP4INTEGER_PROPERTY_DECL(32);
-MP4INTEGER_PROPERTY_DECL(64);
+template <class type, int size> class MP4SizedIntegerProperty : public MP4IntegerProperty {
+public:
+    MP4SizedIntegerProperty(MP4Atom& parentAtom, const char* name)
+        : MP4IntegerProperty(parentAtom, name) {
+        SetCount(1);
+        m_values[0] = 0;
+    }
+
+    MP4PropertyType GetType() {
+        switch (size) {
+            case 8: return Integer8Property;
+            case 16: return Integer16Property;
+            case 24: return Integer24Property;
+            case 32: return Integer32Property;
+            case 64: return Integer64Property;
+        }
+        return Integer32Property;
+    }
+
+    uint32_t GetCount() {
+        return m_values.Size();
+    }
+
+    void SetCount(uint32_t count) {
+        m_values.Resize(count);
+    }
+
+    type GetValue(uint32_t index = 0) {
+        return m_values[index];
+    }
+
+    void SetValue(type value, uint32_t index = 0) {
+        if (m_readOnly) { 
+            ostringstream msg;
+            msg << "property is read-only: " << m_name;
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), EACCES);
+        }
+        m_values[index] = value;
+    }
+
+    void AddValue(type value) {
+        m_values.Add(value);
+    }
+
+    void InsertValue(type value, uint32_t index) {
+        m_values.Insert(value, index);
+    }
+
+    void DeleteValue(uint32_t index) {
+        m_values.Delete(index);
+    }
+
+    void IncrementValue(int32_t increment = 1, uint32_t index = 0) {
+        m_values[index] += increment;
+    }
+
+    void Read(MP4File& file, uint32_t index = 0) {
+        if (m_implicit) {
+            return;
+        }
+        m_values[index] = file.ReadUInt<type, size>();
+    }
+
+    void Write(MP4File& file, uint32_t index = 0) {
+        if (m_implicit) {
+            return;
+        }
+        file.WriteUInt<type, size>(m_values[index]);
+    }
+
+    void Dump(uint8_t indent,
+        bool dumpImplicits, uint32_t index = 0);
+
+protected:
+    MP4Array<type> m_values;
+
+private:
+    MP4SizedIntegerProperty();
+    MP4SizedIntegerProperty ( const MP4SizedIntegerProperty &src );
+    MP4SizedIntegerProperty &operator= ( const MP4SizedIntegerProperty &src );
+};
+
+typedef MP4SizedIntegerProperty<uint8_t, 8> MP4Integer8Property;
+typedef MP4SizedIntegerProperty<uint16_t, 16> MP4Integer16Property;
+typedef MP4SizedIntegerProperty<uint32_t, 24> MP4Integer24Property;
+typedef MP4SizedIntegerProperty<uint32_t, 32> MP4Integer32Property;
+typedef MP4SizedIntegerProperty<uint64_t, 64> MP4Integer64Property;
 
 class MP4Integer6432Property: public MP4Integer64Property {
 public:
@@ -300,7 +312,7 @@ public:
         if (m_readOnly) {
             ostringstream msg;
             msg << "property is read-only: " << m_name;
-            throw new PlatformException(msg.str().c_str(), EACCES, __FILE__, __LINE__, __FUNCTION__);
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), EACCES);
         }
         m_values[index] = value;
     }
@@ -345,6 +357,60 @@ private:
     MP4Float32Property &operator= ( const MP4Float32Property &src );
 };
 
+class MP4Float64Property : public MP4Property {
+public:
+    MP4Float64Property(MP4Atom& parentAtom, const char* name)
+            : MP4Property(parentAtom, name) {
+        SetCount(1);
+        m_values[0] = 0.0;
+    }
+
+    MP4PropertyType GetType() {
+        return Float64Property;
+    }
+
+    uint32_t GetCount() {
+        return m_values.Size();
+    }
+    void SetCount(uint32_t count) {
+        m_values.Resize(count);
+    }
+
+    double GetValue(uint32_t index = 0) {
+        return m_values[index];
+    }
+
+    void SetValue(double value, uint32_t index = 0) {
+        if (m_readOnly) {
+            ostringstream msg;
+            msg << "property is read-only: " << m_name;
+            throw new PLATFORM_EXCEPTION(msg.str().c_str(), EACCES);
+        }
+        m_values[index] = value;
+    }
+
+    void AddValue(double value) {
+        m_values.Add(value);
+    }
+
+    void InsertValue(double value, uint32_t index) {
+        m_values.Insert(value, index);
+    }
+
+    void Read(MP4File& file, uint32_t index = 0);
+    void Write(MP4File& file, uint32_t index = 0);
+    void Dump(uint8_t indent,
+              bool dumpImplicits, uint32_t index = 0);
+
+protected:
+    MP4Float64Array m_values;
+
+private:
+    MP4Float64Property();
+    MP4Float64Property ( const MP4Float64Property &src );
+    MP4Float64Property &operator= ( const MP4Float64Property &src );
+};
+
 class MP4StringProperty : public MP4Property {
 public:
     MP4StringProperty(MP4Atom& parentAtom, const char* name,
diff --git a/mp4v2/src/mp4track.cpp b/mp4v2/src/mp4track.cpp
index 8055449..ceafe24 100644
--- a/mp4v2/src/mp4track.cpp
+++ b/mp4v2/src/mp4track.cpp
@@ -232,7 +232,7 @@ MP4Track::MP4Track(MP4File& file, MP4Atom& trakAtom)
 
     // was everything found?
     if (!success) {
-        throw new Exception("invalid track", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid track");
     }
     CalculateBytesPerSample();
 
@@ -277,7 +277,7 @@ void MP4Track::ReadSample(
     uint32_t*     dependencyFlags )
 {
     if( sampleId == MP4_INVALID_SAMPLE_ID )
-        throw new Exception( "sample id can't be zero", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("sample id can't be zero");
 
     if( hasDependencyFlags )
         *hasDependencyFlags = !m_sdtpLog.empty();
@@ -288,7 +288,7 @@ void MP4Track::ReadSample(
         }
         else {
             if( sampleId > m_sdtpLog.size() )
-                throw new Exception( "sample id > sdtp logsize", __FILE__, __LINE__, __FUNCTION__ );
+                throw new EXCEPTION("sample id > sdtp logsize");
             *dependencyFlags = m_sdtpLog[sampleId-1]; // sampleId is 1-based
         }
     }
@@ -301,14 +301,13 @@ void MP4Track::ReadSample(
 
     File* fin = GetSampleFile( sampleId );
     if( fin == (File*)-1 )
-        throw new Exception( "sample is located in an inaccessible file", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("sample is located in an inaccessible file");
 
     uint64_t fileOffset = GetSampleFileOffset(sampleId);
 
     uint32_t sampleSize = GetSampleSize(sampleId);
     if (*ppBytes != NULL && *pNumBytes < sampleSize) {
-        throw new Exception("sample buffer is too small",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("sample buffer is too small");
     }
     *pNumBytes = sampleSize;
 
@@ -347,7 +346,7 @@ void MP4Track::ReadSample(
         }
     }
 
-    catch (Exception* x) {
+    catch (Exception*) {
         if( bufferMalloc ) {
             MP4Free( *ppBytes );
             *ppBytes = NULL;
@@ -356,7 +355,7 @@ void MP4Track::ReadSample(
         if( m_File.IsWriteMode() )
             m_File.SetPosition( oldPos, fin );
 
-        throw x;
+        throw;
     }
 
     if( m_File.IsWriteMode() )
@@ -370,8 +369,7 @@ void MP4Track::ReadSampleFragment(
     uint8_t* pDest)
 {
     if (sampleId == MP4_INVALID_SAMPLE_ID) {
-        throw new Exception("invalid sample id",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid sample id");
     }
 
     if (sampleId != m_cachedReadSampleId) {
@@ -389,8 +387,7 @@ void MP4Track::ReadSampleFragment(
     }
 
     if (sampleOffset + sampleLength > m_cachedReadSampleSize) {
-        throw new Exception("offset and/or length are too large",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("offset and/or length are too large");
     }
 
     memcpy(pDest, &m_pCachedReadSample[sampleOffset], sampleLength);
@@ -410,7 +407,7 @@ void MP4Track::WriteSample(
                   m_trackId, m_writeSampleId + 1, numBytes, numBytes);
 
     if (pBytes == NULL && numBytes > 0) {
-        throw new Exception("no sample data", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no sample data");
     }
 
     if (m_isAmr == AMR_UNINITIALIZED ) {
@@ -522,6 +519,15 @@ void MP4Track::FinishWrite(uint32_t options)
     // write out any remaining samples in chunk buffer
     WriteChunkBuffer();
 
+    MP4Duration editTotalDuration = GetEditTotalDuration(MP4_INVALID_EDIT_ID);
+    if (editTotalDuration == MP4_INVALID_DURATION) {
+        MP4Duration mediaDuration = m_pMediaDurationProperty->GetValue();
+        m_pTrackDurationProperty->SetValue(ToMovieDuration(mediaDuration));
+    } else {
+        m_pTrackDurationProperty->SetValue(editTotalDuration);
+    }
+    m_File.UpdateDuration(m_pTrackDurationProperty->GetValue());
+
     if (m_pStszFixedSampleSizeProperty == NULL &&
             m_stsz_sample_bits == 4) {
         if (m_have_stz2_4bit_sample) {
@@ -599,7 +605,7 @@ void MP4Track::FinishSdtp()
         bool found = false;
         const uint32_t max = ftyp->compatibleBrands.GetCount();
         for( uint32_t i = 0; i < max; i++ ) {
-            if( !strcmp( ftyp->compatibleBrands.GetValue( i ), "avc1" )) {
+            if( strequal( ftyp->compatibleBrands.GetValue( i ), "avc1" )) {
                 found = true;
                 break;
             }
@@ -863,7 +869,7 @@ uint32_t MP4Track::GetSampleStscIndex(MP4SampleId sampleId)
     uint32_t numStscs = m_pStscCountProperty->GetValue();
 
     if (numStscs == 0) {
-        throw new Exception("No data chunks exist", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("No data chunks exist");
     }
 
     for (stscIndex = 0; stscIndex < numStscs; stscIndex++) {
@@ -900,7 +906,21 @@ File* MP4Track::GetSampleFile( MP4SampleId sampleId )
     if( !pStsdEntryAtom->FindProperty( "*.dataReferenceIndex", (MP4Property**)&pDrefIndexProperty ) ||
         pDrefIndexProperty == NULL )
     {
-        throw new Exception( "invalid stsd entry", __FILE__, __LINE__, __FUNCTION__ );
+        // mp4v2 does not know about Apple-specific atoms in MOV files so may fail to find
+        // the DataReferenceIndex. In that case, we'll handle it the same as the "media data
+        // in local file" case... for our purposes, we don't care about cases where the
+        // media data is outside of the local file.
+        MP4FtypAtom *pFtypAtom = reinterpret_cast<MP4FtypAtom *>( m_File.FindAtom( "ftyp" ) );
+
+        // MOV spec does not require "ftyp" atom...
+        if ( pFtypAtom == NULL )
+            return NULL;
+
+        // ... but most often it is present with a "qt  " value
+        if ( strequal( pFtypAtom->majorBrand.GetValue(), "qt  " ) )
+            return NULL;
+
+        throw new EXCEPTION("invalid stsd entry");
     }
 
     uint32_t drefIndex = pDrefIndexProperty->GetValue();
@@ -914,7 +934,7 @@ File* MP4Track::GetSampleFile( MP4SampleId sampleId )
     File* file;
 
     // make sure this is actually a url atom (somtimes it's "cios", like in iTunes videos)
-    if( strcmp(pUrlAtom->GetType(), "url ") ||
+    if( !strequal(pUrlAtom->GetType(), "url ") ||
         pUrlAtom->GetFlags() & 1 ) {
         file = NULL; // self-contained
     }
@@ -932,10 +952,10 @@ File* MP4Track::GetSampleFile( MP4SampleId sampleId )
 
         // attempt to open url if it's a file url
         // currently this is the only thing we understand
-        if( !strncmp( url, "file:", 5 )) {
+        if( strnequal( url, "file:", 5 )) {
             const char* fileName = url + 5;
 
-            if( !strncmp(fileName, "//", 2 ))
+            if( strnequal(fileName, "//", 2 ))
                 fileName = strchr( fileName + 2, '/' );
 
             if( fileName ) {
@@ -1070,9 +1090,9 @@ void MP4Track::GetSampleTimes(MP4SampleId sampleId,
     }
 
     for (uint32_t sttsIndex = m_cachedSttsIndex; sttsIndex < numStts; sttsIndex++) {
-        uint32_t sampleCount =
+        MP4SampleId sampleCount =
             m_pSttsSampleCountProperty->GetValue(sttsIndex);
-        uint32_t sampleDelta =
+        MP4Duration sampleDelta =
             m_pSttsSampleDeltaProperty->GetValue(sttsIndex);
 
         if (sampleId <= sid + sampleCount - 1) {
@@ -1095,8 +1115,7 @@ void MP4Track::GetSampleTimes(MP4SampleId sampleId,
         elapsed += sampleCount * sampleDelta;
     }
 
-    throw new Exception("sample id out of range",
-                        __FILE__, __LINE__, __FUNCTION__ );
+    throw new EXCEPTION("sample id out of range");
 }
 
 MP4SampleId MP4Track::GetSampleIdFromTime(
@@ -1108,9 +1127,9 @@ MP4SampleId MP4Track::GetSampleIdFromTime(
     MP4Duration elapsed = 0;
 
     for (uint32_t sttsIndex = 0; sttsIndex < numStts; sttsIndex++) {
-        uint32_t sampleCount =
+        MP4SampleId sampleCount =
             m_pSttsSampleCountProperty->GetValue(sttsIndex);
-        uint32_t sampleDelta =
+        MP4Duration sampleDelta =
             m_pSttsSampleDeltaProperty->GetValue(sttsIndex);
 
         if (sampleDelta == 0 && sttsIndex < numStts - 1) {
@@ -1136,8 +1155,7 @@ MP4SampleId MP4Track::GetSampleIdFromTime(
         elapsed += sampleCount * sampleDelta;
     }
 
-    throw new Exception("time out of range",
-                        __FILE__, __LINE__, __FUNCTION__);
+    throw new EXCEPTION("time out of range");
 
     return 0; // satisfy MS compiler
 }
@@ -1174,9 +1192,9 @@ uint32_t MP4Track::GetSampleCttsIndex(MP4SampleId sampleId,
     }
 
     for (uint32_t cttsIndex = m_cachedCttsIndex; cttsIndex < numCtts; cttsIndex++) {
-        uint32_t sampleCount =
+        MP4SampleId sampleCount =
             m_pCttsSampleCountProperty->GetValue(cttsIndex);
-        
+
         if (sampleId <= sid + sampleCount - 1) {
             if (pFirstSampleId) {
                 *pFirstSampleId = sid;
@@ -1190,9 +1208,7 @@ uint32_t MP4Track::GetSampleCttsIndex(MP4SampleId sampleId,
         sid += sampleCount;
     }
 
-    throw new Exception("sample id out of range",
-                        __FILE__, __LINE__, __FUNCTION__ );
-    return 0; // satisfy MS compiler
+    throw new EXCEPTION("sample id out of range");
 }
 
 MP4Duration MP4Track::GetSampleRenderingOffset(MP4SampleId sampleId)
@@ -1298,7 +1314,7 @@ void MP4Track::SetSampleRenderingOffset(MP4SampleId sampleId,
         return;
     }
 
-    uint32_t sampleCount =
+    MP4SampleId sampleCount =
         m_pCttsSampleCountProperty->GetValue(cttsIndex);
 
     // if this sample has it's own ctts entry
@@ -1381,6 +1397,9 @@ bool MP4Track::IsSyncSample(MP4SampleId sampleId)
             return true;
         }
 
+        if (stssLIndex == stssRIndex)
+            break;
+
         if (sampleId > syncSampleId) {
             stssLIndex = stssIndex + 1;
         } else {
@@ -1474,15 +1493,8 @@ uint32_t MP4Track::GetTimeScale()
 
 void MP4Track::UpdateDurations(MP4Duration duration)
 {
-    // update media, track, and movie durations
     m_pMediaDurationProperty->SetValue(
         m_pMediaDurationProperty->GetValue() + duration);
-
-    MP4Duration movieDuration = ToMovieDuration(
-        m_pMediaDurationProperty->GetValue());
-    m_pTrackDurationProperty->SetValue(movieDuration);
-
-    m_File.UpdateDuration(m_pTrackDurationProperty->GetValue());
 }
 
 MP4Duration MP4Track::ToMovieDuration(MP4Duration trackDuration)
@@ -1591,14 +1603,14 @@ void MP4Track::ReadChunk(MP4ChunkId chunkId,
         m_File.SetPosition( chunkOffset );
         m_File.ReadBytes( *ppChunk, *pChunkSize );
     }
-    catch( Exception* x ) {
+    catch( Exception* ) {
         MP4Free( *ppChunk );
         *ppChunk = NULL;
 
         if( m_File.IsWriteMode() )
             m_File.SetPosition( oldPos );
 
-        throw x;
+        throw;
     }
 
     if( m_File.IsWriteMode() )
@@ -1685,14 +1697,12 @@ MP4EditId MP4Track::AddEdit(MP4EditId editId)
 void MP4Track::DeleteEdit(MP4EditId editId)
 {
     if (editId == MP4_INVALID_EDIT_ID) {
-        throw new Exception("edit id can't be zero",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("edit id can't be zero");
     }
 
     if (!m_pElstCountProperty
             || m_pElstCountProperty->GetValue() == 0) {
-        throw new Exception("no edits exist",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no edits exist");
     }
 
     m_pElstMediaTimeProperty->DeleteValue(editId - 1);
@@ -1777,9 +1787,9 @@ MP4SampleId MP4Track::GetSampleIdFromEditTime(
             editElapsedDuration +=
                 m_pElstDurationProperty->GetValue(editId - 1);
 
-            // calculate difference between the specified edit time
-            // and the end of this edit segment
-            if (editElapsedDuration - editWhen <= 0) {
+            // check whether the specified edit
+            // time is within this edit segment
+            if (editWhen >= editElapsedDuration) {
                 // the specified time has not yet been reached
                 continue;
             }
@@ -1860,8 +1870,7 @@ MP4SampleId MP4Track::GetSampleIdFromEditTime(
             return sampleId;
         }
 
-        throw new Exception("time out of range",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("time out of range");
 
     } else { // no edit list
         sampleId = GetSampleIdFromTime(editWhen, false);
diff --git a/mp4v2/src/mp4track.h b/mp4v2/src/mp4track.h
index 2a649f2..b2b662c 100644
--- a/mp4v2/src/mp4track.h
+++ b/mp4v2/src/mp4track.h
@@ -40,12 +40,16 @@ class MP4File;
 class MP4Atom;
 class MP4Property;
 class MP4IntegerProperty;
-class MP4Integer8Property;
-class MP4Integer16Property;
-class MP4Integer32Property;
-class MP4Integer64Property;
 class MP4StringProperty;
 
+template <class, int> class MP4SizedIntegerProperty;
+
+typedef MP4SizedIntegerProperty<uint8_t, 8> MP4Integer8Property;
+typedef MP4SizedIntegerProperty<uint16_t, 16> MP4Integer16Property;
+typedef MP4SizedIntegerProperty<uint32_t, 24> MP4Integer24Property;
+typedef MP4SizedIntegerProperty<uint32_t, 32> MP4Integer32Property;
+typedef MP4SizedIntegerProperty<uint64_t, 64> MP4Integer64Property;
+
 class MP4Track
 {
 public:
@@ -285,7 +289,7 @@ protected:
     string m_sdtpLog; // records frame types for H264 samples
 };
 
-MP4ARRAY_DECL(MP4Track, MP4Track*);
+typedef MP4Array<MP4Track*> MP4TrackArray;
 
 ///////////////////////////////////////////////////////////////////////////////
 
diff --git a/mp4v2/src/mp4util.cpp b/mp4v2/src/mp4util.cpp
index 47bd74e..f21ffe6 100644
--- a/mp4v2/src/mp4util.cpp
+++ b/mp4v2/src/mp4util.cpp
@@ -40,12 +40,18 @@ bool MP4NameFirstMatches(const char* s1, const char* s2)
         if (*s2 == '\0' || strchr("[.", *s2)) {
             break;
         }
-        if (tolower(*s1) != tolower(*s2)) {
+        if (*s1 != *s2) {
             return false;
         }
         s1++;
         s2++;
     }
+
+    // Make sure we finished the loop by using up s2, not s1
+    if ( *s2 != '[' && *s2 != '.' && *s2 != '\0' ) {
+        return false;
+    }
+
     return true;
 }
 
@@ -111,24 +117,24 @@ const char* MP4NameAfterFirst(const char *s)
 
 char* MP4ToBase16(const uint8_t* pData, uint32_t dataSize)
 {
-    if (dataSize) {
-        ASSERT(pData);
-    }
-    uint32_t size = 2 * dataSize + 1;
-    char* s = (char*)MP4Calloc(size);
+    if (pData == NULL && dataSize != 0) return NULL;
+
+    uint32_t size = 2 * dataSize;
+    char* s = (char*)MP4Calloc(size + 1);
 
-    uint32_t i, j;
-    for (i = 0, j = 0; i < dataSize; i++) {
-        size -= snprintf(&s[j], size, "%02x", pData[i]);
-        j += 2;
+    for (uint32_t i = 0; i < dataSize; i++) {
+        if (snprintf(&s[2 * i], size - 2 * i, "%02x", pData[i]) != 2) {
+            MP4Free(s);
+            return NULL;
+        }
     }
 
-    return s;   /* N.B. caller is responsible for free'ing s */
+    return s;   /* N.B. caller is responsible for freeing s */
 }
 
 char* MP4ToBase64(const uint8_t* pData, uint32_t dataSize)
 {
-    if (pData == NULL || dataSize == 0) return NULL;
+    if (pData == NULL && dataSize != 0) return NULL;
 
     static const char encoding[64] = {
         'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P',
@@ -140,7 +146,6 @@ char* MP4ToBase64(const uint8_t* pData, uint32_t dataSize)
     char* s = (char*)MP4Calloc((((dataSize + 2) * 4) / 3) + 1);
 
     const uint8_t* src = pData;
-    if (pData == NULL) return NULL;
     char* dest = s;
     uint32_t numGroups = dataSize / 3;
 
@@ -164,74 +169,7 @@ char* MP4ToBase64(const uint8_t* pData, uint32_t dataSize)
         *dest++ = '=';
     }
     *dest = '\0';
-    return s;   /* N.B. caller is responsible for free'ing s */
-}
-
-static bool convertBase64 (const char data, uint8_t *value)
-{
-    static const uint8_t decodingarr64[128] = {
-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
-        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
-        0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
-        0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
-        0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
-        0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
-        0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
-        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
-        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
-        0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
-    };
-    uint8_t index = (uint8_t)data;
-    if ((index & 0x80) != 0) return false;
-
-    if (decodingarr64[index] == 0xff) return false;
-    *value = decodingarr64[index];
-    return true;
-}
-
-uint8_t *Base64ToBinary (const char *pData, uint32_t decodeSize, uint32_t *pDataSize)
-{
-    uint8_t *ret;
-    uint32_t size, ix, groups;
-    if (pData == NULL ||  decodeSize == 0 || pDataSize == NULL)
-        return NULL;
-
-    if ((decodeSize % 4) != 0) {
-        // must be multiples of 4 characters
-        return NULL;
-    }
-    size = (decodeSize * 3) / 4;
-    groups = decodeSize / 4;
-    ret = (uint8_t *)MP4Calloc(size);
-    if (ret == NULL) return NULL;
-    for (ix = 0; ix < groups; ix++) {
-        uint8_t value[4];
-        for (uint8_t jx = 0; jx < 4; jx++) {
-            if (pData[jx] == '=') {
-                if (ix != (groups - 1)) {
-                    free(ret);
-                    return NULL;
-                }
-                size--;
-                value[jx] = 0;
-            } else if (convertBase64(pData[jx], &value[jx]) == false) {
-                free(ret);
-                return NULL;
-            }
-        }
-        ret[(ix * 3)] = value[0] << 2 | ((value[1] >> 4) & 0x3);
-        ret[(ix * 3) + 1] = (value[1] << 4) | (value[2] >> 2 & 0xf);
-        ret[(ix * 3) + 2] = ((value[2] & 0x3) << 6) | value[3];
-        pData += 4;
-    }
-    *pDataSize = size;
-    return ret;
+    return s;   /* N.B. caller is responsible for freeing s */
 }
 
 // log2 of value, rounded up
@@ -252,7 +190,7 @@ uint64_t MP4ConvertTime(uint64_t t,
 {
     // avoid float point exception
     if (oldTimeScale == 0) {
-        throw new Exception("division by zero", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("division by zero");
     }
 
     if (oldTimeScale == newTimeScale) return t;
@@ -273,7 +211,7 @@ uint64_t MP4ConvertTime(uint64_t t,
 
 const char* MP4NormalizeTrackType (const char* type)
 {
-    if (!strcasecmp(type, "vide")
+    if (!strcasecmp(type, MP4_VIDEO_TRACK_TYPE)
             || !strcasecmp(type, "video")
             || !strcasecmp(type, "mp4v")
             || !strcasecmp(type, "avc1")
@@ -282,30 +220,47 @@ const char* MP4NormalizeTrackType (const char* type)
         return MP4_VIDEO_TRACK_TYPE;
     }
 
-    if (!strcasecmp(type, "soun")
+    if (!strcasecmp(type, MP4_AUDIO_TRACK_TYPE)
             || !strcasecmp(type, "sound")
             || !strcasecmp(type, "audio")
-            || !strcasecmp(type, "enca")
+            || !strcasecmp(type, "mp4a")
+            || !strcasecmp(type, "ipcm")
+            || !strcasecmp(type, "lpcm")
+            || !strcasecmp(type, "alaw")
+            || !strcasecmp(type, "ulaw")
             || !strcasecmp(type, "samr")  // 3GPP AMR
             || !strcasecmp(type, "sawb")  // 3GPP AMR/WB
-            || !strcasecmp(type, "mp4a")) {
+            || !strcasecmp(type, "ac-3")
+            || !strcasecmp(type, "alac")
+            || !strcasecmp(type, "enca")) {
         return MP4_AUDIO_TRACK_TYPE;
     }
 
-    if (!strcasecmp(type, "sdsm")
+    if (!strcasecmp(type, MP4_SCENE_TRACK_TYPE)
             || !strcasecmp(type, "scene")
             || !strcasecmp(type, "bifs")) {
         return MP4_SCENE_TRACK_TYPE;
     }
 
-    if (!strcasecmp(type, "odsm")
+    if (!strcasecmp(type, MP4_OD_TRACK_TYPE)
             || !strcasecmp(type, "od")) {
         return MP4_OD_TRACK_TYPE;
     }
-    if (strcasecmp(type, "cntl") == 0) {
+
+    if (!strcasecmp(type, MP4_HINT_TRACK_TYPE)
+            || !strcasecmp(type, "rtp ")) {
+        return MP4_HINT_TRACK_TYPE;
+    }
+
+    if (!strcasecmp(type, MP4_CNTL_TRACK_TYPE)) {
         return MP4_CNTL_TRACK_TYPE;
     }
 
+    if (!strcasecmp(type, MP4_SUBTITLE_TRACK_TYPE)
+            || !strcasecmp(type, "tx3g")) {
+        return MP4_SUBTITLE_TRACK_TYPE;
+    }
+
     log.verbose1f("Attempt to normalize %s did not match",type);
 
     return type;
diff --git a/mp4v2/src/mp4util.h b/mp4v2/src/mp4util.h
index 1fbbd81..6864495 100644
--- a/mp4v2/src/mp4util.h
+++ b/mp4v2/src/mp4util.h
@@ -33,15 +33,17 @@ namespace mp4v2 { namespace impl {
 #ifndef ASSERT
 #   define ASSERT(expr) \
         if (!(expr)) { \
-            throw new Exception("assert failure: "LIBMPV42_STRINGIFY((expr)), __FILE__, __LINE__, __FUNCTION__ ); \
+            throw new EXCEPTION("assert failure: " LIBMPV42_STRINGIFY((expr))); \
         }
 #endif
 
-#define WARNING(expr) \
-    if (expr) { \
-        log.errorf("Warning (%s) in %s at line %u", \
-                         LIBMPV42_STRINGIFY(expr), __FILE__, __LINE__); \
-    }
+#ifdef NDEBUG
+#   define WARNING(expr) \
+        log.errorf("Warning: %s", LIBMPV42_STRINGIFY(expr));
+#else
+#   define WARNING(expr) \
+        log.errorf("Warning (%s) in %s at line %u", LIBMPV42_STRINGIFY(expr), __FILE__, __LINE__);
+#endif
 
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -51,11 +53,16 @@ namespace mp4v2 { namespace impl {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+#define strequal(str1, str2) (strcmp((str1), (str2)) == 0)
+#define strnequal(str1, str2, n) (strncmp((str1), (str2), (n)) == 0)
+
+///////////////////////////////////////////////////////////////////////////////
+
 inline void* MP4Malloc(size_t size) {
     if (size == 0) return NULL;
     void* p = malloc(size);
-    if (p == NULL && size > 0) {
-        throw new PlatformException("malloc failed",errno,__FILE__,__LINE__,__FUNCTION__);
+    if (p == NULL) {
+        throw new PLATFORM_EXCEPTION("malloc failed", errno);
     }
     return p;
 }
@@ -79,7 +86,7 @@ inline void* MP4Realloc(void* p, uint32_t newSize) {
 
     void* temp = realloc(p, newSize);
     if (temp == NULL && newSize > 0) {
-        throw new PlatformException("malloc failed",errno,__FILE__,__LINE__,__FUNCTION__);
+        throw new PLATFORM_EXCEPTION("malloc failed", errno);
     }
     return temp;
 }
diff --git a/mp4v2/src/qtff/ColorParameterBox.cpp b/mp4v2/src/qtff/ColorParameterBox.cpp
index 7581c63..4a0a306 100644
--- a/mp4v2/src/qtff/ColorParameterBox.cpp
+++ b/mp4v2/src/qtff/ColorParameterBox.cpp
@@ -41,14 +41,14 @@ ColorParameterBox::add( MP4FileHandle file, uint16_t trackIndex, const Item& ite
     MP4Atom* coding;
 
     if( !MP4_IS_VALID_FILE_HANDLE( file ))
-        throw new Exception( "invalid file handle", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid file handle");
 
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* colr;
     if( !findColorParameterBox( file, *coding, colr ))
-        throw new Exception( "colr-box already exists", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("colr-box already exists");
 
     colr = MP4Atom::CreateAtom( *((MP4File *)file), coding, BOX_CODE.c_str() );
     coding->AddChildAtom( colr );
@@ -92,11 +92,11 @@ ColorParameterBox::get( MP4FileHandle file, uint16_t trackIndex, Item& item )
 
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* colr;
     if( findColorParameterBox( file, *coding, colr ))
-        throw new Exception( "colr-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("colr-box not found");
 
     MP4Integer16Property* primariesIndex;
     MP4Integer16Property* transferFunctionIndex;
@@ -171,11 +171,11 @@ ColorParameterBox::remove( MP4FileHandle file, uint16_t trackIndex )
 {
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* colr;
     if( findColorParameterBox( file, *coding, colr ))
-        throw new Exception( "colr-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("colr-box not found");
 
     coding->DeleteChildAtom( colr );
     delete colr;
@@ -199,11 +199,11 @@ ColorParameterBox::set( MP4FileHandle file, uint16_t trackIndex, const Item& ite
 {
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* colr;
     if( findColorParameterBox( file, *coding, colr ))
-        throw new Exception( "colr-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("colr-box not found");
 
     MP4Integer16Property* primariesIndex;
     MP4Integer16Property* transferFunctionIndex;
@@ -268,7 +268,7 @@ ColorParameterBox::Item::convertFromCSV( const string& text )
         xss << "invalid ColorParameterBox format"
             << " (expecting: INDEX1,INDEX2,INDEX3)"
             << " got: " << text;
-        throw new Exception( xss.str(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION(xss.str());
     }
 }
 
diff --git a/mp4v2/src/qtff/PictureAspectRatioBox.cpp b/mp4v2/src/qtff/PictureAspectRatioBox.cpp
index 4fe5916..d10456c 100644
--- a/mp4v2/src/qtff/PictureAspectRatioBox.cpp
+++ b/mp4v2/src/qtff/PictureAspectRatioBox.cpp
@@ -41,14 +41,14 @@ PictureAspectRatioBox::add( MP4FileHandle file, uint16_t trackIndex, const Item&
     MP4Atom* coding;
 
     if( !MP4_IS_VALID_FILE_HANDLE( file ))
-        throw new Exception( "invalid file handle", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid file handle");
 
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* pasp;
     if( !findPictureAspectRatioBox( file, *coding, pasp ))
-        throw new Exception( "pasp-box already exists", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("pasp-box already exists");
 
     pasp = MP4Atom::CreateAtom( *((MP4File *)file), coding, BOX_CODE.c_str() );
     coding->AddChildAtom( pasp );
@@ -84,11 +84,11 @@ PictureAspectRatioBox::get( MP4FileHandle file, uint16_t trackIndex, Item& item
 
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* pasp;
     if( findPictureAspectRatioBox( file, *coding, pasp ))
-        throw new Exception( "pasp-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("pasp-box not found");
 
     MP4Integer16Property* hSpacing;
     MP4Integer16Property* vSpacing;
@@ -159,11 +159,11 @@ PictureAspectRatioBox::remove( MP4FileHandle file, uint16_t trackIndex )
 {
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* pasp;
     if( findPictureAspectRatioBox( file, *coding, pasp ))
-        throw new Exception( "pasp-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("pasp-box not found");
 
     coding->DeleteChildAtom( pasp );
     delete pasp;
@@ -187,11 +187,11 @@ PictureAspectRatioBox::set( MP4FileHandle file, uint16_t trackIndex, const Item&
 {
     MP4Atom* coding;
     if( findCoding( file, trackIndex, coding ))
-        throw new Exception( "supported coding not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("supported coding not found");
 
     MP4Atom* pasp;
     if( findPictureAspectRatioBox( file, *coding, pasp ))
-        throw new Exception( "pasp-box not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("pasp-box not found");
 
     MP4Integer16Property* hSpacing;
     MP4Integer16Property* vSpacing;
@@ -258,7 +258,7 @@ PictureAspectRatioBox::Item::convertFromCSV( const string& text )
         xss << "invalid PcitureAspectRatioBox format"
             << " (expecting: hSpacing,vSpacing)"
             << " got: " << text;
-        throw new Exception( xss.str(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION(xss.str());
     }
 }
 
diff --git a/mp4v2/src/qtff/coding.cpp b/mp4v2/src/qtff/coding.cpp
index 29eaf77..dd2e47f 100644
--- a/mp4v2/src/qtff/coding.cpp
+++ b/mp4v2/src/qtff/coding.cpp
@@ -54,29 +54,29 @@ findCoding( MP4FileHandle file, uint16_t trackIndex, MP4Atom*& coding )
     if( trackIndex == numeric_limits<uint16_t>::max() ) {
         ostringstream xss;
         xss << "invalid track-index: " << trackIndex;
-        throw new Exception( xss.str(), __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION(xss.str());
     }
 
     ostringstream oss;
     oss << "moov.trak[" << trackIndex << "].mdia.hdlr";
     MP4Atom* hdlr = mp4.FindAtom( oss.str().c_str() );
     if( !hdlr )
-        throw new Exception( "media handler not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("media handler not found");
 
     MP4StringProperty* handlerType;
     if( !hdlr->FindProperty( "hdlr.handlerType", (MP4Property**)&handlerType ))
-        throw new Exception( "media handler type-property not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("media handler type-property not found");
 
     const string video = "vide";
     if( video != handlerType->GetValue() )
-        throw new Exception( "video-track required", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("video-track required");
 
     oss.str( "" );
     oss.clear();
     oss << "moov.trak[" << trackIndex << "].mdia.minf.stbl.stsd";
     MP4Atom* stsd = mp4.FindAtom( oss.str().c_str() );
     if( !stsd )
-        throw new Exception( "media handler type-property not found", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("media handler type-property not found");
 
     // find first atom which is a supported coding
     const uint32_t atomc = stsd->GetNumberOfChildAtoms();
diff --git a/mp4v2/src/qtff/qtff.h b/mp4v2/src/qtff/qtff.h
index 6403821..3be2110 100644
--- a/mp4v2/src/qtff/qtff.h
+++ b/mp4v2/src/qtff/qtff.h
@@ -31,7 +31,7 @@
 /// QuickTime File Format Specification, revision 2007-09-04.
 ///
 namespace mp4v2 { namespace impl { namespace qtff {
-    ;
+
 }}}
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/mp4v2/src/rtphint.cpp b/mp4v2/src/rtphint.cpp
index 1eb01f5..a992721 100644
--- a/mp4v2/src/rtphint.cpp
+++ b/mp4v2/src/rtphint.cpp
@@ -148,8 +148,7 @@ void MP4RtpHintTrack::ReadHint(
 uint16_t MP4RtpHintTrack::GetHintNumberOfPackets()
 {
     if (m_pReadHint == NULL) {
-        throw new Exception("no hint has been read",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no hint has been read");
     }
     return m_pReadHint->GetNumberOfPackets();
 }
@@ -157,8 +156,7 @@ uint16_t MP4RtpHintTrack::GetHintNumberOfPackets()
 bool MP4RtpHintTrack::GetPacketBFrame(uint16_t packetIndex)
 {
     if (m_pReadHint == NULL) {
-        throw new Exception("no hint has been read",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no hint has been read");
     }
     MP4RtpPacket* pPacket =
         m_pReadHint->GetPacket(packetIndex);
@@ -169,8 +167,7 @@ bool MP4RtpHintTrack::GetPacketBFrame(uint16_t packetIndex)
 uint16_t MP4RtpHintTrack::GetPacketTransmitOffset(uint16_t packetIndex)
 {
     if (m_pReadHint == NULL) {
-        throw new Exception("no hint has been read",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no hint has been read");
      }
 
     MP4RtpPacket* pPacket =
@@ -188,12 +185,10 @@ void MP4RtpHintTrack::ReadPacket(
     bool addPayload)
 {
     if (m_pReadHint == NULL) {
-        throw new Exception("no hint has been read",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no hint has been read");
     }
     if (!addHeader && !addPayload) {
-        throw new Exception("no data requested",
-                             __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no data requested");
     }
 
     MP4RtpPacket* pPacket =
@@ -242,12 +237,12 @@ void MP4RtpHintTrack::ReadPacket(
             pPacket->GetData(pDest);
         }
     }
-    catch (Exception* x) {
+    catch (Exception*) {
         if (buffer_malloc) {
             MP4Free(*ppBytes);
             *ppBytes = NULL;
         }
-        throw x;
+        throw;
     }
 
     log.hexDump(0, MP4_LOG_VERBOSE1, *ppBytes, *pNumBytes,
@@ -332,7 +327,7 @@ void MP4RtpHintTrack::GetPayload(
 
             if (ppPayloadName) {
                 *ppPayloadName = (char*)MP4Calloc(length + 1);
-                strncpy(*ppPayloadName, pRtpMap, length);
+                memcpy(*ppPayloadName, pRtpMap, length);
             }
             if (pSlash && ppEncodingParams) {
                 pSlash++;
@@ -342,7 +337,7 @@ void MP4RtpHintTrack::GetPayload(
                     if (*pSlash != '\0') {
                         length = (uint32_t)strlen(pRtpMap) - (pSlash - pRtpMap);
                         *ppEncodingParams = (char *)MP4Calloc(length + 1);
-                        strncpy(*ppEncodingParams, pSlash, length);
+                        memcpy(*ppEncodingParams, pSlash, length);
                     }
                 }
             }
@@ -408,11 +403,11 @@ void MP4RtpHintTrack::SetPayload(
 
     // set sdp media type
     const char* sdpMediaType;
-    if (!strcmp(m_pRefTrack->GetType(), MP4_AUDIO_TRACK_TYPE)) {
+    if (strequal(m_pRefTrack->GetType(), MP4_AUDIO_TRACK_TYPE)) {
         sdpMediaType = "audio";
-    } else if (!strcmp(m_pRefTrack->GetType(), MP4_VIDEO_TRACK_TYPE)) {
+    } else if (strequal(m_pRefTrack->GetType(), MP4_VIDEO_TRACK_TYPE)) {
         sdpMediaType = "video";
-    } else if (!strcmp(m_pRefTrack->GetType(), MP4_CNTL_TRACK_TYPE)) {
+    } else if (strequal(m_pRefTrack->GetType(), MP4_CNTL_TRACK_TYPE)) {
         sdpMediaType = "control";
     } else {
         sdpMediaType = "application";
@@ -458,7 +453,7 @@ void MP4RtpHintTrack::AddHint(bool isBFrame, uint32_t timestampOffset)
     }
 
     if (m_pWriteHint) {
-        throw new Exception("unwritten hint is still pending", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("unwritten hint is still pending");
     }
 
     m_pWriteHint = new MP4RtpHint(*this);
@@ -472,7 +467,7 @@ void MP4RtpHintTrack::AddHint(bool isBFrame, uint32_t timestampOffset)
 void MP4RtpHintTrack::AddPacket(bool setMbit, int32_t transmitOffset)
 {
     if (m_pWriteHint == NULL) {
-        throw new Exception("no hint pending", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no hint pending");
     }
 
     MP4RtpPacket* pPacket = m_pWriteHint->AddPacket();
@@ -499,21 +494,19 @@ void MP4RtpHintTrack::AddImmediateData(
     uint32_t numBytes)
 {
     if (m_pWriteHint == NULL) {
-        throw new Exception("no hint pending", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no hint pending");
     }
 
     MP4RtpPacket* pPacket = m_pWriteHint->GetCurrentPacket();
     if (pPacket == NULL) {
-        throw new Exception("no packet pending", __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("no packet pending");
     }
 
     if (pBytes == NULL || numBytes == 0) {
-        throw new Exception("no data",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no data");
     }
     if (numBytes > 14) {
-        throw new Exception("data size is larger than 14 bytes",
-                            __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("data size is larger than 14 bytes");
     }
 
     MP4RtpImmediateData* pData = new MP4RtpImmediateData(*pPacket);
@@ -534,12 +527,12 @@ void MP4RtpHintTrack::AddSampleData(
     uint32_t dataLength)
 {
     if (m_pWriteHint == NULL) {
-        throw new Exception("no hint pending", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no hint pending");
     }
 
     MP4RtpPacket* pPacket = m_pWriteHint->GetCurrentPacket();
     if (pPacket == NULL) {
-        throw new Exception("no packet pending", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no packet pending");
     }
 
     MP4RtpSampleData* pData = new MP4RtpSampleData(*pPacket);
@@ -558,7 +551,7 @@ void MP4RtpHintTrack::AddSampleData(
 void MP4RtpHintTrack::AddESConfigurationPacket()
 {
     if (m_pWriteHint == NULL) {
-        throw new Exception("no hint pending", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no hint pending");
     }
 
     uint8_t* pConfig = NULL;
@@ -574,7 +567,7 @@ void MP4RtpHintTrack::AddESConfigurationPacket()
     ASSERT(m_pMaxPacketSizeProperty);
 
     if (configSize > m_pMaxPacketSizeProperty->GetValue()) {
-        throw new Exception("ES configuration is too large for RTP payload", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("ES configuration is too large for RTP payload");
     }
 
     AddPacket(false);
@@ -603,7 +596,7 @@ void MP4RtpHintTrack::AddESConfigurationPacket()
 void MP4RtpHintTrack::WriteHint(MP4Duration duration, bool isSyncSample)
 {
     if (m_pWriteHint == NULL) {
-        throw new Exception("no hint pending", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("no hint pending");
     }
 
     uint8_t* pBytes;
@@ -894,7 +887,7 @@ void MP4RtpPacket::Read(MP4File& file)
             pData = new MP4RtpSampleDescriptionData(*this);
             break;
         default:
-            throw new Exception("unknown packet data entry type", __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION("unknown packet data entry type");
         }
 
         m_rtpData.Add(pData);
@@ -911,7 +904,7 @@ void MP4RtpPacket::ReadExtra(MP4File& file)
     int32_t extraLength = (int32_t)file.ReadUInt32();
 
     if (extraLength < 4) {
-        throw new Exception("bad packet extra info length", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("bad packet extra info length");
     }
     extraLength -= 4;
 
@@ -920,7 +913,7 @@ void MP4RtpPacket::ReadExtra(MP4File& file)
         uint32_t entryTag = file.ReadUInt32();
 
         if (entryLength < 8) {
-            throw new Exception("bad packet extra info entry length", __FILE__, __LINE__, __FUNCTION__ );
+            throw new EXCEPTION("bad packet extra info entry length");
         }
 
         if (entryTag == STRTOINT32("rtpo") && entryLength == 12) {
@@ -935,7 +928,7 @@ void MP4RtpPacket::ReadExtra(MP4File& file)
     }
 
     if (extraLength < 0) {
-        throw new Exception("invalid packet extra info length", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid packet extra info length");
     }
 }
 
@@ -1318,7 +1311,7 @@ void MP4RtpSampleDescriptionData::GetData(uint8_t* pDest)
 
     // bad reference
     if (pSdAtom == NULL) {
-        throw new Exception("invalid sample description index", __FILE__, __LINE__, __FUNCTION__ );
+        throw new EXCEPTION("invalid sample description index");
     }
 
     // check validity of the upcoming copy
@@ -1328,8 +1321,7 @@ void MP4RtpSampleDescriptionData::GetData(uint8_t* pDest)
         ((MP4Integer32Property*)m_pProperties[4])->GetValue();
 
     if (offset + length > pSdAtom->GetSize()) {
-        throw new Exception("offset and/or length are too large",
-                            __FILE__, __LINE__, __FUNCTION__);
+        throw new EXCEPTION("offset and/or length are too large");
     }
 
     // now we use the raw file to get the desired bytes
diff --git a/mp4v2/src/rtphint.h b/mp4v2/src/rtphint.h
index a2a4fa8..77a7018 100644
--- a/mp4v2/src/rtphint.h
+++ b/mp4v2/src/rtphint.h
@@ -53,7 +53,7 @@ protected:
     MP4RtpPacket& m_packet;
 };
 
-MP4ARRAY_DECL(MP4RtpData, MP4RtpData*)
+typedef MP4Array<MP4RtpData*> MP4RtpDataArray;
 
 class MP4RtpNullData : public MP4RtpData {
 public:
@@ -181,7 +181,7 @@ protected:
     MP4RtpDataArray     m_rtpData;
 };
 
-MP4ARRAY_DECL(MP4RtpPacket, MP4RtpPacket*)
+typedef MP4Array<MP4RtpPacket*> MP4RtpPacketArray;
 
 class MP4RtpHint : public MP4Container {
 public:
diff --git a/mp4v2/svninfo b/mp4v2/svninfo
deleted file mode 100644
index 80b6616..0000000
--- a/mp4v2/svninfo
+++ /dev/null
@@ -1,11 +0,0 @@
-Path: .
-URL: http://mp4v2.googlecode.com/svn/trunk
-Repository Root: http://mp4v2.googlecode.com/svn
-Repository UUID: 6e6572fa-98a6-11dd-ad9f-f77439c74b79
-Revision: 507
-Node Kind: directory
-Schedule: normal
-Last Changed Author: Nicholas.Salerno@gmail.com
-Last Changed Rev: 507
-Last Changed Date: 2015-01-06 07:05:43 +0900 (Tue, 06 Jan 2015)
-
diff --git a/mp4v2/util/impl.h b/mp4v2/util/impl.h
new file mode 100644
index 0000000..9daa297
--- /dev/null
+++ b/mp4v2/util/impl.h
@@ -0,0 +1,10 @@
+#ifndef MP4V2_UTIL_IMPL_H
+#define MP4V2_UTIL_IMPL_H
+
+///////////////////////////////////////////////////////////////////////////////
+
+#include "libutil/util.h"
+
+///////////////////////////////////////////////////////////////////////////////
+
+#endif // MP4V2_UTIL_IMPL_H
diff --git a/mp4v2/util/mp4art.cpp b/mp4v2/util/mp4art.cpp
new file mode 100644
index 0000000..9b399a9
--- /dev/null
+++ b/mp4v2/util/mp4art.cpp
@@ -0,0 +1,438 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  Portions created by David Byron are Copyright (C) 2010.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//      David Byron, dbyron@dbyron.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util/impl.h"
+
+namespace mp4v2 { namespace util {
+    using namespace itmf;
+
+///////////////////////////////////////////////////////////////////////////////
+
+class ArtUtility : public Utility
+{
+private:
+    enum ArtLongCode {
+        LC_ART_ANY = _LC_MAX,
+        LC_ART_INDEX,
+        LC_LIST,
+        LC_ADD,
+        LC_REMOVE,
+        LC_REPLACE,
+        LC_EXTRACT
+    };
+
+public:
+    ArtUtility( int, char** );
+
+protected:
+    // delegates implementation
+    bool utility_option( int, bool& );
+    bool utility_job( JobContext& );
+
+private:
+    struct ArtType {
+        string         name;
+        string         ext;
+        vector<string> cwarns; // compatibility warnings
+        string         cerror; // compatibility error
+    };
+
+    bool actionList    ( JobContext& );
+    bool actionAdd     ( JobContext& );
+    bool actionRemove  ( JobContext& );
+    bool actionReplace ( JobContext& );
+    bool actionExtract ( JobContext& );
+
+    bool extractSingle( JobContext&, const CoverArtBox::Item&, uint32_t );
+
+private:
+    Group  _actionGroup;
+    Group  _parmGroup;
+
+    bool (ArtUtility::*_action)( JobContext& );
+
+    string   _artImageFile;
+    uint32_t _artFilter;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+ArtUtility::ArtUtility( int argc, char** argv )
+    : Utility      ( "mp4art", argc, argv )
+    , _actionGroup ( "ACTIONS" )
+    , _parmGroup   ( "ACTION PARAMETERS" )
+    , _action      ( NULL )
+    , _artFilter   ( numeric_limits<uint32_t>::max() )
+{
+    // add standard options which make sense for this utility
+    _group.add( STD_OPTIMIZE );
+    _group.add( STD_DRYRUN );
+    _group.add( STD_KEEPGOING );
+    _group.add( STD_OVERWRITE );
+    _group.add( STD_FORCE );
+    _group.add( STD_QUIET );
+    _group.add( STD_DEBUG );
+    _group.add( STD_VERBOSE );
+    _group.add( STD_HELP );
+    _group.add( STD_VERSION );
+    _group.add( STD_VERSIONX );
+
+    _parmGroup.add( "art-any",   false, LC_ART_ANY,   "act on all covr-boxes (default)" );
+    _parmGroup.add( "art-index", true,  LC_ART_INDEX, "act on covr-box index IDX", "IDX" );
+    _groups.push_back( &_parmGroup );
+
+    _actionGroup.add( "list",    false, LC_LIST,    "list all covr-boxes" );
+    _actionGroup.add( "add",     true,  LC_ADD,     "add covr-box from IMG file", "IMG" );
+    _actionGroup.add( "replace", true,  LC_REPLACE, "replace covr-box with IMG file", "IMG" );
+    _actionGroup.add( "remove",  false, LC_REMOVE,  "remove covr-box" );
+    _actionGroup.add( "extract", false, LC_EXTRACT, "extract covr-box" );
+    _groups.push_back( &_actionGroup );
+
+    _usage = "[OPTION]... ACTION file...";
+    _description =
+        // 79-cols, inclusive, max desired width
+        // |----------------------------------------------------------------------------|
+        "\nFor each mp4 (m4a) file specified, perform the specified ACTION. An action"
+        "\nmust be specified. Some options are not applicable for some actions.";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::actionAdd( JobContext& job )
+{
+    File in( _artImageFile, File::MODE_READ );
+    if( in.open() )
+        return herrf( "unable to open %s for read: %s\n", _artImageFile.c_str(), sys::getLastErrorStr() );
+
+    const uint32_t max = numeric_limits<uint32_t>::max();
+    if( in.size > max )
+        return herrf( "file too large: %s (exceeds %u bytes)\n", _artImageFile.c_str(), max );
+
+    CoverArtBox::Item item;
+    item.size     = static_cast<uint32_t>( in.size );
+    item.buffer   = static_cast<uint8_t*>( malloc( item.size ));
+    item.autofree = true;
+
+    File::Size nin;
+    if( in.read( item.buffer, item.size, nin ))
+        return herrf( "read failed: %s\n", _artImageFile.c_str() );
+
+    in.close();
+
+    verbose1f( "adding %s -> %s\n", _artImageFile.c_str(), job.file.c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    if( CoverArtBox::add( job.fileHandle, item ))
+        return herrf( "unable to add covr-box\n" );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::actionExtract( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    // single-mode
+    if( _artFilter != numeric_limits<uint32_t>::max() ) {
+        CoverArtBox::Item item;
+        if( CoverArtBox::get( job.fileHandle, item, _artFilter ))
+            return herrf( "unable to retrieve covr-box (index=%d): %s\n", _artFilter, job.file.c_str() );
+
+        return extractSingle( job, item, _artFilter );
+    }
+
+    // wildcard-mode
+    CoverArtBox::ItemList items;
+    if( CoverArtBox::list( job.fileHandle, items ))
+        return herrf( "unable to fetch list of covr-box: %s\n", job.file.c_str() );
+
+    bool onesuccess = false;
+    const CoverArtBox::ItemList::size_type max = items.size();
+    for( CoverArtBox::ItemList::size_type i = 0; i < max; i++ ) {
+        bool rv = extractSingle( job, items[i], (uint32_t)i );
+        if( !rv )
+            onesuccess = true;
+        if( !_keepgoing && rv )
+            return FAILURE;
+    }
+
+    return _keepgoing ? onesuccess : SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::actionList( JobContext& job )
+{
+    ostringstream report;
+
+    const int widx = 3;
+    const int wsize = 8;
+    const int wtype = 9;
+    const string sep = "  ";
+
+    if( _jobCount == 0 ) {
+        report << setw(widx) << right << "IDX" << left
+               << sep << setw(wsize) << right << "BYTES" << left
+               << sep << setw(8) << "CRC32"
+               << sep << setw(wtype) << "TYPE"
+               << sep << setw(0) << "FILE"
+               << '\n';
+
+        report << setfill('-') << setw(70) << "" << setfill(' ') << '\n';
+    }
+
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    CoverArtBox::ItemList items;
+    if( CoverArtBox::list( job.fileHandle, items ))
+        return herrf( "unable to get list of covr-box: %s\n", job.file.c_str() );
+
+    int line = 0;
+    const CoverArtBox::ItemList::size_type max = items.size();
+    for( CoverArtBox::ItemList::size_type i = 0; i < max; i++ ) {
+        if( _artFilter != numeric_limits<uint32_t>::max() && _artFilter != i )
+            continue;
+
+        CoverArtBox::Item& item = items[i];
+        const uint32_t crc = crc32( item.buffer, item.size );
+
+        report << setw(widx) << right << i
+               << sep << setw(wsize) << item.size
+               << sep << setw(8) << setfill('0') << hex << crc << setfill(' ') << dec
+               << sep << setw(wtype) << left << enumBasicType.toString( item.type );
+
+        if( line++ == 0 )
+            report << sep << setw(0) << job.file;
+
+        report << '\n';
+    }
+
+    verbose1f( "%s", report.str().c_str() );
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::actionRemove( JobContext& job )
+{
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    if( _artFilter == numeric_limits<uint32_t>::max() )
+        verbose1f( "removing covr-box (all) from %s\n", job.file.c_str() );
+    else
+        verbose1f( "removing covr-box (index=%d) from %s\n", _artFilter, job.file.c_str() );
+
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    if( CoverArtBox::remove( job.fileHandle, _artFilter ))
+        return herrf( "remove failed\n" );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::actionReplace( JobContext& job )
+{
+    File in( _artImageFile, File::MODE_READ );
+    if( in.open() )
+        return herrf( "unable to open %s for read: %s\n", _artImageFile.c_str(), sys::getLastErrorStr() );
+
+    const uint32_t max = numeric_limits<uint32_t>::max();
+    if( in.size > max )
+        return herrf( "file too large: %s (exceeds %u bytes)\n", _artImageFile.c_str(), max );
+
+    CoverArtBox::Item item;
+    item.size     = static_cast<uint32_t>( in.size );
+    item.buffer   = static_cast<uint8_t*>( malloc( item.size ));
+    item.autofree = true;
+
+    File::Size nin;
+    if( in.read( item.buffer, item.size, nin ))
+        return herrf( "read failed: %s\n", _artImageFile.c_str() );
+
+    in.close();
+
+    if( _artFilter == numeric_limits<uint32_t>::max() )
+        verbose1f( "replacing %s -> %s (all)\n", _artImageFile.c_str(), job.file.c_str() );
+    else
+        verbose1f( "replacing %s -> %s (index=%d)\n", _artImageFile.c_str(), job.file.c_str(), _artFilter );
+
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    if( CoverArtBox::set( job.fileHandle, item, _artFilter ))
+        return herrf( "unable to add covr-box: %s\n", job.file.c_str() );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::extractSingle( JobContext& job, const CoverArtBox::Item& item, uint32_t index )
+{
+    // compute out filename
+    string out_name = job.file;
+    FileSystem::pathnameStripExtension( out_name );
+
+    ostringstream oss;
+    oss << out_name << ".art[" << index << ']';
+
+    // if implicit we try to determine type by inspecting data
+    BasicType bt = item.type;
+    if( bt == BT_IMPLICIT )
+        bt = computeBasicType( item.buffer, item.size );
+
+    // add file extension appropriate for known covr-box types
+    switch( bt ) {
+        case BT_GIF:    oss << ".gif"; break;
+        case BT_JPEG:   oss << ".jpg"; break;
+        case BT_PNG:    oss << ".png"; break;
+        case BT_BMP:    oss << ".bmp"; break;
+
+        default:
+            oss << ".dat";
+            break;
+    }
+
+    out_name = oss.str();
+    verbose1f( "extracting %s (index=%d) -> %s\n", job.file.c_str(), index, out_name.c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    File out( out_name, File::MODE_CREATE );
+    if( openFileForWriting( out ))
+        return FAILURE;
+
+    File::Size nout;
+    if( out.write( item.buffer, item.size, nout ))
+        return herrf( "write failed: %s\n", out_name.c_str() );
+
+    out.close();
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::utility_job( JobContext& job )
+{
+    if( !_action )
+        return herrf( "no action specified\n" );
+
+    return (this->*_action)( job );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+ArtUtility::utility_option( int code, bool& handled )
+{
+    handled = true;
+
+    switch( code ) {
+        case LC_ART_ANY:
+            _artFilter = numeric_limits<uint32_t>::max();
+            break;
+
+        case LC_ART_INDEX:
+        {
+            istringstream iss( prog::optarg );
+            iss >> _artFilter;
+            if( iss.rdstate() != ios::eofbit )
+                return herrf( "invalid cover-art index: %s\n", prog::optarg );
+            break;
+        }
+
+        case LC_LIST:
+            _action = &ArtUtility::actionList;
+            break;
+
+        case LC_ADD:
+            _action = &ArtUtility::actionAdd;
+            _artImageFile = prog::optarg;
+            if( _artImageFile.empty() )
+                return herrf( "invalid image file: empty-string\n" );
+            break;
+
+        case LC_REMOVE:
+            _action = &ArtUtility::actionRemove;
+            break;
+
+        case LC_REPLACE:
+            _action = &ArtUtility::actionReplace;
+            _artImageFile = prog::optarg;
+            if( _artImageFile.empty() )
+                return herrf( "invalid image file: empty-string\n" );
+            break;
+
+        case LC_EXTRACT:
+            _action = &ArtUtility::actionExtract;
+            break;
+
+        default:
+            handled = false;
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+extern "C"
+int main( int argc, char** argv )
+{
+    mp4v2::util::ArtUtility util( argc, argv );
+    return util.process();
+}
diff --git a/mp4v2/util/mp4chaps.cpp b/mp4v2/util/mp4chaps.cpp
new file mode 100644
index 0000000..fd068c4
--- /dev/null
+++ b/mp4v2/util/mp4chaps.cpp
@@ -0,0 +1,1189 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Ullrich Pollaehne.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  Portions created by David Byron are Copyright (C) 2010.
+//  Portions created by Robert Kausch are Copyright (C) 2022.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//      Ullrich Pollaehne, u.pollaehne@@gmail.com
+//      David Byron, dbyron@dbyron.com
+//      Robert Kausch, robert.kausch@freac.org
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+///
+/// Chapter utility program class.
+///
+/// This class provides an implementation for a QuickTime/Nero chapter utility which
+/// allows to add, delete, convert export or import QuickTime and Nero chapters
+/// in MP4 container files.
+///
+///
+/// @see Utility
+///
+///////////////////////////////////////////////////////////////////////////////
+class ChapterUtility : public Utility
+{
+private:
+    static const double CHAPTERTIMESCALE; //!< the timescale used for chapter tracks (1000)
+
+    enum FileLongCode {
+        LC_CHPT_ANY = _LC_MAX,
+        LC_CHPT_QT,
+        LC_CHPT_NERO,
+        LC_CHPT_NATIVE,
+        LC_CHPT_COMMON,
+        LC_CHP_LIST,
+        LC_CHP_CONVERT,
+        LC_CHP_EVERY,
+        LC_CHP_EXPORT,
+        LC_CHP_IMPORT,
+        LC_CHP_REMOVE
+    };
+
+    enum ChapterFormat {
+        CHPT_FMT_NATIVE,
+        CHPT_FMT_COMMON
+    };
+
+    enum FormatState {
+        FMT_STATE_INITIAL,
+        FMT_STATE_TIME_LINE,
+        FMT_STATE_TITLE_LINE,
+        FMT_STATE_FINISH
+    };
+
+public:
+    ChapterUtility( int, char** );
+
+protected:
+    // delegates implementation
+    bool utility_option( int, bool& );
+    bool utility_job( JobContext& );
+
+private:
+    bool actionList    ( JobContext& ); 
+    bool actionConvert ( JobContext& );
+    bool actionEvery   ( JobContext& );
+    bool actionExport  ( JobContext& );
+    bool actionImport  ( JobContext& );
+    bool actionRemove  ( JobContext& );
+
+private:
+    Group  _actionGroup;
+    Group  _parmGroup;
+
+    bool        (ChapterUtility::*_action)( JobContext& );
+    void        fixQtScale(MP4FileHandle );
+    MP4TrackId  getReferencingTrack( MP4FileHandle, bool& );
+    string      getChapterTypeName( MP4ChapterType ) const;
+    bool        parseChapterFile( const string&, vector<MP4Chapter_t>&, Timecode::Format& );
+    bool        readChapterFile( const string&, char**, File::Size& );
+    MP4Duration convertFrameToMillis( MP4Duration, uint32_t );
+
+    MP4ChapterType _ChapterType;
+    ChapterFormat  _ChapterFormat;
+    uint32_t       _ChaptersEvery;
+    string         _ChapterFile;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+const double ChapterUtility::CHAPTERTIMESCALE = 1000.0;
+
+///////////////////////////////////////////////////////////////////////////////
+
+ChapterUtility::ChapterUtility( int argc, char** argv )
+    : Utility        ( "mp4chaps", argc, argv )
+    , _actionGroup   ( "ACTIONS" )
+    , _parmGroup     ( "ACTION PARAMETERS" )
+    , _action        ( NULL )
+    , _ChapterType   ( MP4ChapterTypeAny )
+    , _ChapterFormat ( CHPT_FMT_NATIVE )
+    , _ChaptersEvery ( 0 )
+{
+    // add standard options which make sense for this utility
+    _group.add( STD_OPTIMIZE );
+    _group.add( STD_DRYRUN );
+    _group.add( STD_KEEPGOING );
+    _group.add( STD_OVERWRITE );
+    _group.add( STD_FORCE );
+    _group.add( STD_QUIET );
+    _group.add( STD_DEBUG );
+    _group.add( STD_VERBOSE );
+    _group.add( STD_HELP );
+    _group.add( STD_VERSION );
+    _group.add( STD_VERSIONX );
+
+    _parmGroup.add( 'A', false, "chapter-any",   false, LC_CHPT_ANY,    "act on any chapter type (default)" );
+    _parmGroup.add( 'Q', false, "chapter-qt",    false, LC_CHPT_QT,     "act on QuickTime chapters" );
+    _parmGroup.add( 'N', false, "chapter-nero",  false, LC_CHPT_NERO,   "act on Nero chapters" );
+    _parmGroup.add(  0 , false, "format-native", false, LC_CHPT_NATIVE, "export chapters in native format (default)" );
+    _parmGroup.add( 'C', false, "format-common", false, LC_CHPT_COMMON, "export chapters in common format" );
+    _groups.push_back( &_parmGroup );
+
+    _actionGroup.add( 'l', false, "list",    false, LC_CHP_LIST,    "list available chapters" );
+    _actionGroup.add( 'c', false, "convert", false, LC_CHP_CONVERT, "convert available chapters" );
+    _actionGroup.add( 'e', true,  "every",   true,  LC_CHP_EVERY,   "create chapters every NUM seconds", "NUM" );
+    _actionGroup.add( 'x', false, "export",  false, LC_CHP_EXPORT,  "export chapters to mp4file.chapters.txt", "TXT" );
+    _actionGroup.add( 'i', false, "import",  false, LC_CHP_IMPORT,  "import chapters from mp4file.chapters.txt", "TXT" );
+    _actionGroup.add( 'r', false, "remove",  false, LC_CHP_REMOVE,  "remove all chapters" );
+    _groups.push_back( &_actionGroup );
+
+    _usage = "[OPTION]... ACTION [ACTION PARAMETERS] mp4file...";
+    _description =
+        // 79-cols, inclusive, max desired width
+        // |----------------------------------------------------------------------------|
+        "\nFor each mp4 file specified, perform the specified ACTION. An action must be"
+        "\nspecified. Some options are not applicable to some actions.";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for listing chapters from <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionList( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+    }
+
+    MP4Chapter_t * chapters = 0;
+    uint32_t chapterCount = 0;
+
+    // get the list of chapters
+    MP4ChapterType chtp = MP4GetChapters(job.fileHandle, &chapters, &chapterCount, _ChapterType);
+    if (0 == chapterCount)
+    {
+        verbose1f( "File \"%s\" does not contain chapters of type %s\n", job.file.c_str(),
+                   getChapterTypeName( _ChapterType ).c_str() );
+        return SUCCESS;
+    }
+
+    // start output (more or less like mp4box does)
+    ostringstream report;
+    report << getChapterTypeName( chtp ) << ' ' << "Chapters of " << '"' << job.file << '"' << endl;
+
+    Timecode duration(0, CHAPTERTIMESCALE);
+    duration.setFormat( Timecode::DECIMAL );
+    for (uint32_t i = 0; i < chapterCount; ++i)
+    {
+        // print the infos
+        report << '\t' << "Chapter #" << setw( 3 ) << setfill( '0' ) << i+1
+               << " - " << duration.svalue << " - " << '"' << chapters[i].title << '"' << endl;
+
+        // add the duration of this chapter to the sum (is the start time of the next chapter)
+        duration += Timecode(chapters[i].duration, CHAPTERTIMESCALE);
+    }
+
+    verbose1f( "%s", report.str().c_str() );
+
+    // free up the memory
+    MP4Free(chapters);
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for converting chapters in <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionConvert( JobContext& job )
+{
+    MP4ChapterType sourceType;
+
+    switch( _ChapterType )
+    {
+    case MP4ChapterTypeNero:
+        sourceType = MP4ChapterTypeQt;
+        break;
+    case MP4ChapterTypeQt:
+        sourceType = MP4ChapterTypeNero;
+        break;
+    default:
+        return herrf( "invalid chapter type \"%s\" define the chapter type to convert to\n",
+                      getChapterTypeName( _ChapterType ).c_str() );
+    }
+
+    ostringstream oss;
+    oss << "converting chapters in file " << '"' << job.file << '"'
+        << " from " << getChapterTypeName( sourceType ) << " to " << getChapterTypeName( _ChapterType ) << endl;
+
+    verbose1f( "%s", oss.str().c_str() );
+    if( dryrunAbort() )
+    {
+        return SUCCESS;
+    }
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+    }
+
+    MP4ChapterType chtp = MP4ConvertChapters( job.fileHandle, _ChapterType );
+    if( MP4ChapterTypeNone == chtp )
+    {
+        return herrf( "File %s does not contain chapters of type %s\n", job.file.c_str(),
+                      getChapterTypeName( sourceType ).c_str() );
+    }
+
+    fixQtScale( job.fileHandle );
+    job.optimizeApplicable = true;
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for setting chapters every n second in <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionEvery( JobContext& job )
+{
+    ostringstream oss;
+    oss << "Setting " << getChapterTypeName( _ChapterType ) << " chapters every "
+        << _ChaptersEvery << " seconds in file " << '"' << job.file << '"' << endl;
+
+    verbose1f( "%s", oss.str().c_str() );
+    if( dryrunAbort() )
+    {
+        return SUCCESS;
+    }
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+    }
+
+    bool isVideoTrack = false;
+    MP4TrackId refTrackId = getReferencingTrack( job.fileHandle, isVideoTrack );
+    if( !MP4_IS_VALID_TRACK_ID(refTrackId) )
+    {
+        return herrf( "unable to find a video or audio track in file %s\n", job.file.c_str() );
+    }
+
+    Timecode refTrackDuration( MP4GetTrackDuration( job.fileHandle, refTrackId ), MP4GetTrackTimeScale( job.fileHandle, refTrackId ) );
+    refTrackDuration.setScale( CHAPTERTIMESCALE );
+
+    Timecode chapterDuration( _ChaptersEvery * 1000, CHAPTERTIMESCALE );
+    chapterDuration.setFormat( Timecode::DECIMAL );
+    vector<MP4Chapter_t> chapters;
+
+    do
+    {
+        MP4Chapter_t chap;
+        chap.duration = refTrackDuration.duration > chapterDuration.duration ? chapterDuration.duration : refTrackDuration.duration;
+        sprintf(chap.title, "Chapter %lu", (unsigned long)chapters.size()+1);
+
+        chapters.push_back( chap );
+        refTrackDuration -= chapterDuration;
+    }
+    while( refTrackDuration.duration > 0 );
+
+    if( 0 < chapters.size() )
+    {
+        MP4SetChapters(job.fileHandle, &chapters[0], (uint32_t)chapters.size(), _ChapterType);
+    }
+
+    fixQtScale( job.fileHandle );
+    job.optimizeApplicable = true;
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for exporting chapters from the <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionExport( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+    }
+
+    // get the list of chapters
+    MP4Chapter_t*  chapters = 0;
+    uint32_t       chapterCount = 0;
+    MP4ChapterType chtp = MP4GetChapters( job.fileHandle, &chapters, &chapterCount, _ChapterType );
+    if (0 == chapterCount)
+    {
+        return herrf( "File \"%s\" does not contain chapters of type %s\n", job.file.c_str(),
+                      getChapterTypeName( chtp ).c_str() );
+    }
+
+    // build the filename
+    string outName = job.file;
+    if( _ChapterFile.empty() )
+    {
+        FileSystem::pathnameStripExtension( outName );
+        outName.append( ".chapters.txt" );
+    }
+    else
+    {
+        outName = _ChapterFile;
+    }
+
+    ostringstream oss;
+    oss << "Exporting " << chapterCount << " " << getChapterTypeName( chtp );
+    oss << " chapters from file " << '"' << job.file << '"' << " into chapter file " << '"' << outName << '"' << endl;
+
+    verbose1f( "%s", oss.str().c_str() );
+    if( dryrunAbort() )
+    {
+        // free up the memory
+        MP4Free(chapters);
+
+        return SUCCESS;
+    }
+
+    // open the file
+    File out( outName, File::MODE_CREATE );
+    if( openFileForWriting( out ) )
+    {
+        // free up the memory
+        MP4Free(chapters);
+
+        return FAILURE;
+    }
+
+    // set up format
+#if defined( _WIN32 )
+    static const char* LINEND = "\r\n";
+#else
+    static const char* LINEND = "\n";
+#endif
+    File::Size nout;
+    bool failure = SUCCESS;
+    int width = 2;
+    if( _ChapterFormat == CHPT_FMT_COMMON && (chapterCount / 100) >= 1 )
+        width = 3;
+
+    // write additional information
+    if( _ChapterFormat == CHPT_FMT_NATIVE ) {
+        ostringstream oss;
+        // write metadata
+        const MP4Tags* tags = MP4TagsAlloc();
+        MP4TagsFetch( tags, job.fileHandle );
+
+        if( tags->albumArtist && (!tags->artist || !strequal(tags->albumArtist, tags->artist)) )
+            oss << "## album-artist: " << tags->albumArtist << LINEND;
+
+        if( tags->artist )
+            oss << "## artist: " << tags->artist << LINEND;
+
+        if( tags->album && (!tags->name || !strequal(tags->album, tags->name)) )
+            oss << "## album: " << tags->album << LINEND;
+
+        if( tags->name )
+            oss << "## title: " << tags->name << LINEND;
+
+        if( oss.tellp() > 0 )
+            oss << "##" << LINEND;
+
+        MP4TagsFree( tags );
+
+        // write total duration
+        Timecode movieDuration( MP4GetDuration( job.fileHandle ),
+                                MP4GetTimeScale( job.fileHandle ) );
+        movieDuration.setScale( CHAPTERTIMESCALE );
+        movieDuration.setFormat( Timecode::DECIMAL );
+
+        oss << "## total-duration: " << movieDuration.svalue << LINEND
+            << "##" << LINEND;
+
+        string str = oss.str();
+        if( out.write( str.c_str(), str.size(), nout ) )
+            failure = herrf( "write to %s failed: %s\n", outName.c_str(), sys::getLastErrorStr() );
+    }
+
+    // write the chapters
+    Timecode duration( 0, CHAPTERTIMESCALE );
+    duration.setFormat( Timecode::DECIMAL );
+    for( uint32_t i = 0; i < chapterCount; ++i )
+    {
+        // print the infos
+        ostringstream oss;
+        switch( _ChapterFormat )
+        {
+            case CHPT_FMT_COMMON:
+                oss << "CHAPTER" << setw( width ) << setfill( '0' ) << i+1 <<     '=' << duration.svalue << LINEND
+                    << "CHAPTER" << setw( width ) << setfill( '0' ) << i+1 << "NAME=" << chapters[i].title << LINEND;
+                break;
+            case CHPT_FMT_NATIVE:
+            default:
+                oss << duration.svalue << ' ' << chapters[i].title << LINEND;
+        }
+
+        string str = oss.str();
+        if( out.write( str.c_str(), str.size(), nout ) )
+        {
+            failure = herrf( "write to %s failed: %s\n", outName.c_str(), sys::getLastErrorStr() );
+            break;
+        }
+
+        // add the duration of this chapter to the sum (the start time of the next chapter)
+        duration += Timecode(chapters[i].duration, CHAPTERTIMESCALE);
+    }
+    out.close();
+    if( failure )
+    {
+        verbose1f( "removing file %s\n", outName.c_str() );
+        ::remove( outName.c_str() );
+    }
+
+    // free up the memory
+    MP4Free(chapters);
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for importing chapters into the <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionImport( JobContext& job )
+{
+    vector<MP4Chapter_t> chapters;
+    Timecode::Format format;
+
+    // create the chapter file name
+    string inName = job.file;
+    if( _ChapterFile.empty() )
+    {
+        FileSystem::pathnameStripExtension( inName );
+        inName.append( ".chapters.txt" );
+    }
+    else
+    {
+        inName = _ChapterFile;
+    }
+
+    if( parseChapterFile( inName, chapters, format ) )
+    {
+        return FAILURE;
+    }
+
+    ostringstream oss;
+    oss << "Importing " << chapters.size() << " " << getChapterTypeName( _ChapterType );
+    oss << " chapters from file " << inName << " into file " << '"' << job.file << '"' << endl;
+
+    verbose1f( "%s", oss.str().c_str() );
+    if( dryrunAbort() )
+    {
+        return SUCCESS;
+    }
+
+    if( 0 == chapters.size() )
+    {
+        return herrf( "No chapters found in file %s\n", inName.c_str() );
+    }
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+    }
+
+    bool isVideoTrack = false;
+    MP4TrackId refTrackId = getReferencingTrack( job.fileHandle, isVideoTrack );
+    if( !MP4_IS_VALID_TRACK_ID(refTrackId) )
+    {
+        return herrf( "unable to find a video or audio track in file %s\n", job.file.c_str() );
+    }
+    if( Timecode::FRAME == format && !isVideoTrack )
+    {
+        // we need a video track for this
+        return herrf( "unable to find a video track in file %s but chapter file contains frame timestamps\n", job.file.c_str() );
+    }
+
+    // get duration and recalculate scale
+    Timecode refTrackDuration( MP4GetTrackDuration( job.fileHandle, refTrackId ),
+                               MP4GetTrackTimeScale( job.fileHandle, refTrackId ) );
+    refTrackDuration.setScale( CHAPTERTIMESCALE );
+
+    // check for chapters starting after duration of reftrack
+    for( vector<MP4Chapter_t>::iterator it = chapters.begin(); it != chapters.end(); )
+    {
+        Timecode curr( (*it).duration, CHAPTERTIMESCALE );
+        if( refTrackDuration <= curr )
+        {
+            hwarnf( "Chapter '%s' start: %s, playlength of file: %s, chapter cannot be set\n",
+                    (*it).title, curr.svalue.c_str(), refTrackDuration.svalue.c_str() );
+            it = chapters.erase( it );
+        }
+        else
+        {
+            ++it;
+        }
+    }
+    if( 0 == chapters.size() )
+    {
+        return SUCCESS;
+    }
+
+    // convert start time into duration
+	uint32_t framerate = static_cast<uint32_t>( CHAPTERTIMESCALE );
+    if( Timecode::FRAME == format )
+    {
+        // get the framerate
+        MP4SampleId sampleCount = MP4GetTrackNumberOfSamples( job.fileHandle, refTrackId );
+        Timecode tmpcd( refTrackDuration.svalue, CHAPTERTIMESCALE );
+		framerate = static_cast<uint32_t>( std::ceil( ((double)sampleCount / (double)tmpcd.duration) * CHAPTERTIMESCALE ) );
+    }
+
+    for( vector<MP4Chapter_t>::iterator it = chapters.begin(); it != chapters.end(); ++it )
+    {
+        MP4Duration currDur = (*it).duration;
+        MP4Duration nextDur =  chapters.end() == it+1 ? refTrackDuration.duration : (*(it+1)).duration;
+
+        if( Timecode::FRAME == format )
+        {
+            // convert from frame nr to milliseconds
+            currDur = convertFrameToMillis( (*it).duration, framerate );
+
+            if( chapters.end() != it+1 )
+            {
+                nextDur = convertFrameToMillis( (*(it+1)).duration, framerate );
+            }
+        }
+
+        (*it).duration = nextDur - currDur;
+    }
+
+    // now set the chapters
+    MP4SetChapters( job.fileHandle, &chapters[0], (uint32_t)chapters.size(), _ChapterType );
+
+    fixQtScale( job.fileHandle );
+    job.optimizeApplicable = true;
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Action for removing chapters from the <b>job.file</b>
+ *
+ *  
+ *  @param job the job to process
+ *  @return mp4v2::util::SUCCESS if successful, mp4v2::util::FAILURE otherwise
+ */
+bool
+ChapterUtility::actionRemove( JobContext& job )
+{
+    ostringstream oss;
+    oss << "Deleting " << getChapterTypeName( _ChapterType ) << " chapters from file " << '"' << job.file << '"' << endl;
+
+    verbose1f( "%s", oss.str().c_str() );
+    if( dryrunAbort() )
+    {
+        return SUCCESS;
+    }
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+    {
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+    }
+
+    MP4ChapterType chtp = MP4DeleteChapters( job.fileHandle, _ChapterType );
+    if( MP4ChapterTypeNone == chtp )
+    {
+        return FAILURE;
+    }
+
+    fixQtScale( job.fileHandle );
+    job.optimizeApplicable = true;
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** process positional argument
+ *
+ *  @see Utility::utility_job( JobContext& )
+ */
+bool
+ChapterUtility::utility_job( JobContext& job )
+{
+    if( !_action )
+    {
+        return herrf( "no action specified\n" );
+    }
+
+    return (this->*_action)( job );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** process command-line option
+ *
+ *  @see Utility::utility_option( int, bool& )
+ */
+bool
+ChapterUtility::utility_option( int code, bool& handled )
+{
+    handled = true;
+
+    switch( code ) {
+        case 'A':
+        case LC_CHPT_ANY:
+            _ChapterType = MP4ChapterTypeAny;
+            break;
+
+        case 'Q':
+        case LC_CHPT_QT:
+            _ChapterType = MP4ChapterTypeQt;
+            break;
+
+        case 'N':
+        case LC_CHPT_NERO:
+            _ChapterType = MP4ChapterTypeNero;
+            break;
+
+        case LC_CHPT_NATIVE:
+            _ChapterFormat = CHPT_FMT_NATIVE;
+            break;
+
+        case 'C':
+        case LC_CHPT_COMMON:
+            _ChapterFormat = CHPT_FMT_COMMON;
+            break;
+
+        case 'l':
+        case LC_CHP_LIST:
+            _action = &ChapterUtility::actionList;
+            break;
+
+        case 'e':
+        case LC_CHP_EVERY:
+        {
+            istringstream iss( prog::optarg );
+            iss >> _ChaptersEvery;
+            if( iss.rdstate() != ios::eofbit )
+            {
+                return herrf( "invalid number of seconds: %s\n", prog::optarg );
+            }
+            _action = &ChapterUtility::actionEvery;
+            break;
+        }
+
+        case 'x':
+            _action = &ChapterUtility::actionExport;
+            break;
+
+        case LC_CHP_EXPORT:
+            _action = &ChapterUtility::actionExport;
+            /* currently not supported since the chapters of n input files would be written to one chapter file
+            _ChapterFile = prog::optarg;
+            if( _ChapterFile.empty() )
+            {
+                return herrf( "invalid TXT file: empty-string\n" );
+            }
+            */
+            break;
+
+        case 'i':
+            _action = &ChapterUtility::actionImport;
+            break;
+
+        case LC_CHP_IMPORT:
+            _action = &ChapterUtility::actionImport;
+            /* currently not supported since the chapters of n input files would be read from one chapter file
+            _ChapterFile = prog::optarg;
+            if( _ChapterFile.empty() )
+            {
+                return herrf( "invalid TXT file: empty-string\n" );
+            }
+            */
+            break;
+
+        case 'c':
+        case LC_CHP_CONVERT:
+            _action = &ChapterUtility::actionConvert;
+            break;
+
+        case 'r':
+        case LC_CHP_REMOVE:
+            _action = &ChapterUtility::actionRemove;
+            break;
+
+        default:
+            handled = false;
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Fix a QuickTime/iPod issue with long audio files.
+ *
+ *  This function checks if the <b>file</b> is a long audio file (more than
+ *  about 6 1/2 hours) and modifies the timescale if necessary to allow
+ *  playback of the file in QuickTime player and on some iPod models.
+ *
+ *  @param file the opened MP4 file
+ */
+void
+ChapterUtility::fixQtScale(MP4FileHandle file)
+{
+    // get around a QuickTime/iPod issue with storing the number of samples in a signed 32Bit value
+    if( INT_MAX < MP4GetDuration(file))
+    {
+        bool isVideoTrack = false;
+        if( MP4_IS_VALID_TRACK_ID(getReferencingTrack( file, isVideoTrack )) & isVideoTrack )
+        {
+            // if it is a video, everything is different
+            return;
+        }
+
+        // timescale too high, lower it
+        MP4ChangeMovieTimeScale(file, 1000);
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Finds a suitable track that can reference a chapter track.
+ *
+ *  This function returns the first video or audio track that is found
+ *  in the <b>file</b>.
+ *  This track ca be used to reference the QuickTime chapter track.
+ *
+ *  @param file the opened MP4 file
+ *  @param isVideoTrack receives true if the found track is video, false otherwise
+ *  @return the <b>MP4TrackId</b> of the found track
+ */
+MP4TrackId
+ChapterUtility::getReferencingTrack( MP4FileHandle file, bool& isVideoTrack )
+{
+    isVideoTrack = false;
+
+    uint32_t trackCount = MP4GetNumberOfTracks( file );
+    if( 0 == trackCount )
+    {
+        return MP4_INVALID_TRACK_ID;
+    }
+
+    MP4TrackId refTrackId = MP4_INVALID_TRACK_ID;
+    for( uint32_t i = 0; i < trackCount; ++i )
+    {
+        MP4TrackId    id = MP4FindTrackId( file, i );
+        const char* type = MP4GetTrackType( file, id );
+        if( MP4_IS_VIDEO_TRACK_TYPE( type ) )
+        {
+            refTrackId = id;
+            isVideoTrack = true;
+            break;
+        }
+        else if( MP4_IS_AUDIO_TRACK_TYPE( type ) )
+        {
+            refTrackId = id;
+            break;
+        }
+    }
+
+    return refTrackId;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Return a human readable representation of a <b>MP4ChapterType</b>.
+ *
+ *  @param chapterType the chapter type
+ *  @return a string representing the chapter type
+ */
+string
+ChapterUtility::getChapterTypeName( MP4ChapterType chapterType) const
+{
+    switch( chapterType )
+    {
+    case MP4ChapterTypeQt:
+        return string( "QuickTime" );
+        break;
+
+    case MP4ChapterTypeNero:
+        return string( "Nero" );
+        break;
+
+    case MP4ChapterTypeAny:
+        return string( "QuickTime and Nero" );
+        break;
+
+    default:
+        return string( "Unknown" );
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Read a file into a buffer.
+ *
+ *  This function reads the file named by <b>filename</b> into a buffer allocated
+ *  by malloc and returns the pointer to this buffer in <b>buffer</b> and the size
+ *  of this buffer in <b>fileSize</b>.
+ *
+ *  @param filename  the name of the file.
+ *  @param buffer    receives a pointer to the created buffer
+ *  @param fileSize  reference to a <b>io::StdioFile::Size</b> that receives the size of the file
+ *  @return true if there was an error, false otherwise
+ */
+bool
+ChapterUtility::readChapterFile( const string& filename, char** buffer, File::Size& fileSize )
+{
+    // open the file
+    File in( filename, File::MODE_READ );
+    File::Size nin;
+    if( in.open() ) {
+        return herrf( "opening chapter file '%s' failed: %s\n", filename.c_str(), sys::getLastErrorStr() );
+    }
+
+    // get the file size
+    fileSize = in.size;
+    if( 0 >= fileSize )
+    {
+        in.close();
+        return herrf( "getting size of chapter file '%s' failed: %s\n", filename.c_str(), sys::getLastErrorStr() );
+    }
+
+    // allocate a buffer for the file and read the content
+    char* inBuf = static_cast<char*>( malloc( fileSize+1 ) );
+    if( in.read( inBuf, fileSize, nin ) )
+    {
+        in.close();
+        free(inBuf);
+        return herrf( "reading chapter file '%s' failed: %s\n", filename.c_str(), sys::getLastErrorStr() );
+    }
+    in.close();
+    inBuf[fileSize] = 0;
+
+    *buffer = inBuf;
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Read and parse a chapter file.
+ *
+ *  This function reads and parses a chapter file and returns a vector of
+ *  <b>MP4Chapter_t</b> elements.
+ *
+ *  @param filename the name of the file.
+ *  @param vector   receives a vector of chapters
+ *  @param format   receives the <b>Timecode::Format</b> of the timestamps
+ *  @return true if there was an error, false otherwise
+ */
+bool
+ChapterUtility::parseChapterFile( const string& filename, vector<MP4Chapter_t>& chapters, Timecode::Format& format )
+{
+    // get the content
+    char * inBuf;
+    File::Size fileSize;
+    if( readChapterFile( filename, &inBuf, fileSize ) )
+    {
+        return FAILURE;
+    }
+
+    // separate the text lines
+    char* pos = inBuf;
+    while (pos < inBuf + fileSize)
+    {
+        if (*pos == '\n' || *pos == '\r')
+        {
+            *pos = 0;
+            if (pos > inBuf)
+            {
+                // remove trailing whitespace
+                char* tmp = pos-1;
+                while ((*tmp == ' ' || *tmp == '\t') && tmp > inBuf)
+                {
+                    *tmp = 0;
+                    tmp--;
+                }
+            }
+        }
+        pos++;
+    }
+    pos = inBuf;
+
+    // check for a BOM
+    const unsigned char* uPos = reinterpret_cast<unsigned char*>( pos );
+    if( 0xEF == *uPos && 0xBB == *(uPos+1) && 0xBF == *(uPos+2) )
+    {
+        // UTF-8 (we do not need the BOM)
+        pos += 3;
+    }
+    else if(   ( 0xFE == *uPos && 0xFF == *(uPos+1) )   // UTF-16 big endian
+            || ( 0xFF == *uPos && 0xFE == *(uPos+1) ) ) // UTF-16 little endian
+    {
+        return herrf( "chapter file '%s' has UTF-16 encoding which is not supported (only UTF-8 is allowed)\n",
+                      filename.c_str() );
+    }
+    else if(   ( 0x0 == *uPos && 0x0 == *(uPos+1) && 0xFE == *(uPos+2) && 0xFF == *(uPos+3) )   // UTF-32 big endian
+            || ( 0xFF == *uPos && *(uPos+1) == 0xFE && *(uPos+2) == 0x0 && 0x0 == *(uPos+3) ) ) // UTF-32 little endian
+    {
+        return herrf( "chapter file '%s' has UTF-32 encoding which is not supported (only UTF-8 is allowed)\n",
+                      filename.c_str() );
+    }
+
+    // parse the lines
+    bool failure = false;
+    uint32_t currentChapter = 0;
+    FormatState formatState = FMT_STATE_INITIAL;
+    char* titleStart = 0;
+    uint32_t titleLen = 0;
+    char* timeStart = 0;
+    while( pos < inBuf + fileSize )
+    {
+        if( 0 == *pos || ' ' == *pos || '\t' == *pos )
+        {
+            // uninteresting chars
+            pos++;
+            continue;
+        }
+        else if( '#' == *pos )
+        {
+            // comment line
+            pos += strlen( pos );
+            continue;
+        }
+        else if( isdigit( *pos ) )
+        {
+            // mp4chaps native format: hh:mm:ss.sss <title>
+
+            timeStart = pos;
+
+            // read the title if there is one
+            titleStart = strchr( timeStart, ' ' );
+            if( NULL == titleStart )
+            {
+                titleStart = strchr( timeStart, '\t' );
+            }
+
+            if( NULL != titleStart )
+            {
+                *titleStart = 0;
+                pos = ++titleStart;
+
+                while( ' ' == *titleStart || '\t' == *titleStart )
+                {
+                    titleStart++;
+                }
+
+                titleLen = (uint32_t)strlen( titleStart );
+
+                // advance to the end of the line
+                pos = titleStart + 1 + titleLen;
+            }
+            else
+            {
+                // advance to the end of the line
+                pos += strlen( pos );
+            }
+
+            formatState = FMT_STATE_FINISH;
+        }
+        else if( 0 == strncasecmp( pos, "CHAPTER", 7 ) )
+        {
+            // common format: CHAPTERxx=hh:mm:ss.sss\nCHAPTERxxNAME=<title>
+
+            char* equalsPos = strchr( pos+7, '=' );
+            if( NULL == equalsPos )
+            {
+                herrf( "Unable to parse line \"%s\"\n", pos );
+                failure = true;
+                break;
+            }
+
+            *equalsPos = 0;
+
+            char* tlwr = pos;
+            while( equalsPos != tlwr )
+            {
+                *tlwr = tolower( *tlwr );
+                tlwr++;
+            }
+
+            if( NULL != strstr( pos, "name" ) )
+            {
+                // mark the chapter title
+                uint32_t chNr = 0;
+                sscanf( pos, "chapter%uname", &chNr );
+                if( chNr != currentChapter )
+                {
+                    // different chapter number => different chapter definition pair
+                    if( FMT_STATE_INITIAL != formatState )
+                    {
+                        herrf( "Chapter lines are not consecutive before line \"%s\"\n", pos );
+                        failure = true;
+                        break;
+                    }
+
+                    currentChapter = chNr;
+                }
+                formatState = FMT_STATE_TIME_LINE == formatState ? FMT_STATE_FINISH
+                                                                 : FMT_STATE_TITLE_LINE;
+
+                titleStart = equalsPos + 1;
+                titleLen = (uint32_t)strlen( titleStart );
+
+                // advance to the end of the line
+                pos = titleStart + titleLen;
+            }
+            else
+            {
+                // mark the chapter start time
+                uint32_t chNr = 0;
+                sscanf( pos, "chapter%u", &chNr );
+                if( chNr != currentChapter )
+                {
+                    // different chapter number => different chapter definition pair
+                    if( FMT_STATE_INITIAL != formatState )
+                    {
+                        herrf( "Chapter lines are not consecutive at line \"%s\"\n", pos );
+                        failure = true;
+                        break;
+                    }
+
+                    currentChapter = chNr;
+                }
+                formatState = FMT_STATE_TITLE_LINE == formatState ? FMT_STATE_FINISH 
+                                                                  : FMT_STATE_TIME_LINE;
+
+                timeStart = equalsPos + 1;
+
+                // advance to the end of the line
+                pos = timeStart + strlen( timeStart );
+            }
+        }
+
+        if( FMT_STATE_FINISH == formatState )
+        {
+            // now we have title and start time
+            MP4Chapter_t chap;
+
+            strncpy( chap.title, titleStart, min( titleLen, (uint32_t)MP4V2_CHAPTER_TITLE_MAX ) );
+            chap.title[titleLen] = 0;
+
+            Timecode tc( 0, CHAPTERTIMESCALE );
+            string tm( timeStart );
+            if( tc.parse( tm ) )
+            {
+                herrf( "Unable to parse time code from \"%s\"\n", tm.c_str() );
+                failure = true;
+                break;
+            }
+            chap.duration = tc.duration;
+            format = tc.format;
+
+            // ad the chapter to the list
+            chapters.push_back( chap );
+
+            // re-initialize
+            formatState = FMT_STATE_INITIAL;
+            titleStart = timeStart = NULL;
+            titleLen = 0;
+        }
+    }
+    free( inBuf );
+    if( failure )
+    {
+        return failure;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+/** Convert from frame to millisecond timestamp.
+ *
+ *  This function converts a timestamp from hh:mm:ss:ff to hh:mm:ss.sss
+ *
+ *  @param duration  the timestamp in hours:minutes:seconds:frames.
+ *  @param framerate the frames per second
+ *  @return the timestamp in milliseconds
+ */
+MP4Duration
+ChapterUtility::convertFrameToMillis( MP4Duration duration, uint32_t framerate )
+{
+    Timecode tc( duration, CHAPTERTIMESCALE );
+    if( framerate < tc.subseconds )
+    {
+        uint64_t seconds = tc.subseconds / framerate;
+        tc.setSeconds( tc.seconds + seconds );
+        tc.setSubseconds( (tc.subseconds - (seconds * framerate)) * framerate );
+    }
+    else
+    {
+        tc.setSubseconds( tc.subseconds * framerate );
+    }
+
+    return tc.duration;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+extern "C"
+int main( int argc, char** argv )
+{
+    mp4v2::util::ChapterUtility util( argc, argv );
+    return util.process();
+}
diff --git a/mp4v2/util/mp4extract.cpp b/mp4v2/util/mp4extract.cpp
new file mode 100644
index 0000000..4d7ba0c
--- /dev/null
+++ b/mp4v2/util/mp4extract.cpp
@@ -0,0 +1,255 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie     dmackie@cisco.com
+ */
+
+// N.B. mp4extract just extracts tracks/samples from an mp4 file
+// For many track types this is insufficient to reconsruct a valid
+// elementary stream (ES). Use "mp4creator -extract=<trackId>" if
+// you need the ES reconstructed.
+
+#include "util/impl.h"
+
+using namespace mp4v2::util;
+
+char* ProgName;
+char* Mp4PathName;
+char* Mp4FileName;
+
+// forward declaration
+void ExtractTrack( MP4FileHandle mp4File, MP4TrackId trackId,
+                   bool sampleMode, MP4SampleId sampleId, char* dstFileName = NULL );
+
+extern "C" int main( int argc, char** argv )
+{
+    const char* const usageString =
+        "[-l] [-t <track-id>] [-s <sample-id>] [-v [<level>]] <file-name>";
+    bool doList = false;
+    bool doSamples = false;
+    MP4TrackId trackId = MP4_INVALID_TRACK_ID;
+    MP4SampleId sampleId = MP4_INVALID_SAMPLE_ID;
+    char* dstFileName = NULL;
+    MP4LogLevel verbosity = MP4_LOG_ERROR;
+
+    prog::CommandLine commandLine(argc, argv);
+    commandLine.get(&argc, &argv);
+
+    /* begin processing command line */
+    ProgName = argv[0];
+    while ( true ) {
+        int c = -1;
+        int option_index = 0;
+        static const prog::Option long_options[] = {
+            { "list",    prog::Option::NO_ARG,       0, 'l' },
+            { "track",   prog::Option::REQUIRED_ARG, 0, 't' },
+            { "sample",  prog::Option::OPTIONAL_ARG, 0, 's' },
+            { "verbose", prog::Option::OPTIONAL_ARG, 0, 'v' },
+            { "version", prog::Option::NO_ARG,       0, 'V' },
+            { NULL, prog::Option::NO_ARG, 0, 0 }
+        };
+
+        c = prog::getOptionSingle( argc, argv, "lt:s::v::V", long_options, &option_index );
+
+        if ( c == -1 )
+            break;
+
+        switch ( c ) {
+            case 'l':
+                doList = true;
+                break;
+            case 's':
+                doSamples = true;
+                if ( prog::optarg ) {
+                    if ( sscanf( prog::optarg, "%u", &sampleId ) != 1 ) {
+                        fprintf( stderr,
+                                 "%s: bad sample-id specified: %s\n",
+                                 ProgName, prog::optarg );
+                    }
+                }
+                break;
+            case 't':
+                if ( sscanf( prog::optarg, "%u", &trackId ) != 1 ) {
+                    fprintf( stderr,
+                             "%s: bad track-id specified: %s\n",
+                             ProgName, prog::optarg );
+                    exit( 1 );
+                }
+                break;
+            case 'v':
+                verbosity = MP4_LOG_VERBOSE1;
+                if ( prog::optarg ) {
+                    uint32_t level;
+                    if ( sscanf( prog::optarg, "%u", &level ) == 1 ) {
+                        if ( level >= 2 ) {
+                            verbosity = MP4_LOG_VERBOSE2;
+                        }
+                        if ( level >= 3 ) {
+                            verbosity = MP4_LOG_VERBOSE3;
+                        }
+                        if ( level >= 4 ) {
+                            verbosity = MP4_LOG_VERBOSE4;
+                        }
+                    }
+                }
+                break;
+            case '?':
+                fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+                exit( 0 );
+            case 'V':
+                fprintf( stderr, "%s - %s\n", ProgName, MP4V2_PROJECT_name_formal );
+                exit( 0 );
+            default:
+                fprintf( stderr, "%s: unknown option specified, ignoring: %c\n",
+                         ProgName, c );
+        }
+    }
+
+    /* check that we have at least one non-option argument */
+    if ( ( argc - prog::optind ) < 1 ) {
+        fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+        exit( 1 );
+    }
+
+    MP4LogSetLevel(verbosity);
+    if ( verbosity ) {
+        fprintf( stderr, "%s version %s\n", ProgName, MP4V2_PROJECT_version );
+    }
+
+    /* point to the specified file names */
+    Mp4PathName = argv[prog::optind++];
+
+    /* get dest file name for a single track */
+    if ( trackId && ( argc - prog::optind ) > 0 ) {
+        dstFileName = argv[prog::optind++];
+    }
+
+    char* lastSlash = strrchr( Mp4PathName, '/' );
+    if ( lastSlash ) {
+        Mp4FileName = lastSlash + 1;
+    }
+    else {
+        Mp4FileName = Mp4PathName;
+    }
+
+    /* warn about extraneous non-option arguments */
+    if ( prog::optind < argc ) {
+        fprintf( stderr, "%s: unknown options specified, ignoring: ", ProgName );
+        while ( prog::optind < argc ) {
+            fprintf( stderr, "%s ", argv[prog::optind++] );
+        }
+        fprintf( stderr, "\n" );
+    }
+
+    /* end processing of command line */
+
+
+    MP4FileHandle mp4File = MP4Read( Mp4PathName );
+
+    if ( !mp4File ) {
+        exit( 1 );
+    }
+
+    if ( doList ) {
+        MP4Info( mp4File );
+        exit( 0 );
+    }
+
+    if ( trackId == 0 ) {
+        uint32_t numTracks = MP4GetNumberOfTracks( mp4File );
+
+        for ( uint32_t i = 0; i < numTracks; i++ ) {
+            trackId = MP4FindTrackId( mp4File, i );
+            ExtractTrack( mp4File, trackId, doSamples, sampleId );
+        }
+    }
+    else {
+        ExtractTrack( mp4File, trackId, doSamples, sampleId, dstFileName );
+    }
+
+    MP4Close( mp4File );
+
+    return( 0 );
+}
+
+void ExtractTrack( MP4FileHandle mp4File, MP4TrackId trackId,
+                   bool sampleMode, MP4SampleId sampleId, char* dstFileName )
+{
+    static string outName;
+    File out;
+
+    if( !sampleMode ) {
+        if( !dstFileName ) {
+            stringstream ss;
+            ss << Mp4FileName << ".t" << trackId;
+            outName = ss.str();
+        } else {
+            outName = dstFileName;
+        }
+
+        if( out.open( outName.c_str(), File::MODE_CREATE )) {
+            fprintf( stderr, "%s: can't open %s: %s\n", ProgName, outName.c_str(), sys::getLastErrorStr() );
+            return;
+        }
+    }
+
+    MP4SampleId numSamples;
+
+    if ( sampleMode && sampleId != MP4_INVALID_SAMPLE_ID ) {
+        numSamples = sampleId;
+    }
+    else {
+        sampleId = 1;
+        numSamples = MP4GetTrackNumberOfSamples( mp4File, trackId );
+    }
+
+    for ( ; sampleId <= numSamples; sampleId++ ) {
+        // signals to ReadSample() that it should malloc a buffer for us
+        uint8_t* pSample = NULL;
+        uint32_t sampleSize = 0;
+
+        if( !MP4ReadSample( mp4File, trackId, sampleId, &pSample, &sampleSize )) {
+            fprintf( stderr, "%s: read sample %u for %s failed\n", ProgName, sampleId, outName.c_str() );
+            break;
+        }
+
+        if ( sampleMode ) {
+            stringstream ss;
+            ss << Mp4FileName << ".t" << trackId << ".s" << sampleId;
+            outName = ss.str();
+
+            if( out.open( outName.c_str(), File::MODE_CREATE )) {
+                fprintf( stderr, "%s: can't open %s: %s\n", ProgName, outName.c_str(), sys::getLastErrorStr() );
+                break;
+            }
+        }
+
+        File::Size nout;
+        if( out.write( pSample, sampleSize, nout )) {
+            fprintf( stderr, "%s: write to %s failed: %s\n", ProgName, outName.c_str(), sys::getLastErrorStr() );
+            break;
+        }
+
+        free( pSample );
+
+        if( sampleMode )
+            out.close();
+    }
+
+    out.close();
+}
diff --git a/mp4v2/util/mp4file.cpp b/mp4v2/util/mp4file.cpp
new file mode 100644
index 0000000..087e452
--- /dev/null
+++ b/mp4v2/util/mp4file.cpp
@@ -0,0 +1,224 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  Portions created by David Byron are Copyright (C) 2010.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//      David Byron, dbyron@dbyron.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+class FileUtility : public Utility
+{
+private:
+    enum FileLongCode {
+        LC_LIST = _LC_MAX,
+        LC_OPTIMIZE,
+        LC_DUMP
+    };
+
+public:
+    FileUtility( int, char** );
+
+protected:
+    // delegates implementation
+    bool utility_option( int, bool& );
+    bool utility_job( JobContext& );
+
+private:
+    bool actionList     ( JobContext& );
+    bool actionOptimize ( JobContext& );
+    bool actionDump     ( JobContext& );
+
+private:
+    Group _actionGroup;
+
+    bool (FileUtility::*_action)( JobContext& );
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+FileUtility::FileUtility( int argc, char** argv )
+    : Utility      ( "mp4file", argc, argv )
+    , _actionGroup ( "ACTIONS" )
+    , _action      ( NULL )
+{
+    // add standard options which make sense for this utility
+    _group.add( STD_DRYRUN );
+    _group.add( STD_KEEPGOING );
+    _group.add( STD_QUIET );
+    _group.add( STD_DEBUG );
+    _group.add( STD_VERBOSE );
+    _group.add( STD_HELP );
+    _group.add( STD_VERSION );
+    _group.add( STD_VERSIONX );
+
+    _actionGroup.add( "list",     false, LC_LIST,     "list (summary information)" );
+    _actionGroup.add( "optimize", false, LC_OPTIMIZE, "optimize mp4 structure" );
+    _actionGroup.add( "dump",     false, LC_DUMP,     "dump mp4 structure in human-readable format" );
+    _groups.push_back( &_actionGroup );
+
+    _usage = "[OPTION]... ACTION file...";
+    _description =
+        // 79-cols, inclusive, max desired width
+        // |----------------------------------------------------------------------------|
+        "\nFor each mp4 file specified, perform the specified ACTION. An action must be"
+        "\nspecified. Some options are not applicable to some actions.";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+FileUtility::actionDump( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    if( !MP4Dump( job.fileHandle, _debugImplicits ))
+        return herrf( "dump failed: %s\n", job.file.c_str() );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+FileUtility::actionList( JobContext& job )
+{
+    ostringstream report;
+
+    const int wbrand = 5;
+    const int wcompat = 18;
+    const int wsizing = 6;
+    const string sep = "  ";
+
+    if( _jobCount == 0 ) {
+        report << setw(wbrand) << left << "BRAND" 
+               << sep << setw(wcompat) << left << "COMPAT" 
+               << sep << setw(wsizing) << left << "SIZING" 
+               << sep << setw(0) << "FILE"
+               << '\n';
+
+        report << setfill('-') << setw(70) << "" << setfill(' ') << '\n';
+    }
+
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    FileSummaryInfo info;
+    if( fileFetchSummaryInfo( job.fileHandle, info ))
+        return herrf( "unable to fetch file summary info" );
+
+    string compat;
+    {
+        const FileSummaryInfo::BrandSet::iterator ie = info.compatible_brands.end();
+        int count = 0;
+        for( FileSummaryInfo::BrandSet::iterator it = info.compatible_brands.begin(); it != ie; ++it, count++ ) {
+            if( count > 0 )
+                compat += ',';
+            compat += *it;
+        }
+    }
+
+    const bool sizing = info.nlargesize | info.nversion1 | info.nspecial;
+
+    report << setw(wbrand) << left << info.major_brand
+           << sep << setw(wcompat) << left << compat
+           << sep << setw(wsizing) << left << (sizing ? "64-bit" : "32-bit")
+           << sep << job.file
+           << '\n';
+
+    verbose1f( "%s", report.str().c_str() );
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+FileUtility::actionOptimize( JobContext& job )
+{
+    verbose1f( "optimizing %s\n", job.file.c_str() );
+
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    if( !MP4Optimize( job.file.c_str(), NULL ))
+        return herrf( "optimize failed: %s\n", job.file.c_str() );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+FileUtility::utility_job( JobContext& job )
+{
+    if( !_action )
+        return herrf( "no action specified\n" );
+
+    return (this->*_action)( job );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+FileUtility::utility_option( int code, bool& handled )
+{
+    handled = true;
+
+    switch( code ) {
+        case LC_LIST:
+            _action = &FileUtility::actionList;
+            break;
+
+        case LC_OPTIMIZE:
+            _action = &FileUtility::actionOptimize;
+            break;
+
+        case LC_DUMP:
+            _action = &FileUtility::actionDump;
+            break;
+
+        default:
+            handled = false;
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+extern "C"
+int main( int argc, char** argv )
+{
+    mp4v2::util::FileUtility util( argc, argv );
+    return util.process();
+}
diff --git a/mp4v2/util/mp4info.cpp b/mp4v2/util/mp4info.cpp
new file mode 100644
index 0000000..864c21b
--- /dev/null
+++ b/mp4v2/util/mp4info.cpp
@@ -0,0 +1,252 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001-2002.  All Rights Reserved.
+ *
+ * Portions created by Rouven Wessling are
+ * Copyright (C) 2008-2009. All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie     dmackie@cisco.com
+ *      Rouven Wessling mp4v2@rouvenwessling.de
+ */
+
+#include "util/impl.h"
+
+using namespace mp4v2::util;
+
+extern "C" int main( int argc, char** argv )
+{
+    const char* const usageString =
+        "<file-name>";
+
+    prog::CommandLine commandLine(argc, argv);
+    commandLine.get(&argc, &argv);
+
+    /* begin processing command line */
+    char* ProgName = argv[0];
+    while ( true ) {
+        int c = -1;
+        int option_index = 0;
+        static const prog::Option long_options[] = {
+            { "version", prog::Option::NO_ARG, 0, 'V' },
+            { NULL, prog::Option::NO_ARG, 0, 0 }
+        };
+
+        c = prog::getOptionSingle( argc, argv, "V", long_options, &option_index );
+
+        if ( c == -1 )
+            break;
+
+        switch ( c ) {
+            case '?':
+                fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+                exit( 0 );
+            case 'V':
+                fprintf( stderr, "%s - %s\n", ProgName, MP4V2_PROJECT_name_formal );
+                exit( 0 );
+            default:
+                fprintf( stderr, "%s: unknown option specified, ignoring: %c\n",
+                         ProgName, c );
+        }
+    }
+
+    /* check that we have at least one non-option argument */
+    if ( ( argc - prog::optind ) < 1 ) {
+        fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+        exit( 1 );
+    }
+
+    /* end processing of command line */
+    printf( "%s version %s\n", ProgName, MP4V2_PROJECT_version );
+
+    while ( prog::optind < argc ) {
+        char *mp4FileName = argv[prog::optind++];
+
+        printf( "%s:\n", mp4FileName );
+
+        char* info = MP4FileInfo( mp4FileName );
+
+        if ( !info ) {
+            fprintf( stderr,
+                     "%s: can't open %s\n",
+                     ProgName, mp4FileName );
+            continue;
+        }
+
+        fputs( info, stdout );
+        MP4FileHandle mp4file = MP4Read( mp4FileName ); //, MP4_DETAILS_ERROR);
+        if ( mp4file != MP4_INVALID_FILE_HANDLE ) {
+            const MP4Tags* tags = MP4TagsAlloc();
+            MP4TagsFetch( tags, mp4file );
+            if ( tags->name ) {
+                fprintf( stdout, " Name: %s\n", tags->name );
+            }
+            if ( tags->sortName ) {
+                fprintf( stdout, " Sort Name: %s\n", tags->sortName );
+            }
+            if ( tags->artist ) {
+                fprintf( stdout, " Artist: %s\n", tags->artist );
+            }
+            if ( tags->sortArtist ) {
+                fprintf( stdout, " Sort Artist: %s\n", tags->sortArtist );
+            }
+            if ( tags->composer ) {
+                fprintf( stdout, " Composer: %s\n", tags->composer );
+            }
+            if ( tags->sortComposer ) {
+                fprintf( stdout, " Sort Composer: %s\n", tags->sortComposer );
+            }
+            if ( tags->encodingTool ) {
+                fprintf( stdout, " Encoded with: %s\n", tags->encodingTool );
+            }
+            if ( tags->encodedBy ) {
+                fprintf( stdout, " Encoded by: %s\n", tags->encodedBy );
+            }
+            if ( tags->releaseDate ) {
+                fprintf( stdout, " Release Date: %s\n", tags->releaseDate );
+            }
+            if ( tags->album ) {
+                fprintf( stdout, " Album: %s\n", tags->album );
+            }
+            if ( tags->sortAlbum ) {
+                fprintf( stdout, " Sort Album: %s\n", tags->sortAlbum );
+            }
+            if ( tags->track ) {
+                fprintf( stdout, " Track: %u of %u\n", tags->track->index, tags->track->total );
+            }
+            if ( tags->disk ) {
+                fprintf( stdout, " Disk: %u of %u\n", tags->disk->index, tags->disk->total );
+            }
+            if ( tags->genre ) {
+                fprintf( stdout, " Genre: %s\n", tags->genre );
+            }
+            if ( tags->genreType ) {
+                string s = itmf::enumGenreType.toString(static_cast<itmf::GenreType>(*tags->genreType ), true);
+                fprintf( stdout, " GenreType: %u, %s\n", *tags->genreType, s.c_str() );
+            }
+            if ( tags->grouping ) {
+                fprintf( stdout, " Grouping: %s\n", tags->grouping );
+            }
+            if ( tags->tempo ) {
+                fprintf( stdout, " BPM: %u\n", *tags->tempo );
+            }
+            if ( tags->comments ) {
+                fprintf( stdout, " Comments: %s\n", tags->comments );
+            }
+            if ( tags->compilation ) {
+                fprintf( stdout, " Part of Compilation: %s\n", *tags->compilation ? "yes" : "no" );
+            }
+            if ( tags->gapless ) {
+                fprintf( stdout, " Part of Gapless Album: %s\n", *tags->gapless ? "yes" : "no" );
+            }
+            if ( tags->artworkCount ) {
+                fprintf( stdout, " Cover Art pieces: %u\n", tags->artworkCount );
+            }
+            if ( tags->albumArtist ) {
+                fprintf( stdout, " Album Artist: %s\n", tags->albumArtist );
+            }
+            if ( tags->sortAlbumArtist ) {
+                fprintf( stdout, " Sort Album Artist: %s\n", tags->sortAlbumArtist );
+            }
+            if ( tags->copyright ) {
+                fprintf( stdout, " Copyright: %s\n", tags->copyright );
+            }
+            if ( tags->contentRating ) {
+                string s = itmf::enumContentRating.toString( static_cast<itmf::ContentRating>( *tags->contentRating ), true );
+                fprintf( stdout, " Content Rating: %s\n", s.c_str() );
+            }
+            if ( tags->hdVideo ) {
+                fprintf( stdout, " HD Video: %s\n", *tags->hdVideo ? "yes" : "no");
+            }
+            if ( tags->mediaType ) {
+                string s = itmf::enumStikType.toString( static_cast<itmf::StikType>( *tags->mediaType ), true );
+                fprintf( stdout, " Media Type: %s\n", s.c_str() );
+            }
+            if ( tags->tvShow ) {
+                fprintf( stdout, " TV Show: %s\n", tags->tvShow );
+            }
+            if ( tags->sortTVShow ) {
+                fprintf( stdout, " Sort TV Show: %s\n", tags->sortTVShow );
+            }
+            if ( tags->tvNetwork ) {
+                fprintf( stdout, " TV Network: %s\n", tags->tvNetwork );
+            }
+            if ( tags->tvEpisodeID ) {
+                fprintf( stdout, " TV Episode Number: %s\n", tags->tvEpisodeID );
+            }
+            if ( tags->description ) {
+                fprintf( stdout, " Short Description: %s\n", tags->description );
+            }
+            if ( tags->longDescription ) {
+                fprintf( stdout, " Long Description: %s\n", tags->longDescription );
+            }
+            if ( tags->lyrics ) {
+                fprintf( stdout, " Lyrics: \n %s\n", tags->lyrics );
+            }
+            if ( tags->tvEpisode ) {
+                fprintf( stdout, " TV Episode: %u\n", *tags->tvEpisode );
+            }
+            if ( tags->tvSeason ) {
+                fprintf( stdout, " TV Season: %u\n", *tags->tvSeason );
+            }
+            if ( tags->podcast) {
+                fprintf( stdout, " Podcast: %s\n", *tags->podcast ? "yes" : "no" );
+            }
+            if ( tags->keywords ) {
+                fprintf( stdout, " Keywords: %s\n", tags->keywords );
+            }
+            if ( tags->category ) {
+                fprintf( stdout, " Category: %s\n", tags->category );
+            }
+            if ( tags->contentID ) {
+                fprintf( stdout, " Content ID: %u\n", *tags->contentID );
+            }
+            if ( tags->artistID ) {
+                fprintf( stdout, " Artist ID: %u\n", *tags->artistID );
+            }
+            if ( tags->playlistID ) {
+                fprintf( stdout, " Playlist ID: %" PRIu64 "\n", *tags->playlistID );
+            }
+            if ( tags->genreID ) {
+                fprintf( stdout, " Genre ID: %u\n", *tags->genreID );
+            }
+            if ( tags->composerID ) {
+                fprintf( stdout, " Composer ID: %u\n", *tags->composerID );
+            }
+            if ( tags->xid ) {
+                fprintf( stdout, " xid: %s\n", tags->xid );
+            }
+            if ( tags->iTunesAccount ) {
+                fprintf( stdout, " iTunes Account: %s\n", tags->iTunesAccount );
+            }
+            if ( tags->iTunesAccountType ) {
+                string s = itmf::enumAccountType.toString( static_cast<itmf::AccountType>( *tags->iTunesAccountType ), true );
+                fprintf( stdout, " iTunes Account Type: %s\n", s.c_str() );
+            }
+            if ( tags->purchaseDate ) {
+                fprintf( stdout, " Purchase Date: %s\n", tags->purchaseDate );
+            }
+            if ( tags->iTunesCountry ) {
+                string s = itmf::enumCountryCode.toString( static_cast<itmf::CountryCode>( *tags->iTunesCountry ), true );
+                fprintf( stdout, " iTunes Store Country: %s\n", s.c_str() );
+            }
+            MP4TagsFree( tags );
+            MP4Close( mp4file );
+        }
+        free( info );
+    }
+    return( 0 );
+}
diff --git a/mp4v2/util/mp4subtitle.cpp b/mp4v2/util/mp4subtitle.cpp
new file mode 100644
index 0000000..f0b552b
--- /dev/null
+++ b/mp4v2/util/mp4subtitle.cpp
@@ -0,0 +1,209 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//      Edward Groenendaal, egroenen@@cisco.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+class SubtitleUtility : public Utility
+{
+private:
+    enum SubtitleLongCode {
+        LC_LIST = _LC_MAX,
+        LC_EXPORT,
+        LC_IMPORT,
+        LC_REMOVE
+    };
+
+public:
+    SubtitleUtility( int, char** );
+
+protected:
+    // delegates implementation
+    bool utility_option( int, bool& );
+    bool utility_job( JobContext& );
+
+private:
+    bool actionList   ( JobContext& );
+    bool actionExport ( JobContext& );
+    bool actionImport ( JobContext& );
+    bool actionRemove ( JobContext& );
+
+private:
+    Group  _actionGroup;
+
+    bool (SubtitleUtility::*_action)( JobContext& );
+
+    string _stTextFile;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+SubtitleUtility::SubtitleUtility( int argc, char** argv )
+    : Utility      ( "mp4subtitle", argc, argv )
+    , _actionGroup ( "ACTIONS" )
+    , _action      ( NULL )
+{
+    // add standard options which make sense for this utility
+    _group.add( STD_OPTIMIZE );
+    _group.add( STD_DRYRUN );
+    _group.add( STD_KEEPGOING );
+    _group.add( STD_OVERWRITE );
+    _group.add( STD_FORCE );
+    _group.add( STD_QUIET );
+    _group.add( STD_DEBUG );
+    _group.add( STD_VERBOSE );
+    _group.add( STD_HELP );
+    _group.add( STD_VERSION );
+    _group.add( STD_VERSIONX );
+
+    _actionGroup.add( "list",   false, LC_LIST,   "list available subtitles" );
+    _actionGroup.add( "export", true,  LC_EXPORT, "export subtitles to TXT", "TXT" );
+    _actionGroup.add( "import", true,  LC_IMPORT, "import subtitles from TXT", "TXT" );
+    _actionGroup.add( "remove", false, LC_REMOVE, "remove all subtitles" );
+    _groups.push_back( &_actionGroup );
+
+    _usage = "[OPTION]... ACTION file...";
+    _description =
+        // 79-cols, inclusive, max desired width
+        // |----------------------------------------------------------------------------|
+        "\nFor each mp4 file specified, perform the specified ACTION. An action must be"
+        "\nspecified. Some options are not applicable to some actions.";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::actionExport( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    verbose1f( "NOT IMPLEMENTED\n" );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::actionImport( JobContext& job )
+{
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    verbose1f( "NOT IMPLEMENTED\n" );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::actionList( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    verbose1f( "NOT IMPLEMENTED\n" );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::actionRemove( JobContext& job )
+{
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    verbose1f( "NOT IMPLEMENTED" );
+    return FAILURE;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::utility_job( JobContext& job )
+{
+    if( !_action )
+        return herrf( "no action specified\n" );
+
+    return (this->*_action)( job );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+SubtitleUtility::utility_option( int code, bool& handled )
+{
+    handled = true;
+
+    switch( code ) {
+        case LC_LIST:
+            _action = &SubtitleUtility::actionList;
+            break;
+
+        case LC_EXPORT:
+            _action = &SubtitleUtility::actionExport;
+            _stTextFile = prog::optarg;
+            if( _stTextFile.empty() )
+                return herrf( "invalid TXT file: empty-string\n" );
+            break;
+
+        case LC_IMPORT:
+            _action = &SubtitleUtility::actionImport;
+            _stTextFile = prog::optarg;
+            if( _stTextFile.empty() )
+                return herrf( "invalid TXT file: empty-string\n" );
+            break;
+
+        case LC_REMOVE:
+            _action = &SubtitleUtility::actionRemove;
+            break;
+
+        default:
+            handled = false;
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+extern "C"
+int main( int argc, char** argv )
+{
+    mp4v2::util::SubtitleUtility util( argc, argv );
+    return util.process();
+}
diff --git a/mp4v2/util/mp4tags.cpp b/mp4v2/util/mp4tags.cpp
new file mode 100644
index 0000000..cdd6f0d
--- /dev/null
+++ b/mp4v2/util/mp4tags.cpp
@@ -0,0 +1,692 @@
+/* mp4tags -- tool to set iTunes-compatible metadata tags
+ *
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * Contributed to MPEG4IP
+ * by Christopher League <league@contrapunctus.net>
+ */
+
+#include "util/impl.h"
+
+using namespace mp4v2::util;
+
+///////////////////////////////////////////////////////////////////////////////
+
+/* One-letter options -- if you want to rearrange these, change them
+   here, immediately below in OPT_STRING, and in the help text. */
+enum Option {
+    OPT_HELP              = 0x0100,
+    OPT_VERSION           = 0x0101,
+    OPT_REMOVE            = 'r',
+    OPT_ALBUM             = 'A',
+    OPT_ARTIST            = 'a',
+    OPT_TEMPO             = 'b',
+    OPT_COMMENT           = 'c',
+    OPT_COPYRIGHT         = 'C',
+    OPT_DISK              = 'd',
+    OPT_DISKS             = 'D',
+    OPT_ENCODEDBY         = 'e',
+    OPT_TOOL              = 'E',
+    OPT_GENRE             = 'g',
+    OPT_GROUPING          = 'G',
+    OPT_HD                = 'H',
+    OPT_MEDIA_TYPE        = 'i',
+    OPT_CONTENTID         = 'I',
+    OPT_LONGDESC          = 'l',
+    OPT_GENREID           = 'j',
+    OPT_LYRICS            = 'L',
+    OPT_DESCRIPTION       = 'm',
+    OPT_TVEPISODE         = 'M',
+    OPT_TVSEASON          = 'n',
+    OPT_TVNETWORK         = 'N',
+    OPT_TVEPISODEID       = 'o',
+    OPT_CATEGORY          = 'O',
+    OPT_PLAYLISTID        = 'p',
+    OPT_PICTURE           = 'P',
+    OPT_PODCAST           = 'B',
+    OPT_ALBUM_ARTIST      = 'R',
+    OPT_NAME              = 's',
+    OPT_TVSHOW            = 'S',
+    OPT_TRACK             = 't',
+    OPT_TRACKS            = 'T',
+    OPT_XID               = 'x',
+    OPT_RATING            = 'X',
+    OPT_COMPOSER          = 'w',
+    OPT_RELEASEDATE       = 'y',
+    OPT_ARTISTID          = 'z',
+    OPT_COMPOSERID        = 'Z',
+    OPT_SORT_NAME         = 0x0102,
+    OPT_SORT_ARTIST       = 0x0103,
+    OPT_SORT_ALBUM_ARTIST = 0x0104,
+    OPT_SORT_ALBUM        = 0x0105,
+    OPT_SORT_COMPOSER     = 0x0106,
+    OPT_SORT_TV_SHOW      = 0x0107,
+    OPT_PURCHASE_DATE     = 0x0108,
+
+    MAX_OPT
+};
+
+#define OPT_STRING  "r:A:a:b:c:C:d:D:e:E:g:G:H:i:I:j:l:L:m:M:n:N:o:O:p:P:B:R:s:S:t:T:x:X:w:y:z:Z:"
+
+#define ELEMENT_OF(x,i) x[int(i)]
+
+static const char* const help_text =
+    "OPTION... FILE...\n"
+    "Adds or modifies iTunes-compatible tags on MP4 files.\n"
+    "\n"
+    "      -help                 Display this help text and exit\n"
+    "      -version              Display version information and exit\n"
+    "  -A, -album           STR  Set the album title\n"
+    "  -a, -artist          STR  Set the artist information\n"
+    "  -b, -tempo           NUM  Set the tempo (beats per minute)\n"
+    "  -c, -comment         STR  Set a general comment\n"
+    "  -C, -copyright       STR  Set the copyright information\n"
+    "  -d, -disk            NUM  Set the disk number\n"
+    "  -D, -disks           NUM  Set the number of disks\n"
+    "  -e, -encodedby       STR  Set the name of the person or company who encoded\n"
+    "                            the file\n"
+    "  -E, -tool            STR  Set the software used for encoding\n"
+    "  -g, -genre           STR  Set the genre name\n"
+    "  -G, -grouping        STR  Set the grouping name\n"
+    "  -H, -hdvideo         NUM  Set the HD flag (0/1)\n"
+    "  -i, -type            STR  Set the Media Type(tvshow, movie, music, ...)\n"
+    "  -I, -contentid       NUM  Set the content ID\n"
+    "  -j, -genreid         NUM  Set the genre ID\n"
+    "  -l, -longdesc        STR  Set the long description\n"
+    "  -L, -lyrics          NUM  Set the lyrics\n"
+    "  -m, -description     STR  Set the short description\n"
+    "  -M, -episode         NUM  Set the episode number\n"
+    "  -n, -season          NUM  Set the season number\n"
+    "  -N, -network         STR  Set the TV network\n"
+    "  -o, -episodeid       STR  Set the TV episode ID\n"
+    "  -O, -category        STR  Set the category\n"
+    "  -p, -playlistid      NUM  Set the playlist ID\n"
+    "  -P, -picture         PTH  Set the picture as a .png\n"
+    "  -B, -podcast         NUM  Set the podcast flag.\n"
+    "  -R, -albumartist     STR  Set the album artist\n"
+    "  -s, -song            STR  Set the song title\n"
+    "  -S  -show            STR  Set the TV show\n"
+    "  -t, -track           NUM  Set the track number\n"
+    "  -T, -tracks          NUM  Set the number of tracks\n"
+    "  -x, -xid             STR  Set the globally-unique xid (vendor:scheme:id)\n"
+    "  -X, -rating          STR  Set the Rating(none, clean, explicit)\n"
+    "  -w, -writer          STR  Set the composer information\n"
+    "  -y, -year            NUM  Set the release date\n"
+    "  -z, -artistid        NUM  Set the artist ID\n"
+    "  -Z, -composerid      NUM  Set the composer ID\n"
+    "      -sortname        STR  Set the sort name\n"
+    "      -sortartist      STR  Set the sort artist\n"
+    "      -sortalbum       STR  Set the sort album\n"
+    "      -sorttvshow      STR  Set the sort tv show\n"
+    "      -sortalbumartist STR  Set the sort album artist\n"
+    "      -sortcomposer    STR  Set the sort composer\n"
+    "      -purchasedate    STR  Set the purchase date\n"
+    "  -r, -remove          STR  Remove tags by code (e.g. \"-r comment,song\" or\n"
+    "                            \"-r cs\" removes the comment and song tags)";
+
+extern "C" int
+    main( int argc, char** argv )
+{
+    const prog::Option long_options[] = {
+        { "help",            prog::Option::NO_ARG,       0, OPT_HELP              },
+        { "version",         prog::Option::NO_ARG,       0, OPT_VERSION           },
+        { "album",           prog::Option::REQUIRED_ARG, 0, OPT_ALBUM             },
+        { "artist",          prog::Option::REQUIRED_ARG, 0, OPT_ARTIST            },
+        { "comment",         prog::Option::REQUIRED_ARG, 0, OPT_COMMENT           },
+        { "copyright",       prog::Option::REQUIRED_ARG, 0, OPT_COPYRIGHT         },
+        { "disk",            prog::Option::REQUIRED_ARG, 0, OPT_DISK              },
+        { "disks",           prog::Option::REQUIRED_ARG, 0, OPT_DISKS             },
+        { "encodedby",       prog::Option::REQUIRED_ARG, 0, OPT_ENCODEDBY         },
+        { "tool",            prog::Option::REQUIRED_ARG, 0, OPT_TOOL              },
+        { "genre",           prog::Option::REQUIRED_ARG, 0, OPT_GENRE             },
+        { "grouping",        prog::Option::REQUIRED_ARG, 0, OPT_GROUPING          },
+        { "hdvideo",         prog::Option::REQUIRED_ARG, 0, OPT_HD                },
+        { "type",            prog::Option::REQUIRED_ARG, 0, OPT_MEDIA_TYPE        },
+        { "contentid",       prog::Option::REQUIRED_ARG, 0, OPT_CONTENTID         },
+        { "longdesc",        prog::Option::REQUIRED_ARG, 0, OPT_LONGDESC          },
+        { "genreid",         prog::Option::REQUIRED_ARG, 0, OPT_GENREID           },
+        { "lyrics",          prog::Option::REQUIRED_ARG, 0, OPT_LYRICS            },
+        { "description",     prog::Option::REQUIRED_ARG, 0, OPT_DESCRIPTION       },
+        { "episode",         prog::Option::REQUIRED_ARG, 0, OPT_TVEPISODE         },
+        { "season",          prog::Option::REQUIRED_ARG, 0, OPT_TVSEASON          },
+        { "network",         prog::Option::REQUIRED_ARG, 0, OPT_TVNETWORK         },
+        { "episodeid",       prog::Option::REQUIRED_ARG, 0, OPT_TVEPISODEID       },
+        { "playlistid",      prog::Option::REQUIRED_ARG, 0, OPT_PLAYLISTID        },
+        { "picture",         prog::Option::REQUIRED_ARG, 0, OPT_PICTURE           },
+        { "podcast",         prog::Option::REQUIRED_ARG, 0, OPT_PODCAST           },
+        { "song",            prog::Option::REQUIRED_ARG, 0, OPT_NAME              },
+        { "show",            prog::Option::REQUIRED_ARG, 0, OPT_TVSHOW            },
+        { "tempo",           prog::Option::REQUIRED_ARG, 0, OPT_TEMPO             },
+        { "track",           prog::Option::REQUIRED_ARG, 0, OPT_TRACK             },
+        { "tracks",          prog::Option::REQUIRED_ARG, 0, OPT_TRACKS            },
+        { "xid",             prog::Option::REQUIRED_ARG, 0, OPT_XID               },
+        { "writer",          prog::Option::REQUIRED_ARG, 0, OPT_COMPOSER          },
+        { "year",            prog::Option::REQUIRED_ARG, 0, OPT_RELEASEDATE       },
+        { "artistid",        prog::Option::REQUIRED_ARG, 0, OPT_ARTISTID          },
+        { "composerid",      prog::Option::REQUIRED_ARG, 0, OPT_COMPOSERID        },
+        { "albumartist",     prog::Option::REQUIRED_ARG, 0, OPT_ALBUM_ARTIST      },
+        { "category",        prog::Option::REQUIRED_ARG, 0, OPT_CATEGORY          },
+        { "rating",          prog::Option::REQUIRED_ARG, 0, OPT_RATING            },
+        { "sortname",        prog::Option::REQUIRED_ARG, 0, OPT_SORT_NAME         },
+        { "sortartist",      prog::Option::REQUIRED_ARG, 0, OPT_SORT_ARTIST       },
+        { "sortalbum",       prog::Option::REQUIRED_ARG, 0, OPT_SORT_ALBUM        },
+        { "sorttvshow",      prog::Option::REQUIRED_ARG, 0, OPT_SORT_TV_SHOW      },
+        { "sortalbumartist", prog::Option::REQUIRED_ARG, 0, OPT_SORT_ALBUM_ARTIST },
+        { "sortcomposer",    prog::Option::REQUIRED_ARG, 0, OPT_SORT_COMPOSER     },
+        { "purchasedate",    prog::Option::REQUIRED_ARG, 0, OPT_PURCHASE_DATE     },
+        { "remove",          prog::Option::REQUIRED_ARG, 0, OPT_REMOVE            },
+        { NULL, prog::Option::NO_ARG, 0, 0 }
+    };
+
+    /* Sparse arrays of tag data: some space is wasted, but it's more
+       convenient to say tags[OPT_SONG] than to enumerate all the
+       metadata types (again) as a struct. */
+    const char *tags[MAX_OPT];
+    uint64_t nums[MAX_OPT];
+
+    memset( tags, 0, sizeof( tags ) );
+    memset( nums, 0, sizeof( nums ) );
+
+    /* Any modifications requested? */
+    int mods = 0;
+
+    prog::CommandLine commandLine(argc, argv);
+    commandLine.get(&argc, &argv);
+
+    /* Option-processing loop. */
+    int c = prog::getOptionSingle( argc, argv, OPT_STRING, long_options, NULL );
+    while ( c != -1 ) {
+        int r = 2;
+        switch ( c ) {
+                /* getopt() returns '?' if there was an error.  It already
+                   printed the error message, so just return. */
+            case '?':
+                return 1;
+
+                /* Help and version requests handled here. */
+            case OPT_HELP:
+                fprintf( stdout, "Usage: %s %s\n", "mp4tags", help_text );
+                return 0;
+            case OPT_VERSION:
+                fprintf( stdout, "%s - %s\n", "mp4tags", MP4V2_PROJECT_name_formal );
+                return 0;
+
+                /* Integer arguments: convert them using sscanf(). */
+            case OPT_TEMPO:
+            case OPT_DISK:
+            case OPT_DISKS:
+            case OPT_HD:
+            case OPT_CONTENTID:
+            case OPT_GENREID:
+            case OPT_TVEPISODE:
+            case OPT_TVSEASON:
+            case OPT_PLAYLISTID:
+            case OPT_TRACK:
+            case OPT_TRACKS:
+            case OPT_ARTISTID:
+            case OPT_COMPOSERID:
+            case OPT_PODCAST:
+                if ( c == OPT_PLAYLISTID ) {
+                    r = sscanf( prog::optarg, "%" PRIu64, &nums[c] );
+                } else {
+                    unsigned int n;
+                    r = sscanf( prog::optarg, "%u", &n );
+                    if ( r >= 1 )
+                    {
+                        nums[c] = static_cast<uint64_t>( n );
+                    }
+                }
+                if ( r < 1 ) {
+                    fprintf( stderr, "%s: option requires integer argument -- %c\n",
+                             argv[0], c );
+                    return 2;
+                }
+                /* Break not, lest ye be broken.  :) */
+                /* All arguments: all valid options end up here, and we just
+                   stuff the string pointer into the tags[] array. */
+            default:
+                tags[c] = prog::optarg;
+                mods++;
+        } /* end switch */
+
+        c = prog::getOptionSingle( argc, argv, OPT_STRING, long_options, NULL );
+    } /* end while */
+
+    /* Check that we have at least one non-option argument */
+    if ( ( argc - prog::optind ) < 1 ) {
+        fprintf( stderr,
+                 "%s: You must specify at least one MP4 file.\n",
+                 argv[0] );
+        fprintf( stderr, "Usage: %s %s\n", "mp4tags", help_text );
+        return 3;
+    }
+
+    /* Check that we have at least one requested modification.  Probably
+       it's useful instead to print the metadata if no modifications are
+       requested? */
+    if ( !mods ) {
+        fprintf( stderr,
+                 "%s: You must specify at least one tag modification.\n",
+                 argv[0] );
+        fprintf( stderr, "Usage: %s %s\n", "mp4tags", help_text );
+        return 4;
+    }
+
+    /* Loop through the non-option arguments, and modify the tags as
+       requested. */
+    while ( prog::optind < argc ) {
+        char *mp4 = argv[prog::optind++];
+
+        MP4FileHandle h = MP4Modify( mp4 );
+        if ( h == MP4_INVALID_FILE_HANDLE ) {
+            fprintf( stderr, "Could not open '%s'... aborting\n", mp4 );
+            return 5;
+        }
+        /* Read out the existing metadata */
+        const MP4Tags* mdata = MP4TagsAlloc();
+        MP4TagsFetch( mdata, h );
+
+        /* Remove any tags */
+        if ( ELEMENT_OF(tags,OPT_REMOVE) ) {
+            for ( const char *p = ELEMENT_OF(tags,OPT_REMOVE); *p; p++ ) {
+                int index = *p;
+                for ( int i = 0; long_options[i].name != NULL; i++ ) {
+                    size_t len = strlen( long_options[i].name );
+                    if ( strnequal( p, long_options[i].name, len ) && ( p[len] == ',' || p[len] == 0 ) ) {
+                        p += len - 1;
+                        index = long_options[i].val;
+                        break;
+                    }
+                }
+                switch ( index ) {
+                    case OPT_ALBUM:
+                        MP4TagsSetAlbum( mdata, NULL );
+                        break;
+                    case OPT_ARTIST:
+                        MP4TagsSetArtist( mdata, NULL );
+                        break;
+                    case OPT_TEMPO:
+                        MP4TagsSetTempo( mdata, NULL );
+                        break;
+                    case OPT_COMMENT:
+                        MP4TagsSetComments( mdata, NULL );
+                        break;
+                    case OPT_COPYRIGHT:
+                        MP4TagsSetCopyright( mdata, NULL );
+                        break;
+                    case OPT_DISK:
+                        MP4TagsSetDisk( mdata, NULL );
+                        break;
+                    case OPT_DISKS:
+                        MP4TagsSetDisk( mdata, NULL );
+                        break;
+                    case OPT_ENCODEDBY:
+                        MP4TagsSetEncodedBy( mdata, NULL );
+                        break;
+                    case OPT_TOOL:
+                        MP4TagsSetEncodingTool( mdata, NULL );
+                        break;
+                    case OPT_GENRE:
+                        MP4TagsSetGenre( mdata, NULL );
+                        MP4TagsSetGenreType( mdata, NULL );
+                        break;
+                    case OPT_GROUPING:
+                        MP4TagsSetGrouping( mdata, NULL );
+                        break;
+                    case OPT_HD:
+                        MP4TagsSetHDVideo( mdata, NULL );
+                        break;
+                    case OPT_MEDIA_TYPE:
+                        MP4TagsSetMediaType( mdata, NULL );
+                        break;
+                    case OPT_CONTENTID:
+                        MP4TagsSetContentID( mdata, NULL );
+                        break;
+                    case OPT_LONGDESC:
+                        MP4TagsSetLongDescription( mdata, NULL );
+                        break;
+                    case OPT_GENREID:
+                        MP4TagsSetGenreID( mdata, NULL );
+                        break;
+                    case OPT_LYRICS:
+                        MP4TagsSetLyrics( mdata, NULL );
+                        break;
+                    case OPT_DESCRIPTION:
+                        MP4TagsSetDescription( mdata, NULL );
+                        break;
+                    case OPT_TVEPISODE:
+                        MP4TagsSetTVEpisode( mdata, NULL );
+                        break;
+                    case OPT_TVSEASON:
+                        MP4TagsSetTVSeason( mdata, NULL );
+                        break;
+                    case OPT_TVNETWORK:
+                        MP4TagsSetTVNetwork( mdata, NULL );
+                        break;
+                    case OPT_TVEPISODEID:
+                        MP4TagsSetTVEpisodeID( mdata, NULL );
+                        break;
+                    case OPT_PLAYLISTID:
+                        MP4TagsSetPlaylistID( mdata, NULL );
+                        break;
+                    case OPT_PICTURE:
+                        if( mdata->artworkCount )
+                            MP4TagsRemoveArtwork( mdata, 0 );
+                        break;
+                    case OPT_ALBUM_ARTIST:
+                        MP4TagsSetAlbumArtist( mdata, NULL );
+                        break ;
+                    case OPT_NAME:
+                        MP4TagsSetName( mdata, NULL );
+                        break;
+                    case OPT_TVSHOW:
+                        MP4TagsSetTVShow( mdata, NULL );
+                        break;
+                    case OPT_TRACK:
+                        MP4TagsSetTrack( mdata, NULL );
+                        break;
+                    case OPT_TRACKS:
+                        MP4TagsSetTrack( mdata, NULL );
+                        break;
+                    case OPT_XID:
+                        MP4TagsSetXID( mdata, NULL );
+                        break;
+                    case OPT_COMPOSER:
+                        MP4TagsSetComposer( mdata, NULL );
+                        break;
+                    case OPT_RELEASEDATE:
+                        MP4TagsSetReleaseDate( mdata, NULL );
+                        break;
+                    case OPT_ARTISTID:
+                        MP4TagsSetArtistID( mdata, NULL );
+                        break;
+                    case OPT_COMPOSERID:
+                        MP4TagsSetComposerID( mdata, NULL );
+                        break;
+                    case OPT_PODCAST:
+                        MP4TagsSetPodcast( mdata, NULL );
+                        break;
+                    case OPT_CATEGORY:
+                        MP4TagsSetCategory( mdata, NULL );
+                        break;
+                    case OPT_RATING:
+                        MP4TagsSetContentRating( mdata, NULL );
+                        break;
+                    case OPT_SORT_NAME:
+                        MP4TagsSetSortName( mdata, NULL );
+                        break;
+                    case OPT_SORT_ARTIST:
+                        MP4TagsSetSortArtist( mdata, NULL );
+                        break;
+                    case OPT_SORT_ALBUM_ARTIST:
+                        MP4TagsSetSortAlbumArtist( mdata, NULL );
+                        break;
+                    case OPT_SORT_ALBUM:
+                        MP4TagsSetSortAlbum( mdata, NULL );
+                        break;
+                    case OPT_SORT_COMPOSER:
+                        MP4TagsSetSortComposer( mdata, NULL );
+                        break;
+                    case OPT_SORT_TV_SHOW:
+                        MP4TagsSetSortTVShow( mdata, NULL );
+                        break;
+                    case OPT_PURCHASE_DATE:
+                        MP4TagsSetPurchaseDate( mdata, NULL );
+                        break;
+                }
+            }
+        }
+
+        /* Track/disk numbers need to be set all at once, but we'd like to
+           allow users to just specify -T 12 to indicate that all existing
+           track numbers are out of 12.  This means we need to look up the
+           current info if it is not being set. */
+
+        if ( ELEMENT_OF(tags,OPT_TRACK) || ELEMENT_OF(tags,OPT_TRACKS) ) {
+            MP4TagTrack tt;
+            tt.index = 0;
+            tt.total = 0;
+
+            if( mdata->track ) {
+                tt.index = mdata->track->index;
+                tt.total = mdata->track->total;
+            }
+
+            if( ELEMENT_OF(tags,OPT_TRACK) )
+                tt.index = static_cast<uint16_t>( ELEMENT_OF(nums,OPT_TRACK) );
+            if( ELEMENT_OF(tags,OPT_TRACKS) )
+                tt.total = static_cast<uint16_t>( ELEMENT_OF(nums,OPT_TRACKS) );
+
+            MP4TagsSetTrack( mdata, &tt );
+        }
+
+        if ( ELEMENT_OF(tags,OPT_DISK) || ELEMENT_OF(tags,OPT_DISKS) ) {
+            MP4TagDisk td;
+            td.index = 0;
+            td.total = 0;
+
+            if( mdata->disk ) {
+                td.index = mdata->disk->index;
+                td.total = mdata->disk->total;
+            }
+
+            if( ELEMENT_OF(tags,OPT_DISK) )
+                td.index = static_cast<uint16_t>( ELEMENT_OF(nums,OPT_DISK) );
+            if( ELEMENT_OF(tags,OPT_DISKS) )
+                td.total = static_cast<uint16_t>( ELEMENT_OF(nums,OPT_DISKS) );
+
+            MP4TagsSetDisk( mdata, &td );
+        }
+
+        /* Set the other relevant attributes */
+        for ( int i = 0;  i < MAX_OPT;  i++ ) {
+            if ( tags[i] ) {
+                switch ( i ) {
+                    case OPT_ALBUM:
+                        MP4TagsSetAlbum( mdata, tags[i] );
+                        break;
+                    case OPT_ARTIST:
+                        MP4TagsSetArtist( mdata, tags[i] );
+                        break;
+                    case OPT_TEMPO:
+                    {
+                        uint16_t value = static_cast<uint16_t>( nums[i] );
+                        MP4TagsSetTempo( mdata, &value );
+                        break;
+                    }
+                    case OPT_COMMENT:
+                        MP4TagsSetComments( mdata, tags[i] );
+                        break;
+                    case OPT_COPYRIGHT:
+                        MP4TagsSetCopyright( mdata, tags[i] );
+                        break;
+                    case OPT_ENCODEDBY:
+                        MP4TagsSetEncodedBy( mdata, tags[i] );
+                        break;
+                    case OPT_TOOL:
+                        MP4TagsSetEncodingTool( mdata, tags[i] );
+                        break;
+                    case OPT_GENRE: {
+                        MP4TagsSetGenre(mdata, 0);
+                        MP4TagsSetGenreType(mdata, 0);
+
+                        uint16_t id;
+                        if (std::sscanf(tags[i], "%hd", &id) == 1) {
+                            MP4TagsSetGenreType(mdata, &id);
+                        } else {
+                            id = static_cast<uint16_t>(itmf::enumGenreType.toType(tags[i])) ;
+                            if (id != mp4v2::impl::itmf::GENRE_UNDEFINED)
+                                MP4TagsSetGenreType(mdata, &id);
+                            else
+                                MP4TagsSetGenre(mdata, tags[i]);
+                        }
+                        break;
+                    }
+                    case OPT_GROUPING:
+                        MP4TagsSetGrouping( mdata, tags[i] );
+                        break;
+                    case OPT_HD:
+                    {
+                        uint8_t value = static_cast<uint8_t>( nums[i] );
+                        MP4TagsSetHDVideo( mdata, &value );
+                        break;
+                    }
+                    case OPT_MEDIA_TYPE:
+                    {
+                        uint8_t st = static_cast<uint8_t>( itmf::enumStikType.toType( tags[i] ) ) ;
+                        MP4TagsSetMediaType( mdata, &st );
+                        break;
+                    }
+                    case OPT_CONTENTID:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetContentID( mdata, &value );
+                        break;
+                    }
+                    case OPT_LONGDESC:
+                        MP4TagsSetLongDescription( mdata, tags[i] );
+                        break;
+                    case OPT_GENREID:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetGenreID( mdata, &value );
+                        break;
+                    }
+                    case OPT_LYRICS:
+                        MP4TagsSetLyrics( mdata, tags[i] );
+                        break;
+                    case OPT_DESCRIPTION:
+                        MP4TagsSetDescription( mdata, tags[i] );
+                        break;
+                    case OPT_TVEPISODE:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetTVEpisode( mdata, &value );
+                        break;
+                    }
+                    case OPT_TVSEASON:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetTVSeason( mdata, &value );
+                        break;
+                    }
+                    case OPT_TVNETWORK:
+                        MP4TagsSetTVNetwork( mdata, tags[i] );
+                        break;
+                    case OPT_TVEPISODEID:
+                        MP4TagsSetTVEpisodeID( mdata, tags[i] );
+                        break;
+                    case OPT_PLAYLISTID:
+                    {
+                        uint64_t value = static_cast<uint64_t>( nums[i] );
+                        MP4TagsSetPlaylistID( mdata, &value );
+                        break;
+                    }
+                    case OPT_PICTURE:
+                    {
+                        File in( tags[i], File::MODE_READ );
+                        if( !in.open() ) {
+                            MP4TagArtwork art;
+                            art.size = (uint32_t)in.size;
+                            art.data = malloc( art.size );
+                            art.type = MP4_ART_UNDEFINED;
+
+                            File::Size nin;
+                            if( !in.read( art.data, art.size, nin ) && nin == art.size ) {
+                                if( mdata->artworkCount )
+                                    MP4TagsRemoveArtwork( mdata, 0 );
+                                MP4TagsAddArtwork( mdata, &art ); 
+                            }
+
+                            free( art.data );
+                            in.close();
+                        }
+                        else {
+                            fprintf( stderr, "Art file %s not found\n", tags[i] );
+                        }
+                        break;
+                    }
+                    case OPT_ALBUM_ARTIST:
+                        MP4TagsSetAlbumArtist( mdata, tags[i] );
+                        break;
+                    case OPT_NAME:
+                        MP4TagsSetName( mdata, tags[i] );
+                        break;
+                    case OPT_TVSHOW:
+                        MP4TagsSetTVShow( mdata, tags[i] );
+                        break;
+                    case OPT_XID:
+                        MP4TagsSetXID( mdata, tags[i] );
+                        break;
+                    case OPT_COMPOSER:
+                        MP4TagsSetComposer( mdata, tags[i] );
+                        break;
+                    case OPT_RELEASEDATE:
+                        MP4TagsSetReleaseDate( mdata, tags[i] );
+                        break;
+                    case OPT_ARTISTID:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetArtistID( mdata, &value );
+                        break;
+                    }
+                    case OPT_COMPOSERID:
+                    {
+                        uint32_t value = static_cast<uint32_t>( nums[i] );
+                        MP4TagsSetComposerID( mdata, &value );
+                        break;
+                    }
+                    case OPT_PODCAST:
+                    {
+                        uint8_t value = static_cast<uint8_t>( nums[i] );
+                        MP4TagsSetPodcast( mdata, &value );
+                        break;
+                    }
+                    case OPT_CATEGORY:
+                        MP4TagsSetCategory( mdata, tags[i] );
+                        break;
+                    case OPT_RATING:
+                    {
+                        uint8_t rating = static_cast<uint8_t>( itmf::enumContentRating.toType( tags[i] ) ) ;
+                        MP4TagsSetContentRating( mdata, &rating );
+                        break;
+                    }
+                    case OPT_SORT_NAME:
+                        MP4TagsSetSortName( mdata, tags[i] );
+                        break;
+                    case OPT_SORT_ARTIST:
+                        MP4TagsSetSortArtist( mdata, tags[i] );
+                        break;
+                    case OPT_SORT_ALBUM_ARTIST:
+                        MP4TagsSetSortAlbumArtist( mdata, tags[i] );
+                        break;
+                    case OPT_SORT_ALBUM:
+                        MP4TagsSetSortAlbum( mdata, tags[i] );
+                        break;
+                    case OPT_SORT_COMPOSER:
+                        MP4TagsSetSortComposer( mdata, tags[i] );
+                        break;
+                    case OPT_SORT_TV_SHOW:
+                        MP4TagsSetSortTVShow( mdata, tags[i] );
+                        break;
+                    case OPT_PURCHASE_DATE:
+                        MP4TagsSetPurchaseDate( mdata, tags[i] );
+                        break;
+                }
+            }
+        }
+        /* Write out all tag modifications, free and close */
+        MP4TagsStore( mdata, h );
+        MP4TagsFree( mdata );
+        MP4Close( h );
+    } /* end while optind < argc */
+    return 0;
+}
diff --git a/mp4v2/util/mp4track.cpp b/mp4v2/util/mp4track.cpp
new file mode 100644
index 0000000..2e8faff
--- /dev/null
+++ b/mp4v2/util/mp4track.cpp
@@ -0,0 +1,981 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The contents of this file are subject to the Mozilla Public License
+//  Version 1.1 (the "License"); you may not use this file except in
+//  compliance with the License. You may obtain a copy of the License at
+//  http://www.mozilla.org/MPL/
+//
+//  Software distributed under the License is distributed on an "AS IS"
+//  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+//  License for the specific language governing rights and limitations
+//  under the License.
+// 
+//  The Original Code is MP4v2.
+// 
+//  The Initial Developer of the Original Code is Kona Blend.
+//  Portions created by Kona Blend are Copyright (C) 2008.
+//  Portions created by David Byron are Copyright (C) 2010.
+//  All Rights Reserved.
+//
+//  Contributors:
+//      Kona Blend, kona8lend@@gmail.com
+//      David Byron, dbyron@dbyron.com
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "util/impl.h"
+
+namespace mp4v2 { namespace util {
+
+///////////////////////////////////////////////////////////////////////////////
+
+class TrackUtility : public Utility
+{
+private:
+    enum TrackLongAction {
+        LC_TRACK_WILDCARD = _LC_MAX,
+        LC_TRACK_ID,
+        LC_TRACK_INDEX,
+
+        LC_SAMPLE_WILDCARD,
+        LC_SAMPLE_ID,
+        LC_SAMPLE_INDEX,
+
+        LC_LIST,
+
+        LC_ENABLED,
+        LC_INMOVIE,
+        LC_INPREVIEW,
+        LC_LAYER,
+        LC_ALTGROUP,
+        LC_VOLUME,
+        LC_WIDTH,
+        LC_HEIGHT,
+        LC_LANGUAGE,
+        LC_HDLRNAME,
+        LC_UDTANAME,
+        LC_UDTANAME_R,
+
+        LC_COLR_PARMS,
+        LC_COLR_PARM_HD,
+        LC_COLR_PARM_SD,
+
+        LC_COLR_LIST,
+        LC_COLR_ADD,
+        LC_COLR_SET,
+        LC_COLR_REMOVE,
+
+        LC_PASP_PARMS,
+
+        LC_PASP_LIST,
+        LC_PASP_ADD,
+        LC_PASP_SET,
+        LC_PASP_REMOVE
+    };
+
+public:
+    TrackUtility( int, char** );
+
+protected:
+    // delegates implementation
+    bool utility_option( int, bool& );
+    bool utility_job( JobContext& );
+
+private:
+    bool actionList( JobContext& );
+    bool actionListSingle( JobContext&, uint16_t );
+
+    bool actionColorParameterList   ( JobContext& );
+    bool actionColorParameterAdd    ( JobContext& );
+    bool actionColorParameterSet    ( JobContext& );
+    bool actionColorParameterRemove ( JobContext& );
+
+    bool actionPictureAspectRatioList   ( JobContext& );
+    bool actionPictureAspectRatioAdd    ( JobContext& );
+    bool actionPictureAspectRatioSet    ( JobContext& );
+    bool actionPictureAspectRatioRemove ( JobContext& );
+
+    bool actionTrackModifierSet    ( JobContext& );
+    bool actionTrackModifierRemove ( JobContext& );
+
+private:
+    enum TrackMode {
+        TM_UNDEFINED,
+        TM_INDEX,
+        TM_ID,
+        TM_WILDCARD
+    };
+
+    Group _actionGroup;
+    Group _parmGroup;
+
+    bool (TrackUtility::*_action)( JobContext& );
+
+    TrackMode _trackMode;
+    uint16_t  _trackIndex;
+    uint32_t  _trackId;
+
+    qtff::ColorParameterBox::Item     _colorParameterItem;
+    qtff::PictureAspectRatioBox::Item _pictureAspectRatioItem;
+
+    void (TrackModifier::*_actionTrackModifierSet_function)( const string& );
+    string _actionTrackModifierSet_name;
+    string _actionTrackModifierSet_value;
+
+    void (TrackModifier::*_actionTrackModifierRemove_function)();
+    string _actionTrackModifierRemove_name;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+string toStringTrackType( const string& );
+
+///////////////////////////////////////////////////////////////////////////////
+
+TrackUtility::TrackUtility( int argc, char** argv )
+    : Utility      ( "mp4track", argc, argv )
+    , _actionGroup ( "ACTIONS" )
+    , _parmGroup   ( "PARAMETERS" )
+    , _action      ( NULL )
+    , _trackMode   ( TM_UNDEFINED )
+    , _trackIndex  ( 0 )
+    , _trackId     ( MP4_INVALID_TRACK_ID )
+{
+    // add standard options which make sense for this utility
+    _group.add( STD_OPTIMIZE );
+    _group.add( STD_DRYRUN );
+    _group.add( STD_KEEPGOING );
+    _group.add( STD_OVERWRITE );
+    _group.add( STD_FORCE );
+    _group.add( STD_QUIET );
+    _group.add( STD_DEBUG );
+    _group.add( STD_VERBOSE );
+    _group.add( STD_HELP );
+    _group.add( STD_VERSION );
+    _group.add( STD_VERSIONX );
+
+    _parmGroup.add( "track-any",    false, LC_TRACK_WILDCARD,  "act on any/all tracks" );
+    _parmGroup.add( "track-index",  true,  LC_TRACK_INDEX,     "act on track index IDX", "IDX" );
+    _parmGroup.add( "track-id",     true,  LC_TRACK_ID,        "act on track id ID", "ID" );
+/*
+    _parmGroup.add( "sample-any",   false, LC_SAMPLE_WILDCARD, "act on any sample (default)" );
+    _parmGroup.add( "sample-index", true,  LC_SAMPLE_INDEX,    "act on sample index IDX" );
+    _parmGroup.add( "sample-id",    true,  LC_SAMPLE_ID,       "act on sample id ID" );
+*/
+    _parmGroup.add( "colr-parms",   true,  LC_COLR_PARMS,      "where CSV is IDX1,IDX2,IDX3", "CSV" );
+    _parmGroup.add( "colr-parm-hd", false, LC_COLR_PARM_HD,    "equivalent to --colr-parms=1,1,1" );
+    _parmGroup.add( "colr-parm-sd", false, LC_COLR_PARM_SD,    "equivalent to --colr-parms=6,1,6" );
+    _parmGroup.add( "pasp-parms",   true,  LC_PASP_PARMS,      "where CSV is hSPACING,vSPACING", "CSV" );
+    _groups.push_back( &_parmGroup );
+
+    _actionGroup.add( "list", false, LC_LIST, "list all tracks in mp4" );
+
+    _actionGroup.add( "enabled",         true,  LC_ENABLED,    "set trak.tkhd.flags (enabled bit)", "BOOL" );
+    _actionGroup.add( "inmovie",         true,  LC_INMOVIE,    "set trak.tkhd.flags (inMovie bit)", "BOOL" );
+    _actionGroup.add( "inpreview",       true,  LC_INPREVIEW,  "set trak.tkhd.flags (inPreview bit)", "BOOL" );
+    _actionGroup.add( "layer",           true,  LC_LAYER,      "set trak.tkhd.layer", "NUM" );
+    _actionGroup.add( "altgroup",        true,  LC_ALTGROUP,   "set trak.tkhd.alternate_group", "NUM" );
+    _actionGroup.add( "volume",          true,  LC_VOLUME,     "set trak.tkhd.volume", "FLOAT" );
+    _actionGroup.add( "width",           true,  LC_WIDTH,      "set trak.tkhd.width", "FLOAT" );
+    _actionGroup.add( "height",          true,  LC_HEIGHT,     "set trak.tkhd.height", "FLOAT" );
+    _actionGroup.add( "language",        true,  LC_LANGUAGE,   "set trak.mdia.mdhd.language", "CODE" );
+    _actionGroup.add( "hdlrname",        true,  LC_HDLRNAME,   "set trak.mdia.hdlr.name", "STR" );
+    _actionGroup.add( "udtaname",        true,  LC_UDTANAME,   "set trak.udta.name.value", "STR" );
+    _actionGroup.add( "udtaname-remove", false, LC_UDTANAME_R, "remove trak.udta.name atom" );
+
+    _actionGroup.add( "colr-list",   false, LC_COLR_LIST,   "list all colr-boxes in mp4" );
+    _actionGroup.add( "colr-add",    false, LC_COLR_ADD,    "add colr-box to a video track" );
+    _actionGroup.add( "colr-set",    false, LC_COLR_SET,    "set colr-box parms" );
+    _actionGroup.add( "colr-remove", false, LC_COLR_REMOVE, "remove colr-box from track" );
+    _actionGroup.add( "pasp-list",   false, LC_PASP_LIST,   "list all pasp-boxes in mp4" );
+    _actionGroup.add( "pasp-add",    false, LC_PASP_ADD,    "add pasp-box to a video track" );
+    _actionGroup.add( "pasp-set",    false, LC_PASP_SET,    "set pasp-box parms" );
+    _actionGroup.add( "pasp-remove", false, LC_PASP_REMOVE, "remove pasp-box from track" );
+
+    _groups.push_back( &_actionGroup );
+
+    _usage = "[OPTION]... [PARAMETERS]... ACTION file...";
+    _description =
+        // 79-cols, inclusive, max desired width
+        // |----------------------------------------------------------------------------|
+        "\nFor each mp4 file specified, perform the specified ACTION. An action must be"
+        "\nspecified. Some options are not applicable to some actions.";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionColorParameterAdd( JobContext& job )
+{
+    ostringstream oss;
+    oss << "adding colr-box(" << _colorParameterItem.convertToCSV() << ") -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        default:
+        case TM_INDEX:
+            if( qtff::ColorParameterBox::add( job.fileHandle, _trackIndex, _colorParameterItem ))
+                return herrf( "unable to add colr-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::ColorParameterBox::add( job.fileHandle, _trackId, _colorParameterItem ))
+                return herrf( "unable to add colr-box\n" );
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionColorParameterList( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    ostringstream report;
+
+    const int widx = 3;
+    const int wid = 3;
+    const int wtype = 8;
+    const int wparm = 6;
+    const string sep = "  ";
+
+    if( _jobCount == 0 ) {
+        report << setw(widx) << right << "IDX"
+               << sep << setw(wid) << "ID"
+               << sep << setw(wtype) << left << "TYPE"
+               << sep << setw(wparm) << right << "PRIMRY"
+               << sep << setw(wparm) << right << "XFERFN"
+               << sep << setw(wparm) << right << "MATRIX"
+               << sep << setw(0) << "FILE"
+               << '\n';
+
+        report << setfill('-') << setw(70) << "" << setfill(' ') << '\n';
+    }
+
+    qtff::ColorParameterBox::ItemList itemList;
+    if( qtff::ColorParameterBox::list( job.fileHandle, itemList ))
+        return herrf( "unable to fetch list of colr-boxes" );
+
+    const qtff::ColorParameterBox::ItemList::size_type max = itemList.size();
+    for( qtff::ColorParameterBox::ItemList::size_type i = 0; i < max; i++ ) {
+        const qtff::ColorParameterBox::IndexedItem& xitem = itemList[i];
+
+        const char* type = MP4GetTrackType( job.fileHandle, xitem.trackId );
+        if( !type)
+            type = "unknown";
+
+        report << right << setw(widx) << xitem.trackIndex
+               << sep << setw(wid) << xitem.trackId
+               << sep << setw(wtype) << left << toStringTrackType( type )
+               << sep << setw(wparm) << right << xitem.item.primariesIndex
+               << sep << setw(wparm) << right << xitem.item.transferFunctionIndex
+               << sep << setw(wparm) << right << xitem.item.matrixIndex;
+
+        if( i == 0 )
+            report << sep << setw(0) << job.file;
+
+        report << '\n';
+    }
+
+    verbose1f( "%s", report.str().c_str() );
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionColorParameterRemove( JobContext& job )
+{
+    ostringstream oss;
+    oss << "removing colr-box from " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        case TM_WILDCARD:
+            oss << " (all tracks)";
+            break;
+
+        default:
+            return herrf( "track(s) not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            if( qtff::ColorParameterBox::remove( job.fileHandle, _trackIndex ))
+                return herrf( "unable to remove colr-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::ColorParameterBox::remove( job.fileHandle, _trackId ))
+                return herrf( "unable to remove colr-box\n" );
+            break;
+
+        default:
+        case TM_WILDCARD:
+        {
+            qtff::ColorParameterBox::ItemList itemList;
+            if( qtff::ColorParameterBox::list( job.fileHandle, itemList ))
+                return herrf( "unable to fetch list of colr-boxes" );
+
+            _trackMode = TM_INDEX;
+            const qtff::ColorParameterBox::ItemList::size_type max = itemList.size();
+            for( qtff::ColorParameterBox::ItemList::size_type i = 0; i < max; i++ ) {
+                const qtff::ColorParameterBox::IndexedItem& xitem = itemList[i];
+                _trackIndex = xitem.trackIndex;
+                actionColorParameterRemove( job );
+            }
+            break;
+        }
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionColorParameterSet( JobContext& job )
+{
+    ostringstream oss;
+    oss << "setting colr-box(" << _colorParameterItem.convertToCSV() << ") -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        default:
+        case TM_INDEX:
+            if( qtff::ColorParameterBox::set( job.fileHandle, _trackIndex, _colorParameterItem ))
+                return herrf( "unable to set colr-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::ColorParameterBox::set( job.fileHandle, _trackId, _colorParameterItem ))
+                return herrf( "unable to set colr-box\n" );
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionList( JobContext& job )
+{
+    if( _jobTotal > 1 )
+        verbose1f( "file %u of %u: %s\n", _jobCount+1, _jobTotal, job.file.c_str() );
+
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            return actionListSingle( job, _trackIndex );
+
+        case TM_ID:
+            return actionListSingle( job, MP4FindTrackIndex( job.fileHandle, _trackId ));
+
+        case TM_WILDCARD:
+        default:
+        {
+            bool result = SUCCESS;
+            const uint16_t trackc = static_cast<uint16_t>( MP4GetNumberOfTracks( job.fileHandle ));
+            for( uint16_t i = 0; i < trackc; i++ ) {
+                if( actionListSingle( job, i ))
+                    result = FAILURE;
+            }
+            return result;
+        }
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionListSingle( JobContext& job, uint16_t index )
+{
+    TrackModifier tm( job.fileHandle, index );
+
+    ostringstream report;
+    tm.dump( report, ( _jobTotal > 1 ? "  " : "" ));
+
+    verbose1f( "%s", report.str().c_str() );
+    return false;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionPictureAspectRatioAdd( JobContext& job )
+{
+    ostringstream oss;
+    oss << "adding pasp-box(" << _pictureAspectRatioItem.convertToCSV() << ") -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        default:
+        case TM_INDEX:
+            if( qtff::PictureAspectRatioBox::add( job.fileHandle, _trackIndex, _pictureAspectRatioItem ))
+                return herrf( "unable to add pasp-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::PictureAspectRatioBox::add( job.fileHandle, _trackId, _pictureAspectRatioItem ))
+                return herrf( "unable to add pasp-box\n" );
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionPictureAspectRatioList( JobContext& job )
+{
+    job.fileHandle = MP4Read( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for read: %s\n", job.file.c_str() );
+
+    ostringstream report;
+
+    const int widx = 3;
+    const int wid = 3;
+    const int wtype = 8;
+    const int wparm = 6;
+    const string sep = "  ";
+
+    if( _jobCount == 0 ) {
+        report << setw(widx) << right << "IDX"
+               << sep << setw(wid) << "ID"
+               << sep << setw(wtype) << left << "TYPE"
+               << sep << setw(wparm) << right << "hSPACE"
+               << sep << setw(wparm) << right << "vSPACE"
+               << sep << setw(0) << "FILE"
+               << '\n';
+
+        report << setfill('-') << setw(70) << "" << setfill(' ') << '\n';
+    }
+
+    qtff::PictureAspectRatioBox::ItemList itemList;
+    if( qtff::PictureAspectRatioBox::list( job.fileHandle, itemList ))
+        return herrf( "unable to fetch list of pasp-boxes" );
+
+    const qtff::PictureAspectRatioBox::ItemList::size_type max = itemList.size();
+    for( qtff::PictureAspectRatioBox::ItemList::size_type i = 0; i < max; i++ ) {
+        const qtff::PictureAspectRatioBox::IndexedItem& xitem = itemList[i];
+
+        const char* type = MP4GetTrackType( job.fileHandle, xitem.trackId );
+        if( !type)
+            type = "unknown";
+
+        report << right << setw(widx) << xitem.trackIndex
+               << sep << setw(wid) << xitem.trackId
+               << sep << setw(wtype) << left << toStringTrackType( type )
+               << sep << setw(wparm) << right << xitem.item.hSpacing
+               << sep << setw(wparm) << right << xitem.item.vSpacing;
+
+        if( i == 0 )
+            report << sep << setw(0) << job.file;
+
+        report << '\n';
+    }
+
+    verbose1f( "%s", report.str().c_str() );
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionPictureAspectRatioRemove( JobContext& job )
+{
+    ostringstream oss;
+    oss << "removing pasp-box from " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            oss << " (all tracks)";
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            if( qtff::PictureAspectRatioBox::remove( job.fileHandle, _trackIndex ))
+                return herrf( "unable to remove pasp-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::PictureAspectRatioBox::remove( job.fileHandle, _trackId ))
+                return herrf( "unable to remove pasp-box\n" );
+            break;
+
+        default:
+        case TM_WILDCARD:
+        {
+            qtff::PictureAspectRatioBox::ItemList itemList;
+            if( qtff::PictureAspectRatioBox::list( job.fileHandle, itemList ))
+                return herrf( "unable to fetch list of pasp-boxes" );
+
+            _trackMode = TM_INDEX;
+            const qtff::PictureAspectRatioBox::ItemList::size_type max = itemList.size();
+            for( qtff::PictureAspectRatioBox::ItemList::size_type i = 0; i < max; i++ ) {
+                const qtff::PictureAspectRatioBox::IndexedItem& xitem = itemList[i];
+                _trackIndex = xitem.trackIndex;
+                actionPictureAspectRatioRemove( job );
+            }
+            break;
+        }
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionPictureAspectRatioSet( JobContext& job )
+{
+    ostringstream oss;
+    oss << "setting pasp-box(" << _pictureAspectRatioItem.convertToCSV() << ") -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    switch( _trackMode ) {
+        default:
+        case TM_INDEX:
+            if( qtff::PictureAspectRatioBox::set( job.fileHandle, _trackIndex, _pictureAspectRatioItem ))
+                return herrf( "unable to set pasp-box\n" );
+            break;
+
+        case TM_ID:
+            if( qtff::PictureAspectRatioBox::set( job.fileHandle, _trackId, _pictureAspectRatioItem ))
+                return herrf( "unable to set pasp-box\n" );
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionTrackModifierRemove( JobContext& job )
+{
+    ostringstream oss;
+    oss << "removing " << _actionTrackModifierRemove_name << " -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    if( _trackMode == TM_ID )
+        _trackIndex = MP4FindTrackIndex( job.fileHandle, _trackId );
+
+    TrackModifier tm( job.fileHandle, _trackIndex );
+    (tm.*_actionTrackModifierRemove_function)();
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::actionTrackModifierSet( JobContext& job )
+{
+    ostringstream oss;
+    oss << "setting " << _actionTrackModifierSet_name << "=" << _actionTrackModifierSet_value << " -> " << job.file;
+
+    switch( _trackMode ) {
+        case TM_INDEX:
+            oss << " (track index=" << _trackIndex << ')';
+            break;
+
+        case TM_ID:
+            oss << " (track id=" << _trackId << ')';
+            break;
+
+        default:
+        case TM_WILDCARD:
+            return herrf( "track not specified\n" );
+    }
+
+    verbose1f( "%s\n", oss.str().c_str() );
+    if( dryrunAbort() )
+        return SUCCESS;
+
+    job.fileHandle = MP4Modify( job.file.c_str() );
+    if( job.fileHandle == MP4_INVALID_FILE_HANDLE )
+        return herrf( "unable to open for write: %s\n", job.file.c_str() );
+
+    if( _trackMode == TM_ID )
+        _trackIndex = MP4FindTrackIndex( job.fileHandle, _trackId );
+
+    TrackModifier tm( job.fileHandle, _trackIndex );
+    (tm.*_actionTrackModifierSet_function)( _actionTrackModifierSet_value );
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::utility_job( JobContext& job )
+{
+    if( !_action )
+        return herrf( "no action specified\n" );
+
+    return (this->*_action)( job );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+bool
+TrackUtility::utility_option( int code, bool& handled )
+{
+    handled = true;
+
+    switch( code ) {
+        case LC_TRACK_WILDCARD:
+            _trackMode = TM_WILDCARD;
+            break;
+
+        case LC_TRACK_INDEX:
+        {
+            _trackMode = TM_INDEX;
+            istringstream iss( prog::optarg );
+            iss >> _trackIndex;
+            if( iss.rdstate() != ios::eofbit )
+                return herrf( "invalid track index: %s\n", prog::optarg );
+            break;
+        }
+
+        case LC_TRACK_ID:
+        {
+            _trackMode = TM_ID;
+            istringstream iss( prog::optarg );
+            iss >> _trackId;
+            if( iss.rdstate() != ios::eofbit )
+                return herrf( "invalid track id: %s\n", prog::optarg );
+            break;
+        }
+
+        case LC_LIST:
+            _action = &TrackUtility::actionList;
+            break;
+
+        case LC_COLR_PARMS:
+            _colorParameterItem.convertFromCSV( prog::optarg );
+            break;
+
+        case LC_COLR_PARM_HD:
+            _colorParameterItem.primariesIndex        = 1;
+            _colorParameterItem.transferFunctionIndex = 1;
+            _colorParameterItem.matrixIndex           = 1;
+            break;
+
+        case LC_COLR_PARM_SD:
+            _colorParameterItem.primariesIndex        = 6;
+            _colorParameterItem.transferFunctionIndex = 1;
+            _colorParameterItem.matrixIndex           = 6;
+            break;
+
+        case LC_COLR_LIST:
+            _action = &TrackUtility::actionColorParameterList;
+            break;
+
+        case LC_ENABLED:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setEnabled;
+            _actionTrackModifierSet_name     = "enabled";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_INMOVIE:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setInMovie;
+            _actionTrackModifierSet_name     = "inMovie";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_INPREVIEW:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setInPreview;
+            _actionTrackModifierSet_name     = "inPreview";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_LAYER:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setLayer;
+            _actionTrackModifierSet_name     = "layer";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_ALTGROUP:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setAlternateGroup;
+            _actionTrackModifierSet_name     = "alternateGroup";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_VOLUME:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setVolume;
+            _actionTrackModifierSet_name     = "volume";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_WIDTH:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setWidth;
+            _actionTrackModifierSet_name     = "width";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_HEIGHT:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setHeight;
+            _actionTrackModifierSet_name     = "height";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_LANGUAGE:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setLanguage;
+            _actionTrackModifierSet_name     = "language";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_HDLRNAME:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setHandlerName;
+            _actionTrackModifierSet_name     = "handlerName";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_UDTANAME:
+            _action = &TrackUtility::actionTrackModifierSet;
+            _actionTrackModifierSet_function = &TrackModifier::setUserDataName;
+            _actionTrackModifierSet_name     = "userDataName";
+            _actionTrackModifierSet_value    = prog::optarg;
+            break;
+
+        case LC_UDTANAME_R:
+            _action = &TrackUtility::actionTrackModifierRemove;
+            _actionTrackModifierRemove_function = &TrackModifier::removeUserDataName;
+            _actionTrackModifierRemove_name     = "userDataName";
+            break;
+
+        case LC_COLR_ADD:
+            _action = &TrackUtility::actionColorParameterAdd;
+            break;
+
+        case LC_COLR_SET:
+            _action = &TrackUtility::actionColorParameterSet;
+            break;
+
+        case LC_COLR_REMOVE:
+            _action = &TrackUtility::actionColorParameterRemove;
+            break;
+
+        case LC_PASP_PARMS:
+            _pictureAspectRatioItem.convertFromCSV( prog::optarg );
+            break;
+
+        case LC_PASP_LIST:
+            _action = &TrackUtility::actionPictureAspectRatioList;
+            break;
+
+        case LC_PASP_ADD:
+            _action = &TrackUtility::actionPictureAspectRatioAdd;
+            break;
+
+        case LC_PASP_SET:
+            _action = &TrackUtility::actionPictureAspectRatioSet;
+            break;
+
+        case LC_PASP_REMOVE:
+            _action = &TrackUtility::actionPictureAspectRatioRemove;
+            break;
+
+        default:
+            handled = false;
+            break;
+    }
+
+    return SUCCESS;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+string
+toStringTrackType( const string& code )
+{
+    if( !code.compare( "vide" ))    // 14496-12
+        return "video";
+    if( !code.compare( "soun" ))    // 14496-12
+        return "audio";
+    if( !code.compare( "hint" ))    // 14496-12
+        return "hint";
+
+    if( !code.compare( "text" ))    // QTFF
+        return "text";
+    if( !code.compare( "tmcd" ))    // QTFF
+        return "timecode";
+
+    if( !code.compare( "subt" ))    // QTFF
+        return "subtitle";
+
+    return string( "(" ) + code + ")";
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+}} // namespace mp4v2::util
+
+///////////////////////////////////////////////////////////////////////////////
+
+extern "C"
+int main( int argc, char** argv )
+{
+    mp4v2::util::TrackUtility util( argc, argv );
+    return util.process();
+}
diff --git a/mp4v2/util/mp4trackdump.cpp b/mp4v2/util/mp4trackdump.cpp
new file mode 100644
index 0000000..c39d399
--- /dev/null
+++ b/mp4v2/util/mp4trackdump.cpp
@@ -0,0 +1,245 @@
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is MPEG4IP.
+ *
+ * The Initial Developer of the Original Code is Cisco Systems Inc.
+ * Portions created by Cisco Systems Inc. are
+ * Copyright (C) Cisco Systems Inc. 2001.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *      Dave Mackie     dmackie@cisco.com
+ */
+
+// N.B. mp4extract just extracts tracks/samples from an mp4 file
+// For many track types this is insufficient to reconsruct a valid
+// elementary stream (ES). Use "mp4creator -extract=<trackId>" if
+// you need the ES reconstructed.
+
+#include "util/impl.h"
+
+using namespace mp4v2::util;
+
+char* ProgName;
+char* Mp4PathName;
+char* Mp4FileName;
+
+static void DumpTrack ( MP4FileHandle mp4file, MP4TrackId tid )
+{
+    uint32_t numSamples;
+    MP4SampleId sid;
+    MP4Duration time;
+    uint32_t timescale;
+    uint64_t msectime;
+
+    uint64_t sectime, mintime, hrtime;
+
+    numSamples = MP4GetTrackNumberOfSamples( mp4file, tid );
+    timescale = MP4GetTrackTimeScale( mp4file, tid );
+    printf( "mp4file %s, track %u, samples %u, timescale %u\n",
+            Mp4FileName, tid, numSamples, timescale );
+
+    for ( sid = 1; sid <= numSamples; sid++ ) {
+        time = MP4GetSampleTime( mp4file, tid, sid );
+        msectime = time;
+        msectime *= UINT64_C( 1000 );
+        msectime /= timescale;
+        if ( msectime == 0 ) {
+            hrtime = mintime = sectime = UINT64_C( 0 );
+        }
+        else {
+            hrtime = msectime / UINT64_C( 3600000 ); // 3600 * 1000
+            msectime -= hrtime * UINT64_C( 3600000 );// 3600 * 1000
+            mintime = msectime / UINT64_C( 60000 );// 60 * 1000
+            msectime -= ( mintime * UINT64_C( 60000 ) );// 60 * 1000
+            sectime = msectime / UINT64_C( 1000 );
+            msectime -= sectime * UINT64_C( 1000 );
+        }
+
+        printf( "sampleId %6u, size %5u duration %8" PRIu64 " time %8" PRIu64 " %02" PRIu64 ":%02" PRIu64 ":%02" PRIu64 ".%03" PRIu64 " %c\n",
+                sid,  MP4GetSampleSize( mp4file, tid, sid ),
+                MP4GetSampleDuration( mp4file, tid, sid ),
+                time, hrtime, mintime, sectime, msectime,
+                MP4GetSampleSync( mp4file, tid, sid ) == 1 ? 'S' : ' ' );
+    }
+}
+
+extern "C" int main( int argc, char** argv )
+{
+    const char* const usageString =
+        "[-l] [-t <track-id>] [-s <sample-id>] [-v [<level>]] <file-name>";
+    MP4TrackId trackId = MP4_INVALID_TRACK_ID;
+    MP4SampleId sampleId = MP4_INVALID_SAMPLE_ID;
+    MP4LogLevel verbosity = MP4_LOG_ERROR;
+
+    prog::CommandLine commandLine(argc, argv);
+    commandLine.get(&argc, &argv);
+
+    /* begin processing command line */
+    ProgName = argv[0];
+    while ( true ) {
+        int c = -1;
+        int option_index = 0;
+        static const prog::Option long_options[] = {
+            { "track",   prog::Option::REQUIRED_ARG, 0, 't' },
+            { "sample",  prog::Option::REQUIRED_ARG, 0, 's' },
+            { "verbose", prog::Option::OPTIONAL_ARG, 0, 'v' },
+            { "version", prog::Option::NO_ARG,       0, 'V' },
+            { NULL, prog::Option::NO_ARG, 0, 0 }
+        };
+
+        c = prog::getOptionSingle( argc, argv, "t:v::V", long_options, &option_index );
+
+        if ( c == -1 )
+            break;
+
+        switch ( c ) {
+            case 's':
+                if ( sscanf( prog::optarg, "%u", &sampleId ) != 1 ) {
+                    fprintf( stderr, "%s: bad sample-id specified: %s\n",
+                             ProgName, prog::optarg );
+                    exit( 1 );
+                }
+                break;
+            case 't':
+                if ( sscanf( prog::optarg, "%u", &trackId ) != 1 ) {
+                    fprintf( stderr,
+                             "%s: bad track-id specified: %s\n",
+                             ProgName, prog::optarg );
+                    exit( 1 );
+                }
+                break;
+            case 'v':
+                verbosity = MP4_LOG_VERBOSE1;
+                if ( prog::optarg ) {
+                    uint32_t level;
+                    if ( sscanf( prog::optarg, "%u", &level ) == 1 ) {
+                        if ( level >= 2 ) {
+                            verbosity = MP4_LOG_VERBOSE2;
+                        }
+                        if ( level >= 3 ) {
+                            verbosity = MP4_LOG_VERBOSE3;
+                        }
+                        if ( level >= 4 ) {
+                            verbosity = MP4_LOG_VERBOSE4;
+                        }
+                    }
+                }
+                break;
+            case '?':
+                fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+                exit( 0 );
+            case 'V':
+                fprintf( stderr, "%s - %s\n",
+                         ProgName, MP4V2_PROJECT_name_formal );
+                exit( 0 );
+            default:
+                fprintf( stderr, "%s: unknown option specified, ignoring: %c\n",
+                         ProgName, c );
+        }
+    }
+
+    /* check that we have at least one non-option argument */
+    if ( ( argc - prog::optind ) < 1 ) {
+        fprintf( stderr, "usage: %s %s\n", ProgName, usageString );
+        exit( 1 );
+    }
+
+    MP4LogSetLevel(verbosity);
+    if ( verbosity ) {
+        fprintf( stderr, "%s version %s\n", ProgName, MP4V2_PROJECT_version );
+    }
+
+    /* point to the specified file names */
+    Mp4PathName = argv[prog::optind++];
+
+    char* lastSlash = strrchr( Mp4PathName, '/' );
+    if ( lastSlash ) {
+        Mp4FileName = lastSlash + 1;
+    }
+    else {
+        Mp4FileName = Mp4PathName;
+    }
+
+    /* warn about extraneous non-option arguments */
+    if ( prog::optind < argc ) {
+        fprintf( stderr, "%s: unknown options specified, ignoring: ", ProgName );
+        while ( prog::optind < argc ) {
+            fprintf( stderr, "%s ", argv[prog::optind++] );
+        }
+        fprintf( stderr, "\n" );
+    }
+
+    /* end processing of command line */
+
+
+    MP4FileHandle mp4File = MP4Read( Mp4PathName );
+
+    if ( !mp4File ) {
+        exit( 1 );
+    }
+
+    if ( sampleId != MP4_INVALID_SAMPLE_ID ) {
+        if ( trackId == 0 ) {
+            fprintf( stderr, "%s: Must specify track for sample\n", ProgName );
+            return -1;
+        }
+        if ( sampleId > MP4GetTrackNumberOfSamples( mp4File, trackId ) ) {
+            fprintf( stderr, "%s: Sample number %u is past end %u\n",
+                     ProgName, sampleId, MP4GetTrackNumberOfSamples( mp4File, trackId ) );
+            return -1;
+        }
+        uint32_t sample_size = MP4GetTrackMaxSampleSize( mp4File, trackId );
+        uint8_t *sample = ( uint8_t * )malloc( sample_size );
+        MP4Timestamp sampleTime;
+        MP4Duration sampleDuration, sampleRenderingOffset;
+        uint32_t this_size = sample_size;
+        bool isSyncSample;
+        bool ret = MP4ReadSample( mp4File,
+                                  trackId,
+                                  sampleId,
+                                  &sample,
+                                  &this_size,
+                                  &sampleTime,
+                                  &sampleDuration,
+                                  &sampleRenderingOffset,
+                                  &isSyncSample );
+        if ( ret == false ) {
+            fprintf( stderr, "Sample read error\n" );
+            return -1;
+        }
+        printf( "Track %u, Sample %u, Length %u\n",
+                trackId, sampleId, this_size );
+
+        for ( uint32_t ix = 0; ix < this_size; ix++ ) {
+            if ( ( ix % 16 ) == 0 ) printf( "\n%04u ", ix );
+            printf( "%02x ", sample[ix] );
+        }
+        printf( "\n" );
+    }
+    else {
+        if ( trackId == 0 ) {
+            uint32_t numTracks = MP4GetNumberOfTracks( mp4File );
+
+            for ( uint32_t i = 0; i < numTracks; i++ ) {
+                trackId = MP4FindTrackId( mp4File, i );
+                DumpTrack( mp4File, trackId );
+            }
+        }
+        else {
+            DumpTrack( mp4File, trackId );
+        }
+    }
+
+    MP4Close( mp4File );
+
+    return( 0 );
+}
diff --git a/src/main.cpp b/src/main.cpp
index 6c86d15..358a24e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -79,7 +79,7 @@ bool convertToExactRanges(Option &opt)
             /* test if it's close enough to one of the well known rate. */
             double diff = std::abs(delta - sp->delta);
             if (diff < bound) {
-                FPSRange range = { dp->first, sp->num, sp->denom };
+                FPSRange range = { static_cast<uint32_t>(dp->first), sp->num, sp->denom };
                 ranges.push_back(range);
                 break;
             }
@@ -342,9 +342,9 @@ void execute(Option &opt)
         mp4v2::impl::MP4File file;
         std::fprintf(stderr, "Reading MP4 stream...\n");
         if (opt.inplace)
-            file.Modify(opt.src);
+            file.Modify(opt.src, 0, 0);
         else
-            file.Read(opt.src, 0);
+            file.Read(opt.src, 0, 0, 0);
         std::fprintf(stderr, "Done reading\n");
         MP4TrackId trackId = file.FindTrackId(0, MP4_VIDEO_TRACK_TYPE);
         mp4v2::impl::MP4Track *track = file.GetTrack(trackId);
# diff --git a/vcproj/mp4fpsmod.sln b/vcproj/mp4fpsmod.sln
# index b3fb5b3..fce1663 100644
# --- a/vcproj/mp4fpsmod.sln
# +++ b/vcproj/mp4fpsmod.sln
# @@ -11,17 +11,27 @@ EndProject
#  Global
#  	GlobalSection(SolutionConfigurationPlatforms) = preSolution
#  		Debug|Win32 = Debug|Win32
# +		Debug|x64 = Debug|x64
#  		Release|Win32 = Release|Win32
# +		Release|x64 = Release|x64
#  	EndGlobalSection
#  	GlobalSection(ProjectConfigurationPlatforms) = postSolution
#  		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Debug|Win32.ActiveCfg = Debug|Win32
#  		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Debug|Win32.Build.0 = Debug|Win32
# +		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Debug|x64.ActiveCfg = Debug|x64
# +		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Debug|x64.Build.0 = Debug|x64
#  		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Release|Win32.ActiveCfg = Release|Win32
#  		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Release|Win32.Build.0 = Release|Win32
# +		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Release|x64.ActiveCfg = Release|x64
# +		{4AFCDE75-3562-4787-8CF0-CE401A621160}.Release|x64.Build.0 = Release|x64
#  		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Debug|Win32.ActiveCfg = Debug|Win32
#  		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Debug|Win32.Build.0 = Debug|Win32
# +		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Debug|x64.ActiveCfg = Debug|x64
# +		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Debug|x64.Build.0 = Debug|x64
#  		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Release|Win32.ActiveCfg = Release|Win32
#  		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Release|Win32.Build.0 = Release|Win32
# +		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Release|x64.ActiveCfg = Release|x64
# +		{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}.Release|x64.Build.0 = Release|x64
#  	EndGlobalSection
#  	GlobalSection(SolutionProperties) = preSolution
#  		HideSolutionNode = FALSE
# diff --git a/vcproj/mp4fpsmod/mp4fpsmod.vcxproj b/vcproj/mp4fpsmod/mp4fpsmod.vcxproj
# index 21aee78..95fff09 100644
# --- a/vcproj/mp4fpsmod/mp4fpsmod.vcxproj
# +++ b/vcproj/mp4fpsmod/mp4fpsmod.vcxproj
# @@ -5,76 +5,75 @@
#        <Configuration>Debug</Configuration>
#        <Platform>Win32</Platform>
#      </ProjectConfiguration>
# +    <ProjectConfiguration Include="Debug|x64">
# +      <Configuration>Debug</Configuration>
# +      <Platform>x64</Platform>
# +    </ProjectConfiguration>
#      <ProjectConfiguration Include="Release|Win32">
#        <Configuration>Release</Configuration>
#        <Platform>Win32</Platform>
#      </ProjectConfiguration>
# +    <ProjectConfiguration Include="Release|x64">
# +      <Configuration>Release</Configuration>
# +      <Platform>x64</Platform>
# +    </ProjectConfiguration>
#    </ItemGroup>
#    <PropertyGroup Label="Globals">
#      <ProjectGuid>{4AFCDE75-3562-4787-8CF0-CE401A621160}</ProjectGuid>
#      <Keyword>Win32Proj</Keyword>
#      <RootNamespace>mp4fpsmod</RootNamespace>
#    </PropertyGroup>
# +  <PropertyGroup>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '17.0'">v143</PlatformToolset>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '16.0'">v142</PlatformToolset>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '15.0'">v141_xp</PlatformToolset>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '14.0'">v140_xp</PlatformToolset>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '12.0'">v120_xp</PlatformToolset>
# +    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '11.0'">v110_xp</PlatformToolset>
# +  </PropertyGroup>
#    <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
# -  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
# +  <PropertyGroup>
#      <ConfigurationType>Application</ConfigurationType>
#      <UseDebugLibraries>true</UseDebugLibraries>
#      <CharacterSet>Unicode</CharacterSet>
#    </PropertyGroup>
# -  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
# -    <ConfigurationType>Application</ConfigurationType>
# -    <UseDebugLibraries>false</UseDebugLibraries>
# -    <WholeProgramOptimization>true</WholeProgramOptimization>
# -    <CharacterSet>Unicode</CharacterSet>
# -  </PropertyGroup>
#    <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
#    <ImportGroup Label="ExtensionSettings">
#    </ImportGroup>
# -  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
# -    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
# -  </ImportGroup>
# -  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
# +  <ImportGroup Label="PropertySheets">
#      <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
#    </ImportGroup>
#    <PropertyGroup Label="UserMacros" />
# -  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
# -    <LinkIncremental>true</LinkIncremental>
# -  </PropertyGroup>
# -  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
# -    <LinkIncremental>false</LinkIncremental>
# -  </PropertyGroup>
# -  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
# +  <ItemDefinitionGroup>
#      <ClCompile>
# -      <PrecompiledHeader>
# -      </PrecompiledHeader>
#        <WarningLevel>Level3</WarningLevel>
# -      <Optimization>Disabled</Optimization>
# -      <PreprocessorDefinitions>WIN32;MP4V2_USE_STATIC_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
# -      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;..\..\mp4v2\src</AdditionalIncludeDirectories>
# +      <PreprocessorDefinitions>WIN32;MP4V2_USE_STATIC_LIB;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
# +      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;..\..\mp4v2\src;..\mp4v2\include</AdditionalIncludeDirectories>
#      </ClCompile>
#      <Link>
#        <SubSystem>Console</SubSystem>
#        <GenerateDebugInformation>true</GenerateDebugInformation>
# -      <AdditionalDependencies>..\mp4v2\Debug\mp4v2.lib;%(AdditionalDependencies)</AdditionalDependencies>
#      </Link>
#    </ItemDefinitionGroup>
# -  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
# +  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
# +    <UseDebugLibraries>true</UseDebugLibraries>
# +  </PropertyGroup>
# +  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
# +    <UseDebugLibraries>false</UseDebugLibraries>
# +  </PropertyGroup>
# +  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
# +    <ClCompile>
# +      <Optimization>Disabled</Optimization>
# +    </ClCompile>
# +  </ItemDefinitionGroup>
# +  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
#      <ClCompile>
# -      <WarningLevel>Level3</WarningLevel>
# -      <PrecompiledHeader>
# -      </PrecompiledHeader>
#        <Optimization>MaxSpeed</Optimization>
# -      <FunctionLevelLinking>true</FunctionLevelLinking>
# -      <IntrinsicFunctions>true</IntrinsicFunctions>
# -      <PreprocessorDefinitions>WIN32;MP4V2_USE_STATIC_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
# -      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;..\..\mp4v2\src</AdditionalIncludeDirectories>
# +      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
#      </ClCompile>
#      <Link>
# -      <SubSystem>Console</SubSystem>
# -      <GenerateDebugInformation>true</GenerateDebugInformation>
#        <EnableCOMDATFolding>true</EnableCOMDATFolding>
#        <OptimizeReferences>true</OptimizeReferences>
# -      <AdditionalDependencies>..\mp4v2\Release\mp4v2.lib;%(AdditionalDependencies)</AdditionalDependencies>
#      </Link>
#    </ItemDefinitionGroup>
#    <ItemGroup>
# @@ -95,6 +94,11 @@
#      <ClInclude Include="..\..\src\strcnv.h" />
#      <ClInclude Include="..\..\src\utf8_codecvt_facet.hpp" />
#    </ItemGroup>
# +  <ItemGroup>
# +    <ProjectReference Include="..\mp4v2\mp4v2.vcxproj">
# +      <Project>{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}</Project>
# +    </ProjectReference>
# +  </ItemGroup>
#    <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
#    <ImportGroup Label="ExtensionTargets">
#    </ImportGroup>
diff --git a/vcproj/mp4v2/include/mp4v2/project.h b/vcproj/mp4v2/include/mp4v2/project.h
new file mode 100644
index 0000000..b34272a
--- /dev/null
+++ b/vcproj/mp4v2/include/mp4v2/project.h
@@ -0,0 +1,25 @@
+#ifndef MP4V2_PROJECT_H
+#define MP4V2_PROJECT_H
+
+/*****************************************************************************/
+
+#define MP4V2_PROJECT_name            "MP4v2"
+#define MP4V2_PROJECT_name_lower      "mp4v2"
+#define MP4V2_PROJECT_name_upper      "MP4V2"
+#define MP4V2_PROJECT_name_formal     "MP4v2 2.1.2"
+#define MP4V2_PROJECT_url_website     "https://mp4v2.org"
+#define MP4V2_PROJECT_url_downloads   "https://github.com/enzo1982/releases"
+#define MP4V2_PROJECT_url_discussion  "https://github.com/enzo1982/discussions"
+#define MP4V2_PROJECT_url_bugreport   "https://github.com/enzo1982/issues"
+#define MP4V2_PROJECT_support         "<support@mp4v2.org>"
+#define MP4V2_PROJECT_version         "2.1.2"
+#define MP4V2_PROJECT_version_hex     0x00020102
+#define MP4V2_PROJECT_version_major   2
+#define MP4V2_PROJECT_version_minor   1
+#define MP4V2_PROJECT_version_point   2
+#define MP4V2_PROJECT_repo_url        "git@github.com:enzo1982/mp4v2.git"
+#define MP4V2_PROJECT_build           "Thu Feb 09 23:15:44 UTC 2023"
+
+/*****************************************************************************/
+
+#endif /* MP4V2_PROJECT_H */
diff --git a/vcproj/mp4v2/mp4v2.vcxproj b/vcproj/mp4v2/mp4v2.vcxproj
index cf2ef7f..d2cd32a 100644
--- a/vcproj/mp4v2/mp4v2.vcxproj
+++ b/vcproj/mp4v2/mp4v2.vcxproj
@@ -5,89 +5,71 @@
       <Configuration>Debug</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
     <ProjectConfiguration Include="Release|Win32">
       <Configuration>Release</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{86A064E2-C81B-4EEE-8BE0-A39A2E7C7C76}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
   </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
+  <PropertyGroup>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '17.0'">v143</PlatformToolset>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '16.0'">v142</PlatformToolset>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '15.0'">v141_xp</PlatformToolset>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '14.0'">v140_xp</PlatformToolset>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '12.0'">v120_xp</PlatformToolset>
+    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(MSBuildToolsVersion)' == '11.0'">v110_xp</PlatformToolset>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup>
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+  <ImportGroup>
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+  <ItemDefinitionGroup Condition="'$([System.Convert]::ToInt32($(PlatformToolset.Substring(1, 3))))' &lt; 140">
+    <ClCompile>
+      <PreprocessorDefinitions>snprintf=_snprintf;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_LIB;MP4V2_USE_STATIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <WarningLevel>Level3</WarningLevel>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
   </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;MP4V2_USE_STATIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
     </ClCompile>
-    <Lib>
-      <OutputFile>$(OutDir)mp4v2.lib</OutputFile>
-    </Lib>
-    <PreBuildEvent>
-      <Command>copy ..\..\mp4v2\include\mp4v2\project.h.in ..\..\mp4v2\include\mp4v2\project.h</Command>
-    </PreBuildEvent>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
     <ClCompile>
-      <AdditionalIncludeDirectories>..\..\mp4v2;..\..\mp4v2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;MP4V2_USE_STATIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <Optimization>MaxSpeed</Optimization>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
     </ClCompile>
-    <Lib>
-      <OutputFile>$(OutDir)mp4v2.lib</OutputFile>
-    </Lib>
-    <PreBuildEvent>
-      <Command>copy ..\..\mp4v2\include\mp4v2\project.h.in ..\..\mp4v2\include\mp4v2\project.h</Command>
-    </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="..\..\mp4v2\libplatform\platform_win32.cpp" />
@@ -176,7 +158,6 @@
     <ClCompile Include="..\..\mp4v2\src\odcommands.cpp" />
     <ClCompile Include="..\..\mp4v2\libplatform\prog\option.cpp" />
     <ClCompile Include="..\..\mp4v2\src\qtff\PictureAspectRatioBox.cpp" />
-    <ClCompile Include="..\..\mp4v2\libplatform\process\process_win32.cpp" />
     <ClCompile Include="..\..\mp4v2\src\qosqualifiers.cpp" />
     <ClCompile Include="..\..\mp4v2\libplatform\number\random_win32.cpp" />
     <ClCompile Include="..\..\mp4v2\src\rtphint.cpp" />
@@ -190,4 +171,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
