{
  lib,
  stdenvNoCC,
  nixos,
  writeText,
  util-linux,
  e2fsprogs,
}:

let
  stdenv = stdenvNoCC;
in

let
  # build `initrd` and `root` using a NixOS configuration so that we
  # don't need to rewrite build scripts for a distro with nixpkgs
  # kernel is just as easily copied with or without a NixOS configuration
  nixosConfig = nixos (
    {
      config,
      lib,
      pkgs,
      modulesPath,
      ...
    }:
    {
      imports = [
        "${modulesPath}/image/repart.nix"
        "${modulesPath}/profiles/image-based-appliance.nix"
        "${modulesPath}/profiles/qemu-guest.nix"
      ];

      # we require an initrd to be built by pre-existing NixOS scripts
      # configure it a bit for the appliance
      boot.initrd.enable = true;
      boot.initrd.systemd.enable = true;
      boot.initrd.systemd.repart.enable = true;
      boot.initrd.kernelModules = [ "ext4" ];
      boot.initrd.services.udev.packages = [ pkgs.systemdMinimal ];

      # kernel is separate and gets called by qemu
      # adding anything here is utterly useless
      # rather, add it to `passthru.appendToCmdline`
      boot.kernelParams = [ ];
      boot.kernelPackages = pkgs.linuxPackages; # longterm kernel is tested more in nixpkgs
      boot.kernelModules = [
        "nbd" # in case `guestfs_network` is set to `1`
        "vhost_net" # in case `guestfs_network` is set to `1`
        "virtio_console" # required by `guestfsd` for host<->guest communication
      ];
      # again, kernel is separate and gets called by qemu
      # a bootloader is never used in that chain
      boot.loader.grub.enable = lib.mkForce false;
      boot.loader.systemd-boot.enable = lib.mkForce false;

      # swap isn't necessary in a minimal appliance
      swapDevices = [ ];
      fileSystems."/" = {
        device = "/dev/root";
        fsType = "ext4";
        options = [ "defaults" ];
      };
      # rootfs configuration
      image.repart.name = "root";
      image.repart.partitions = {
        "10-root" = {
          storePaths = [ config.system.build.toplevel ];
          repartConfig = {
            Type = "root";
            Label = "root";
            Format = "ext4";
            MountPoint = "/";
            # this image contains "everything" so it requires a minimum
            # size of 1024M but the final ext4 "filesystem" (after
            # "extracting" the ext4 filesystem from this image and
            # shrinking it) we get an image that is roughly under 400M :D
            SizeMinBytes = "1024M";
            SizeMaxBytes = "2048M";
            # libguestfs **requires** a UUID, this is generated by `uuidgen(1)`
            UUID = "04288fff-ce9c-4692-bf43-4bf72e6f4790";
          };
        };
      };

      # **essential** packages for libguestfs operations
      environment.systemPackages = with pkgs; [
        lvm2
        parted
      ];
      systemd.tmpfiles.rules = [
        # PATH is overridden by libguestfs and assume FHS-compliance
        # https://github.com/libguestfs/libguestfs/blob/4349548c837811fd939ccea5b7032d68605e634d/daemon/guestfsd.c#L181
        # https://bugzilla.redhat.com/show_bug.cgi?id=502074#c5
        "L+ /bin - - - - /run/current-system/sw/bin"
        "L+ /sbin - - - - /run/current-system/sw/bin"
      ];
      systemd.services.guestfsd = {
        description = "Communication with libguestfs on host and this guest";
        wantedBy = [ "multi-user.target" ];
        # the device in the guest that gets created on the guest through
        # which libguestfs on host communicates with guestfsd on guest
        requires = [ "dev-virtio\x2dports-org.libguestfs.channel.0.device" ];
        serviceConfig = {
          Type = "exec";
          ExecStart = "${pkgs.libguestfs.guestfsd}/bin/guestfsd -r --verbose";
          StandardOutput = "journal+console";
          StandardError = "journal+console";
          Restart = "no";
        };
      };

      # doesn't matter in an appliance but needs to be set
      system.stateVersion = lib.versions.majorMinor lib.version;
      networking.hostName = "nixos-appliance";
      # **never** turn this off please, it loads our kmods
      systemd.services.systemd-modules-load.enable = lib.mkForce true;

      # "trimming" of items not useful in a minimal appliance
      fonts.enableDefaultPackages = lib.mkForce false;
      fonts.fontconfig.enable = lib.mkForce false;
      hardware.enableRedistributableFirmware = lib.mkForce false;
      networking.dhcpcd.enable = lib.mkForce false;
      networking.firewall.enable = lib.mkForce false;
      networking.useDHCP = lib.mkForce false;
      networking.useNetworkd = lib.mkForce false;
      nix.enable = lib.mkForce false;
      programs.nano.enable = lib.mkForce false;
      programs.ssh.package = lib.mkForce pkgs.systemdMinimal;
      security.polkit.enable = lib.mkForce false;
      security.sudo.enable = lib.mkForce false;
      services.openssh.enable = lib.mkForce false;
      services.timesyncd.enable = lib.mkForce false;
      services.udisks2.enable = lib.mkForce false;
      system.disableInstallerTools = lib.mkForce true;
      system.rebuild.enableNg = lib.mkForce false;
      systemd.services."autovt@".enable = lib.mkForce false;
      systemd.services."getty@tty1".enable = lib.mkForce false;
      systemd.services."serial-getty@ttyS0".enable = lib.mkForce false;
      systemd.services.dbus.enable = lib.mkForce false;
      systemd.services.nscd.enable = lib.mkForce false;
      systemd.services.nsncd.enable = lib.mkForce false;
      systemd.services.systemd-hwdb-update.enable = lib.mkForce false;
      systemd.services.systemd-logind.enable = lib.mkForce false;
      systemd.services.systemd-networkd.enable = lib.mkForce false;
      systemd.services.systemd-resolved.enable = lib.mkForce false;
      systemd.services.systemd-udevd.enable = lib.mkForce true;
      systemd.services.systemd-user-sessions.enable = lib.mkForce false;
      systemd.targets.network.enable = lib.mkForce false;
      users.allowNoPasswordLogin = lib.mkForce true;
    }
  );

  readmeFixed = writeText "README.fixed" ''
    This is a "fix appliance" which means a pre-build binary appliance for
    libguestfs. This was built using the `libguestfs-appliance-nixos`
    package in the nixpkgs repository.

    The appliance consists of:
    * kernel
    * initrd
    * root
    * README.fixed
    * append-to-cmdline

    This appliance is built for '${stdenv.targetPlatform.system}'.
  '';

  appendToCmdline = "init=${nixosConfig.config.system.build.toplevel}/init rw";
  # for when you can't access `libguestfs-appliance-nixos.appendToCmdline`
  appendToCmdlineFile = writeText "append-to-cmdline" appendToCmdline;
in

stdenv.mkDerivation {
  pname = "libguestfs-appliance-nixos";
  version = "1.0.0";

  dontUnpack = true;

  buildInputs = [ nixosConfig.config.system.build.toplevel ];
  nativeBuildInputs = [
    util-linux
    e2fsprogs
  ];

  buildPhase = ''
    # libguestfs expects a raw ext4 filesystem for what to mount on /
    # not the full disk image
    PART_LINE=$(sfdisk --dump ${nixosConfig.config.system.build.image}/root.raw | grep "start=" | head -1)
    PART_START=$(echo "$PART_LINE" | sed -n 's/.*start= *\([0-9]*\).*/\1/p')
    PART_SIZE=$(echo "$PART_LINE" | sed -n 's/.*size= *\([0-9]*\).*/\1/p')
    dd if=${nixosConfig.config.system.build.image}/root.raw of=root bs=512 skip=$PART_START count=$PART_SIZE status=progress
    if e2fsck -n root; then
      echo 'Successfully created individual ext4 filesystem'
    else
      echo 'Failed to create an individual ext4 filesystem'
      exit 1
    fi

    # reduce the size of final `root` image
    resize2fs -M root
    if e2fsck -n root; then
      echo 'Successfully shrunk ext4 filesystem'
    else
      echo 'Failed to shrink ext4 filesystem'
      exit 1
    fi
    BLOCK_SIZE=$(tune2fs -l root | grep "Block size:" | awk '{print $3}')
    BLOCK_COUNT=$(tune2fs -l root | grep "Block count:" | awk '{print $3}')
    NEW_SIZE=$((BLOCK_SIZE * BLOCK_COUNT))
    truncate --no-create --size $NEW_SIZE root
  '';

  installPhase = ''
    runHook preInstall

    mkdir -p $out
    cp ${readmeFixed} $out/README.fixed
    cp ${nixosConfig.config.system.build.kernel}/${nixosConfig.config.system.boot.loader.kernelFile} $out/kernel
    cp ${nixosConfig.config.system.build.initialRamdisk}/initrd $out/initrd
    cp ${appendToCmdlineFile} $out/append-to-cmdline
    mv root $out/root

    runHook postInstall
  '';

  passthru.appendToCmdline = appendToCmdline;

  meta = {
    description = "A fixed appliance for libguestfs to use, built from NixOS";
    platforms = lib.platforms.linux;
    hydraPlatforms = [ ];
    maintainers = with lib.maintainers; [ thefossguy ];
  };
}
