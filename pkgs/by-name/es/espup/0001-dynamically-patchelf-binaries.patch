diff --git a/src/toolchain/mod.rs b/src/toolchain/mod.rs
index b268916..4f22267 100644
--- a/src/toolchain/mod.rs
+++ b/src/toolchain/mod.rs
@@ -210,6 +210,7 @@ pub async fn download_file(
                 return Err(Error::UnsuportedFileExtension(extension.to_string()));
             }
         }
+        nix_patchelf_directory_if_needed(Path::new(output_directory));
     } else {
         debug!("Creating file: '{file_path}'");
         let mut out = File::create(&file_path)?;
@@ -218,6 +219,163 @@ pub async fn download_file(
     Ok(file_path)
 }
 
+fn nix_patchelf_directory_if_needed(directory: &Path) {
+    use std::fs::read_dir;
+
+    fn walk_dir(dir: &Path, callback: &mut dyn FnMut(&Path)) {
+        if let Ok(entries) = read_dir(dir) {
+            for entry in entries.flatten() {
+                let path = entry.path();
+                if path.is_dir() {
+                    walk_dir(&path, callback);
+                } else {
+                    callback(&path);
+                }
+            }
+        }
+    }
+
+    let mut patch_count = 0;
+    walk_dir(directory, &mut |path| {
+        if nix_patchelf_if_needed(path) {
+            patch_count += 1;
+        }
+    });
+
+    if patch_count > 0 {
+        debug!("Patched {patch_count} ELF files in {}", directory.display());
+    }
+}
+
+fn nix_patchelf_if_needed(dest_path: &Path) -> bool {
+    use std::fs::File;
+    use std::os::unix::fs::FileExt;
+
+    struct ELFReader<'a> {
+        file: &'a mut File,
+        is_32bit: bool,
+        is_little_end: bool,
+    }
+
+    impl<'a> ELFReader<'a> {
+        const MAGIC_NUMBER: &'static [u8] = &[0x7F, 0x45, 0x4c, 0x46];
+        const ET_EXEC: u16 = 0x2;
+        const ET_DYN: u16 = 0x3;
+        const PT_INTERP: u32 = 0x3;
+
+        fn new(file: &'a mut File) -> Option<Self> {
+            use std::io::Read;
+            let mut magic_number = [0; 4];
+            file.read_exact(&mut magic_number).ok()?;
+            if Self::MAGIC_NUMBER != magic_number {
+                return None;
+            }
+            let mut ei_class = [0; 1];
+            file.read_exact_at(&mut ei_class, 0x4).ok()?;
+            let is_32bit = ei_class[0] == 1;
+            let mut ei_data = [0; 1];
+            file.read_exact_at(&mut ei_data, 0x5).ok()?;
+            let is_little_end = ei_data[0] == 1;
+            Some(Self {
+                file,
+                is_32bit,
+                is_little_end,
+            })
+        }
+
+        fn is_exec_or_dyn(&self) -> bool {
+            let e_type = self.read_u16_at(0x10);
+            e_type == Self::ET_EXEC || e_type == Self::ET_DYN
+        }
+
+        fn e_phoff(&self) -> u64 {
+            if self.is_32bit {
+                self.read_u32_at(0x1C) as u64
+            } else {
+                self.read_u64_at(0x20)
+            }
+        }
+
+        fn e_phentsize(&self) -> u64 {
+            let offset = if self.is_32bit { 0x2A } else { 0x36 };
+            self.read_u16_at(offset) as u64
+        }
+
+        fn e_phnum(&self) -> u64 {
+            let offset = if self.is_32bit { 0x2C } else { 0x38 };
+            self.read_u16_at(offset) as u64
+        }
+
+        fn has_interp(&self) -> bool {
+            let e_phoff = self.e_phoff();
+            let e_phentsize = self.e_phentsize();
+            let e_phnum = self.e_phnum();
+            for i in 0..e_phnum {
+                let p_type = self.read_u32_at(e_phoff + i * e_phentsize);
+                if p_type == Self::PT_INTERP {
+                    return true;
+                }
+            }
+            false
+        }
+
+        fn read_u16_at(&self, offset: u64) -> u16 {
+            let mut data = [0; 2];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u16::from_le_bytes(data)
+            } else {
+                u16::from_be_bytes(data)
+            }
+        }
+
+        fn read_u32_at(&self, offset: u64) -> u32 {
+            let mut data = [0; 4];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u32::from_le_bytes(data)
+            } else {
+                u32::from_be_bytes(data)
+            }
+        }
+
+        fn read_u64_at(&self, offset: u64) -> u64 {
+            let mut data = [0; 8];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u64::from_le_bytes(data)
+            } else {
+                u64::from_be_bytes(data)
+            }
+        }
+    }
+
+    let Some(mut dest_file) = File::open(dest_path).ok() else {
+        return false;
+    };
+    let Some(elf) = ELFReader::new(&mut dest_file) else {
+        return false;
+    };
+    if !elf.is_exec_or_dyn() {
+        return false;
+    }
+    let mut patch_command = std::process::Command::new("@patchelf@/bin/patchelf");
+    if elf.has_interp() {
+        patch_command
+            .arg("--set-interpreter")
+            .arg("@dynamicLinker@");
+    }
+    // Always add rpath for libstdc++ and other libs
+    patch_command.arg("--add-rpath").arg("@libPath@");
+
+    debug!("patching {dest_path:?} using patchelf");
+    if let Err(err) = patch_command.arg(dest_path).output() {
+        warn!("failed to execute patchelf: {err:?}");
+        return false;
+    }
+    true
+}
+
 /// Installs or updates the Espressif Rust ecosystem.
 pub async fn install(args: InstallOpts, install_mode: InstallMode) -> Result<()> {
     match install_mode {
