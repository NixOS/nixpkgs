{
  lib,
  bobcat,
  fetchFromGitLab,
  icmake,
  stdenv,
  yodl,
}:

stdenv.mkDerivation (finalAttrs: {
  pname = "flexcpp";
  version = "2.16.00";

  src = fetchFromGitLab {
    name = "flexcpp-source-${finalAttrs.version}";
    owner = "fbb-git";
    repo = "flexcpp";
    rev = finalAttrs.version;
    hash = "sha256-hnsWJATdA24kxuOmH7x8HMH9nPFXAAThofXvshuWk0s=";
  };

  buildInputs = [
    bobcat
  ];

  nativeBuildInputs = [
    icmake
    yodl
  ];

  sourceRoot = "${finalAttrs.src.name}/flexc++";

  strictDeps = true;

  postPatch = ''
    substituteInPlace INSTALL.im --replace-fail /usr $out
    patchShebangs .
  '';

  buildPhase = ''
    runHook preBuild

    ./build man
    ./build manual
    ./build program

    runHook postBuild
  '';

  installPhase = ''
    runHook preInstall

    ./build install x

    runHook postInstall
  '';

  meta = {
    homepage = "https://fbb-git.gitlab.io/flexcpp/";
    description = "Tool for generating lexical scanners in C++";
    longDescription = ''
      Flexc++ was designed after `flex'. Flexc++ offers as compared to flex's
      C++ option a cleaner class-design.

      Flexc++ generates a scanner class that is ready for use, as well as a
      member function producing the lexical scanner tokens (lex()). The class
      can easily be provided with additional members without the need for
      polymorphic functions. Consequently, classes generated by flexc++ have no
      virtual members and actually have but one public member: lex(), replacing
      the old-style flex and flex++ yylex() function.

      Flexc++ offers many options, among which an option to define classes
      generated by flexc++ in a separate namespace. This allows developers to
      define additional symbols, even outside of the class generated by flexc++,
      without encountering name-collision problems. With flexc++, artificial
      means to prevent name-collisions, like the yy-conventions used by flex and
      flex++ are no longer required.  Flexc++ generates C++ code. If C code is
      required, flex should be used. Flexc++'s grammar requirements are highly
      compatible with flex's requirements, so converting a flex grammar into a
      flexc++ grammar should be fairly simple.

      In addition to the flexc++ scanner generator itself and several skeleton
      files, the package contains an extensive man-page, as well as a full
      manual rewritten after the original flex manual, and several examples.
    '';
    changelog = "https://gitlab.com/fbb-git/flexcpp/-/blob/master/flexc++/changelog";
    license = lib.licenses.gpl3Plus;
    maintainers = with lib.maintainers; [ AndersonTorres ];
    mainProgram = "flexc++";
    platforms = lib.platforms.all;
  };
})
